<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 æ•´æœºæµ‹è¯• (4Gç‰ˆ)</title>
    <style>
        :root {
            --color-primary: #007bff;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-light: #f8f9fa;
            --color-dark: #343a40;
            --border-radius: 8px;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
        }
        body { font-family: system-ui, -apple-system, Roboto, sans-serif; padding: 5px 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: var(--border-radius); padding: 15px; margin: 10px 0; background: #fff; box-shadow: var(--shadow-sm); }
        .panel-blue { border-color: var(--color-primary); background: #f0f8ff; }
        .panel-green { border-color: var(--color-success); background: #f0fff0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background: #fff; border-radius: var(--border-radius); overflow: hidden; box-shadow: var(--shadow-sm); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background: var(--color-light); color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: var(--color-success); }
        .fail { background: #f8d7da; color: var(--color-danger); }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 160px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .table-container { max-height: 520px; overflow-y: auto; }
        .test-result-display {
            margin: 0; padding: 10px; border-radius: var(--border-radius); text-align: center; font-size: 30px; font-weight: bold; box-shadow: 0 3px 6px rgba(0,0,0,0.1); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            transition: background 0.3s ease, color 0.3s ease;
        }
        .test-result-display.pass { background: linear-gradient(135deg, #28a745, #20c997); color: white; border: 2px solid #1e7e34; }
        .test-result-display.fail { background: linear-gradient(135deg, #dc3545, #ff6b6b); color: white; border: 2px solid #bd2130; }
        .test-result-display.waiting { background: linear-gradient(135deg, #007bff, #3da9fc); color: white; border: 2px solid #0056b3; }
        .test-result-display.default { background: #f8f9fa; color: #6c757d; border: 2px solid #dee2e6; }
        .sim-label { font-size: 18px; display: flex; align-items: center; cursor: pointer; margin-left: auto; white-space: nowrap; }
        .sim-label input { transform: scale(1.5); margin-right: 5px; }
    </style>
</head>
<body>
<!-- ä¸»æ§ç•Œé¢ -->
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
    <h1 style="margin: 5px 0;">æ•´æœºæµ‹è¯• (4Gç‰ˆ)</h1>
    <div style="display: flex; align-items: center; gap: 10px;">
        <button class="btn" id="switchVerisonBtn" style="background: #28a745; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°WIFIç‰ˆ</button>
        <button class="btn" id="switchInterfaceBtn" style="background: #007bff; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<!-- è®¾å¤‡è¿æ¥é¢æ¿ -->
<div class="panel">
    <div class="grid">
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Aï¼ˆSERIAL-Aï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput1" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice1Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice1Btn">è¿æ¥</button>
                <div id="device1Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox1" checked> å·²æ’å¡</label>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Bï¼ˆSERIAL-Bï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput2" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice2Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice2Btn">è¿æ¥</button>
                <div id="device2Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox2" checked> å·²æ’å¡</label>
            </div>
        </div>
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Cï¼ˆSERIAL-Cï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput3" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice3Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice3Btn">è¿æ¥</button>
                <div id="device3Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox3" checked> å·²æ’å¡</label>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Dï¼ˆSERIAL-Dï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput4" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice4Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice4Btn">è¿æ¥</button>
                <div id="device4Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox4" checked> å·²æ’å¡</label>
            </div>
        </div>
    </div>
</div>

<!-- çŠ¶æ€æ˜¾ç¤º -->
 <div class="panel">
    <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin: 15px 0;">
        
        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-1" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Aæœªè¿æ¥</div>
            <div id="testResultDisplay-3" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Cæœªè¿æ¥</div>
        </div>

        <img id="deviceImage4" src="image.png" alt="è®¾å¤‡å›¾ç‰‡" style="width: 50%; border-radius: 8px; box-shadow: var(--shadow-sm);"> 

        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-2" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Bæœªè¿æ¥</div>
            <div id="testResultDisplay-4" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Dæœªè¿æ¥</div>
        </div>

    </div>
</div>
<!-- æµ‹è¯•ç»“æœè¡¨æ ¼ -->
<div class="panel">
    <div class="table-container">
        <table>
            <thead><tr><th>è®¾å¤‡å·</th><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
            <tbody id="wholeMachineResultBody"></tbody>
        </table>
    </div>
</div>

<!-- æ—¥å¿— -->
<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>

    (function() {
        'use strict';
        const CONFIG = {
            AES: { KEY_STRING: "me%ov2Ied|eicegh", IV_STRING: "me%ov2Ied|eicegh" },
            URLS: { TEST: "http://gw.3wlink.cn:22011/?dgwkey=", REPORT: "https://daantest.free.beeceptor.com" },
            BAUD_RATE: 115200,
            TIMEOUTS: { COMMAND: 5000, RESPONSE: 1000, FETCH: 5000, REPORT: 10000 , TEST_URL_WAIT: 10000},
            AUTO_REPORT: true,
            DEVICE_COUNT: 4,
            RETRY_COUNT: 2,
            LOG_LIMIT: 100,
        };

        const UI = {
            logBox: document.getElementById('logBox'),
            resultBody: document.getElementById('wholeMachineResultBody'),
            testResultDisplays: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => document.getElementById(`testResultDisplay-${i + 1}`)),
            devicePanels: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => ({
                selectBtn: document.getElementById(`selectDevice${i + 1}Btn`),
                connectBtn: document.getElementById(`connectDevice${i + 1}Btn`),
                msg: document.getElementById(`device${i + 1}Msg`),
                snInput: document.getElementById(`snInput${i + 1}`),
                simCheckbox: document.getElementById(`simCardCheckbox${i + 1}`)
            }))
        };

        /**
         * AES åŠ å¯†å·¥å…· 
         */
        const DgwCrypto = {
            _key: null, _iv: null,
            async init() {
                if (this._key) return;
                try {
                    const keyBytes = new TextEncoder().encode(CONFIG.AES.KEY_STRING);
                    this._iv = new TextEncoder().encode(CONFIG.AES.IV_STRING);
                    this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
                } catch (error) {
                    console.error("AES_CBCå¯†é’¥å¯¼å…¥å¤±è´¥:", error);
                    throw error;
                }
            },
            async encrypt(plainText) {
                if (!this._key) await this.init();
                try {
                    const textBytes = new TextEncoder().encode(plainText);
                    const blockSize = 16;
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    const paddedData = new Uint8Array(textBytes.length + (paddingNeeded === blockSize ? 0 : paddingNeeded));
                    paddedData.set(textBytes);
                    const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                    const truncated = new Uint8Array(encrypted).slice(0, paddedData.length);
                    return btoa(String.fromCharCode(...truncated)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                } catch (error) {
                    console.error('åŠ å¯†å¤±è´¥:', error);
                    return null;
                }
            }
        };

        /**
         * ç®¡ç†ä¸²å£çš„è¿æ¥ã€è¯»å†™å’Œæ–­å¼€ã€‚
         */
        class SerialManager {
            constructor(id) {
                this.id = id;
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.connected = false;
                this.readLoopActive = false;
            }
            async select() {
                try {
                    this.port = await navigator.serial.requestPort();
                    return true;
                } catch {
                    return false;
                }
            }
            async connect(baudRate) {
                if (!this.port) return false;
                try {
                    await this.port.open({ baudRate });
                    this.writer = this.port.writable?.getWriter();
                    this.connected = true;
                    return true;
                } catch (e) {
                    console.error(`è®¾å¤‡ ${String.fromCharCode(64 + this.id)} è¿æ¥å¤±è´¥:`, e);
                    return false;
                }
            }
            async disconnect() {
                await this.stopReadLoop();
                if (this.writer) {
                    try { await this.writer.close(); } catch {}
                    this.writer = null;
                }
                if (this.port?.readable) {
                    try { await this.port.readable.cancel(); } catch {}
                }
                if (this.port) {
                    try { await this.port.close(); } catch {}
                }
                this.connected = false;
            }
            async readLoop(onData, onError) {
                if (!this.port?.readable || !this.connected) return;
                this.readLoopActive = true;
                try {
                    while (this.connected && this.readLoopActive) {
                        this.reader = this.port.readable.getReader();
                        const { value, done } = await this.reader.read();
                        this.reader.releaseLock();
                        this.reader = null;
                        if (done) break;
                        if (onData) onData(new TextDecoder().decode(value));
                    }
                } catch (e) {
                    if (this.readLoopActive && onError) onError(e);
                } finally {
                    this.readLoopActive = false;
                }
            }
            async stopReadLoop() {
                if (this.readLoopActive) {
                    this.readLoopActive = false;
                    if (this.reader) {
                        try { await this.reader.cancel(); } catch {}
                    }
                }
            }
        }

        /**
         * ç®¡ç†æ‰€æœ‰UIæ›´æ–°ï¼ŒåŒ…æ‹¬æ—¥å¿—ã€è¡¨æ ¼å’ŒçŠ¶æ€æ˜¾ç¤ºã€‚
         */
        class UIManager {
            constructor() {
                this.logMessages = [];
                this.deviceRows = new Map();
            }

            initDeviceRows() {
                for (let i = 1; i <= CONFIG.DEVICE_COUNT; i++) {
                    const row = UI.resultBody.insertRow();
                    row.id = `device-row-${i}`;
                    for (let j = 0; j < 9; j++) row.insertCell();
                    row.cells[0].textContent = `è®¾å¤‡${String.fromCharCode(64 + i)}`;
                    this.deviceRows.set(i, row);
                }
            }

            log(msg) {
                const timestamp = new Date().toLocaleTimeString();
                this.logMessages.push(`[${timestamp}] ${msg}`);
                if (this.logMessages.length > CONFIG.LOG_LIMIT) {
                    this.logMessages.shift();
                }
                UI.logBox.textContent = this.logMessages.join('\n');
                UI.logBox.scrollTop = UI.logBox.scrollHeight;
            }

            updateDeviceMessage(id, text, type = 'info') {
                const el = UI.devicePanels[id - 1].msg;
                if (!el) return;
                el.textContent = text;
                el.style.color = { error: 'red', success: 'green' }[type] || 'black';
            }

            updateButtons(devices) {
                devices.forEach((device, i) => {
                    const panel = UI.devicePanels[i];
                    const isConnected = device.serial.connected;

                    panel.connectBtn.textContent = isConnected ? 'æ–­å¼€' : 'è¿æ¥';
                    panel.connectBtn.disabled = !device.serial.connected && !device.serial.port;
                    panel.selectBtn.disabled = device.inProgress;
                    
                    panel.snInput.disabled = !isConnected || device.inProgress;
                    if (isConnected) {
                        panel.snInput.placeholder = 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...';
                    } else {
                        panel.snInput.placeholder = 'è¯·è¿æ¥è®¾å¤‡...';
                    }
                });
            }

            addOrUpdateTestResult(record) {
                const row = this.deviceRows.get(record.deviceId);
                if (!row) return;

                if (record.errorReason === 'SNä¸åŒ¹é…') {
                    row.cells[1].textContent = record.timestamp;
                    row.cells[2].textContent = record.sn || 'æœªçŸ¥';
                    row.cells[2].className = 'fail';
                    row.cells[3].textContent = '-';
                    row.cells[3].className = '';
                    row.cells[4].textContent = '-';
                    row.cells[4].className = '';
                    row.cells[5].textContent = '-';
                    row.cells[5].className = '';
                    row.cells[6].textContent = '-';
                    row.cells[6].className = '';
                    row.cells[7].textContent = 'SNä¸åŒ¹é…';
                    row.cells[7].className = 'fail';
                    row.cells[8].textContent = '-';
                    row.cells[8].className = '';
                    return;
                }

                const getStatusDisplay = (val) => {
                    if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
                    if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
                    if (val === 'æœªæ’å¡') return { text: 'æœªæ’å¡', className: 'fail' };
                    return { text: 'å¾…æµ‹è¯•', className: '' };
                };

                const getInfoCell = (value, failText = 'å¼‚å¸¸') => ({
                    text: value || failText,
                    className: value ? 'pass' : 'fail'
                });

                const getIccidCell = (iccid) => {
                    if (iccid && iccid !== 'æœªæ’å¡' && iccid !== 'å¼‚å¸¸') return { text: iccid, className: 'pass' };
                    if (iccid === 'æœªæ’å¡') return { text: 'æœªæ’å¡', className: 'fail' };
                    return { text: iccid || 'å¼‚å¸¸', className: 'fail' };
                };

                const getReportStatusCell = (record) => {
                    if (record.skipReport) {
                        return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    }
                    if (record.reported) {
                        return { text: 'å·²ä¸ŠæŠ¥', className: 'pass' };
                    }
                    if (record.reportFailed) {
                        return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    }
                    if (record.status !== 'pending' && !CONFIG.AUTO_REPORT) {
                        return { text: 'æœªä¸ŠæŠ¥', className: record.status === false ? 'fail' : '' };
                    }
                    if (record.status === false && !record.sn) {
                        return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    }
                    return { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' };
                };

                const columns = [
                    { text: `è®¾å¤‡${String.fromCharCode(64 + record.deviceId)}` },
                    { text: record.timestamp },
                    getInfoCell(record.sn),
                    getInfoCell(record.imei),
                    getIccidCell(record.iccid),
                    getStatusDisplay(record.serial),
                    getStatusDisplay(record.web),
                    record.status === 'pending' ? { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' } : getStatusDisplay(record.status),
                    getReportStatusCell(record)
                ];

                columns.forEach((col, i) => {
                    row.cells[i].textContent = col.text ?? '';
                    row.cells[i].className = col.className ?? '';
                });
            }

            clearTestResult(deviceId) {
                const row = this.deviceRows.get(deviceId);
                if (row) {
                    for (let i = 1; i < row.cells.length; i++) {
                        row.cells[i].textContent = '';
                        row.cells[i].className = '';
                    }
                }
            }

            showTestResult(deviceId, state, message = null) {
                const display = UI.testResultDisplays[deviceId - 1];
                if (!display) return;

                const states = {
                    waiting: { text: `â³ è®¾å¤‡${String.fromCharCode(64 + deviceId)}æ­£åœ¨æµ‹è¯•...`, className: 'waiting' },
                    pass: { text: `âœ… è®¾å¤‡${String.fromCharCode(64 + deviceId)}-é€šè¿‡`, className: 'pass' },
                    fail: { text: `âŒ è®¾å¤‡${String.fromCharCode(64 + deviceId)}-ä¸é€šè¿‡`, className: 'fail' },
                    'no-device': { text: `âŒ è®¾å¤‡${String.fromCharCode(64 + deviceId)}-æœªæ’å…¥`, className: 'fail' },
                    connected: { text: `ç«¯å£${String.fromCharCode(64 + deviceId)}å·²è¿æ¥`, className: 'default' },
                    disconnected: { text: `ç«¯å£${String.fromCharCode(64 + deviceId)}æœªè¿æ¥`, className: 'default' }
                };

                const { text, className } = states[state] || states.disconnected;
                display.textContent = message || text;
                display.className = `test-result-display ${className}`;
            }
        }

        /**
         * æ ¸å¿ƒåº”ç”¨é€»è¾‘ï¼Œç®¡ç†è®¾å¤‡ã€äº‹ä»¶å’Œæµ‹è¯•æµç¨‹ã€‚
         */
        class App {
            constructor(uiManager) {
                this.uiManager = uiManager;
                this.devices = Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => ({
                    id: i + 1,
                    serial: new SerialManager(i + 1),
                    inProgress: false,
                    record: null
                }));
                this.testRunner = new TestRunner(this.uiManager);
            }

            async init() {
                try {
                    await DgwCrypto.init();
                } catch (e) {
                    alert('URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚');
                    this.uiManager.log('âŒ URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
                    return;
                }
                this.uiManager.initDeviceRows();
                this.setupEventListeners();
                await this.loadSavedPorts();
                this.uiManager.updateButtons(this.devices);
                this.uiManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
            }

            setupEventListeners() {
                this.devices.forEach((device) => {
                    const panel = UI.devicePanels[device.id - 1];
                    panel.selectBtn.addEventListener('click', () => this.selectPort(device.id));
                    panel.connectBtn.addEventListener('click', () => this.toggleConnection(device.id));
                    panel.snInput.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault(); 
                            this.startTestFromInput(device.id);
                        }
                    });
                });
                //UI.switchInterfaceBtn.addEventListener('click', () => window.location.href = 'index.html');
                document.getElementById('switchInterfaceBtn').addEventListener('click', () => window.location.href = `index.html?v=${Date.now()}`);
                document.getElementById('switchVerisonBtn').addEventListener('click', () => window.location.href = `complete_machine_wifi.html?v=${Date.now()}`);
            }

            async startTestFromInput(id) {
                const device = this.devices[id - 1];
                
                if (device.inProgress) {
                    this.uiManager.log(`è®¾å¤‡ ${id} æ­£åœ¨æµ‹è¯•ä¸­ï¼Œè¯·å‹¿é‡å¤æ“ä½œã€‚`);
                    return;
                }
                if (!device.serial.connected) {
                    this.uiManager.updateDeviceMessage(id, 'âŒ ä¸²å£æœªè¿æ¥', 'error');
                    return;
                }

                const panel = UI.devicePanels[id - 1];
                const enteredSn = panel.snInput.value.trim();
                const isSimInserted = panel.simCheckbox.checked;

                if (enteredSn.length !== 20) {
                    this.uiManager.updateDeviceMessage(device.id, 'âŒ SNé”™è¯¯', 'error');
                    return;
                }else{this.uiManager.updateDeviceMessage(device.id, 'âœ… å·²è¿æ¥', 'success');}

                this.testRunner.startTest(device, this, enteredSn, isSimInserted);
            }

            async loadSavedPorts() {
                const allPorts = await navigator.serial.getPorts();
                for (const device of this.devices) {
                    try {
                        const savedIndex = localStorage.getItem(`serialPort_device_${device.id}`);
                        if (savedIndex !== null) {
                            const port = allPorts[parseInt(savedIndex, 10)];
                            if (port) {
                                device.serial.port = port;
                                this.uiManager.updateDeviceMessage(device.id, 'âœ… ä¸²å£å·²åŠ è½½');
                            }
                        }
                    } catch (e) {
                        console.error('åŠ è½½å·²ä¿å­˜çš„ç«¯å£å¤±è´¥:', e);
                    }
                }
            }

            async selectPort(id) {
                const device = this.devices[id - 1];
                if (await device.serial.select()) {
                    this.uiManager.updateDeviceMessage(id, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
                    try {
                        const allPorts = await navigator.serial.getPorts();
                        const portIndex = allPorts.indexOf(device.serial.port);
                        if (portIndex > -1) {
                            localStorage.setItem(`serialPort_device_${id}`, portIndex);
                            this.uiManager.log(`ğŸ’¾ å·²ä¸ºè®¾å¤‡ ${id} ä¿å­˜ä¸²å£é€‰æ‹©`);
                        }
                    } catch (e) {
                        console.error('ä¿å­˜ç«¯å£é€‰æ‹©å¤±è´¥:', e);
                    }
                }
                this.uiManager.updateButtons(this.devices);
            }

            async toggleConnection(id) {
                const device = this.devices[id - 1];
                if (device.serial.connected) {
                    const isFinishedFailure = !device.inProgress && device.record?.status === false;
                    await this.disconnectDevice(device, isFinishedFailure);
                } else {
                    await this.connectDevice(device);
                }
                this.uiManager.updateButtons(this.devices);
            }

            async connectDevice(device) {
                this.uiManager.updateDeviceMessage(device.id, 'âŒ› è¿æ¥ä¸­...');
                if (await device.serial.connect(CONFIG.BAUD_RATE)) {
                    this.uiManager.updateDeviceMessage(device.id, 'âœ… å·²è¿æ¥', 'success');
                    this.uiManager.showTestResult(device.id, 'connected');
                } else {
                    this.uiManager.updateDeviceMessage(device.id, 'âŒ è¿æ¥å¤±è´¥', 'error');
                }
            }

            async disconnectDevice(device, keepResultOnDisplay = false) {
                if (device.inProgress) {
                    this.testRunner.cancelTest(device);
                    this.uiManager.log(`ğŸ›‘ è®¾å¤‡ ${device.id}: ç”¨æˆ·æ‰‹åŠ¨æ–­å¼€ï¼Œæµ‹è¯•å·²ä¸­æ–­`);
                }
                await device.serial.disconnect();
                this.uiManager.updateDeviceMessage(device.id, 'â„¹ï¸ å·²æ–­å¼€');
                UI.devicePanels[device.id - 1].snInput.value = '';
                if (!keepResultOnDisplay) { // å¦‚æœä¸éœ€è¦ä¿æŒç»“æœæ˜¾ç¤ºï¼Œåˆ™é‡ç½®æ˜¾ç¤º
                     device.record = null;
                     this.uiManager.showTestResult(device.id, 'disconnected');
                     this.uiManager.clearTestResult(device.id);
                }
            }
        }

        /**
         * è´Ÿè´£æ‰§è¡Œå•ä¸ªè®¾å¤‡çš„å®Œæ•´æµ‹è¯•æµç¨‹ã€‚
         */
        class TestRunner {
            constructor(uiManager) {
                this.uiManager = uiManager;
                this.testTimeouts = new Map();
            }

            cancelTest(device) {
                this.clearTimeouts(device.id);
                device.inProgress = false;
                if (device.record) this.uiManager.clearTestResult(device.id);
                device.record = null;
                //this.uiManager.updateDeviceMessage(device.id, 'â„¹ï¸ æµ‹è¯•å·²å–æ¶ˆ');
                this.uiManager.log(`â¹ï¸ è®¾å¤‡ ${device.id}: æµ‹è¯•å·²å–æ¶ˆ`);
            }

            async startTest(device, app, enteredSn, isSimInserted) {
                if (device.inProgress) return;

                this.uiManager.clearTestResult(device.id);
                device.record = null;
                device.inProgress = true;
                device.enteredSn = enteredSn;
                device.isSimInserted = isSimInserted;
                app.uiManager.updateButtons(app.devices);
                //this.uiManager.updateDeviceMessage(device.id, 'â³ ç­‰å¾…è®¾å¤‡å¯åŠ¨...');
                this.uiManager.showTestResult(device.id, 'waiting');

                const timeoutId = setTimeout(() => {
                    if (!device.inProgress) return;
                    //this.uiManager.updateDeviceMessage(device.id, 'âœ… æ­£åœ¨æµ‹è¯•...');
                    this.listenAndSendCommand(device, app);
                }, CONFIG.TIMEOUTS.COMMAND);
                this.testTimeouts.set(device.id, timeoutId);
            }

            async listenAndSendCommand(device, app) {
                this.clearTimeouts(device.id);
                let responseReceived = false;
                let buffer = '';

                const onData = async (textData) => {
                    if (responseReceived) return;
                    buffer += textData;
                    if (buffer.includes('<1,DSN;') && buffer.includes('<1,ICC;') && buffer.includes('<1,IME;')) {
                        responseReceived = true;
                        this.clearTimeouts(device.id);
                        await device.serial.stopReadLoop();
                        await this.handleResponse(device, buffer, app);
                    }
                };

                const onError = (e) => {
                    if (device.inProgress) {
                        this.uiManager.log(`âŒ è®¾å¤‡ ${device.id} ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                        this.finishTest(device, { sn: null, serial: false, web: false, status: false, skipReport: true }, app);
                    }
                };

                device.serial.readLoop(onData, onError);
                
                // å‘é€æŒ‡ä»¤å¹¶è®¾ç½®è¶…æ—¶é‡è¯•
                for (let i = 0; i < CONFIG.RETRY_COUNT + 1; i++) {
                    if (responseReceived) break;
                    const isRetry = i > 0;
                    if (isRetry) this.uiManager.log(`è®¾å¤‡ ${device.id}: å“åº”è¶…æ—¶ï¼Œé‡è¯•ä¸€æ¬¡...`);
                    
                    if (!isRetry) {
                        await device.serial.writer.write(new Uint8Array(8).fill(0xf8));
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    await device.serial.writer.write(new TextEncoder().encode('<1,DSN,ICC,IME>'));
                    this.uiManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²å‘é€æŒ‡ä»¤: <1,DSN,ICC,IME>`);

                    await new Promise(resolve => {
                        const responseTimeout = setTimeout(() => {
                            if (!responseReceived && i === CONFIG.RETRY_COUNT) { // æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥
                                this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: å“åº”è¶…æ—¶`);
                                this.finishTest(device, { sn: null, serial: false, web: false, status: false, skipReport: true }, app);
                            }
                            resolve();
                        }, CONFIG.TIMEOUTS.RESPONSE);
                        this.testTimeouts.set(`response_${device.id}`, responseTimeout);
                    });
                }
            }

            async handleResponse(device, buffer, app) {
                const sn = buffer.match(/<1,DSN;([^>]+)>/)?.[1]?.trim() || null;
                const iccid = buffer.match(/<1,ICC;([^>]*)>/)?.[1]?.trim() || '';
                const imei = buffer.match(/<1,IME;([^>]+)>/)?.[1]?.trim() || null;

                if (sn !== device.enteredSn) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: SNä¸åŒ¹é…ã€‚è¾“å…¥: ${device.enteredSn}, è®¾å¤‡è¿”å›: ${sn}`);
                    this.uiManager.showTestResult(device.id, 'fail', 'SNä¸åŒ¹é…');
                    this.finishTest(device, { sn: sn, serial: true, status: false, errorReason: 'SNä¸åŒ¹é…', skipReport: true }, app);
                    return;
                }

                if (!sn || !imei) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: å“åº”æ ¼å¼ä¸æ­£ç¡®æˆ–SN/IMEIä¸ºç©º: ${buffer}`);
                    this.finishTest(device, { sn: null, serial: true, web: false, status: false, skipReport: true }, app);
                    return;
                }

                device.record = { deviceId: device.id, timestamp: new Date().toLocaleString(), sn, imei, iccid, serial: true, web: 'pending', status: 'pending' };
                this.uiManager.addOrUpdateTestResult(device.record);
                this.uiManager.log(`âœ… è®¾å¤‡ ${device.id}: æ”¶åˆ°SN: ${sn}, IMEI: ${imei}, ICCID: ${iccid || 'æ— '}`);

                if (device.isSimInserted) {
                    if (!iccid) {
                        this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: å·²å‹¾é€‰æ’å¡ä½†æœªè¯»åˆ°ICCID`);
                        device.record.iccid = 'å¼‚å¸¸';
                        this.finishTest(device, { ...device.record, web: false, status: false }, app);
                    } else {
                        await this.startWebTest(device, app);
                    }
                } else {
                    this.uiManager.log(`â„¹ï¸ è®¾å¤‡ ${device.id}: è·³è¿‡ICCIDå’Œç½‘ç»œæµ‹è¯•`);
                    device.record.iccid = 'æœªæ’å¡';
                    device.record.web = 'æœªæ’å¡';
                    this.finishTest(device, { ...device.record, status: true }, app);
                }
            }

            async startWebTest(device, app) {
                this.uiManager.log(`ğŸ”— è®¾å¤‡ ${device.id}: æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...`);
                const testUrl = await this._generateTestUrl(device.record.sn);
                let webResult = false;
                await new Promise(resolve => setTimeout(resolve, CONFIG.TIMEOUTS.TEST_URL_WAIT));
                if (testUrl) {
                    this.uiManager.log(`ğŸŒ è®¾å¤‡ ${device.id}: æµ‹è¯•ç½‘å€: ${testUrl}`);
                    for (let attempt = 0; attempt < CONFIG.RETRY_COUNT + 1; attempt++) {
                        try {
                            if (attempt === 2) this.uiManager.log(`ğŸ”„ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•...`);
                            const proxiedUrl = `https://cors.lorens.qzz.io/?url=${encodeURIComponent(testUrl)}`;
                            const response = await fetch(proxiedUrl, { signal: AbortSignal.timeout(CONFIG.TIMEOUTS.FETCH), mode: 'cors', cache: 'no-cache' });
                            if (response.ok) {
                                this.uiManager.log(`âœ… è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®æˆåŠŸ${attempt === 2 ? ' (é‡è¯•æˆåŠŸ)' : ''}`);
                                webResult = true;
                                break;
                            }
                            throw new Error(`HTTPçŠ¶æ€ ${response.status}`);
                        } catch (e) {
                            this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}${attempt >= 1 ? ' (å‡†å¤‡é‡è¯•)' : ''}`);
                            if (attempt >= 1) await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                } else {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: URL ç”Ÿæˆå¤±è´¥`);
                }
                this.finishTest(device, { ...device.record, web: webResult, status: webResult }, app);
            }

            async finishTest(device, result, app) {
                device.inProgress = false;

                // ç¡®ä¿å³ä½¿åœ¨æ—©æœŸå¤±è´¥ï¼ˆè¶…æ—¶ç­‰ï¼‰æ—¶ä¹Ÿèƒ½åˆ›å»ºä¸€ä¸ªå¸¦æœ‰æ—¶é—´æˆ³çš„å®Œæ•´è®°å½•
                const baseRecord = {
                    deviceId: device.id,
                    timestamp: new Date().toLocaleString(),
                    sn: null,
                    imei: null,
                    iccid: null,
                    serial: false,
                    web: false,
                    status: false
                };
                device.record = { ...baseRecord, ...device.record, ...result };

                const isSuccess = device.record.status === true;
                this.uiManager.addOrUpdateTestResult(device.record);

                // åˆ¤æ–­æ˜¯å¦ä¸‰ä¸ªå‚æ•°éƒ½æ²¡æœ‰è·å–åˆ°
                const noDeviceDetected = !device.record.sn && !device.record.imei && !device.record.iccid;
                let displayState;
                if (isSuccess) {
                    displayState = 'pass';
                } else if (noDeviceDetected) {
                    displayState = 'no-device';
                } else {
                    displayState = 'fail';
                }

                this.uiManager.showTestResult(device.id, displayState, result.errorReason);
                this.uiManager.updateButtons(app.devices);
                this.uiManager.log(`ğŸ“Š è®¾å¤‡ ${device.id}: æµ‹è¯•å®Œæˆ - ${isSuccess ? 'é€šè¿‡' : 'å¤±è´¥'}`);

                if (CONFIG.AUTO_REPORT && !device.record.skipReport) {
                    await this.reportResult(device.record);
                }

                try {
                    if (device.serial.writer) {
                        await device.serial.writer.write(new Uint8Array(8).fill(0xf8));
                    }
                } catch (e) {
                    this.uiManager.log(`è®¾å¤‡ ${device.id}: å‘é€æœ€ç»ˆæŒ‡ä»¤å¤±è´¥: ${e.message}`);
                }

                if (!isSuccess) {
                    //this.uiManager.updateDeviceMessage(device.id, 'âŒ æµ‹è¯•å¤±è´¥', 'error');
                }
                
                UI.devicePanels[device.id - 1].snInput.value = '';
            }

            async reportResult(record) {
                if (!record.sn) {
                    this.uiManager.log(`- è®¾å¤‡ ${record.deviceId}: ä¸ŠæŠ¥è·³è¿‡ï¼Œç¼ºå°‘SN`);
                    record.reportFailed = true;
                    this.uiManager.addOrUpdateTestResult(record);
                    return;
                }

                this.uiManager.log(`ğŸ“® è®¾å¤‡ ${record.sn}: æ­£åœ¨ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...`);
                try {
                    const reportData = { deviceId: 'DGS-100', results: [{ sn: record.sn, imei: record.imei, iccid: record.iccid === 'å¼‚å¸¸' ? 'fail' : record.iccid === 'æœªæ’å¡' ? 'fail' : record.iccid, serialTest: record.serial === true ? 'pass' : 'fail', webTest: record.web === true ? 'pass' : 'fail', overallStatus: record.status === true ? 'pass' : 'fail' }] };
                    const response = await fetch(CONFIG.URLS.REPORT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                        body: JSON.stringify(reportData),
                        signal: AbortSignal.timeout(CONFIG.TIMEOUTS.REPORT)
                    });
                    if (response.ok) {
                        this.uiManager.log(`âœ… è®¾å¤‡ ${record.sn}: ä¸ŠæŠ¥æˆåŠŸ`);
                        record.reported = true;
                    } else {
                        throw new Error(`æœåŠ¡å™¨å“åº” ${response.status}`);
                    }
                } catch (error) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${record.sn}: ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
                    record.reportFailed = true;
                }
                this.uiManager.addOrUpdateTestResult(record);
            }

            async _generateTestUrl(sn) {
                const encrypted = await DgwCrypto.encrypt("DAAN" + sn);
                return encrypted ? `${CONFIG.URLS.TEST}${encrypted}` : null;
            }

            clearTimeouts(deviceId) {
                for (const key of [`${deviceId}`, `response_${deviceId}`]) {
                    if (this.testTimeouts.has(key)) {
                        clearTimeout(this.testTimeouts.get(key));
                        this.testTimeouts.delete(key);
                    }
                }
            }
        }

        // --- åº”ç”¨å¯åŠ¨ ---
        if ('serial' in navigator) {
            const uiManager = new UIManager();
            const app = new App(uiManager);
            app.init();
        } else {
            document.body.innerHTML = '<h1>é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚</h1>';
            alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
        }

    })();
</script>
</body>
</html>
