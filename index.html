<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>数据棒测试</title>
    <style>
        body { font-family: Arial; padding: 20px; }
        .btn { margin: 5px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 3px; cursor: pointer; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .panel { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin: 10px 0; }
        .panel-green { border-color: #28a745; background: #f8fff8; }
        .panel-blue { border-color: #007bff; background: #f8f9ff; }
        .flex { display: flex; gap: 20px; }
        .flex > div { flex: 1; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .status-item { display: flex; justify-content: space-between; margin: 5px 0; }
        .status-value { color: #007bff; font-weight: bold; }
        .status-ready { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-on { color: #28a745; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .pass { background: #d4edda; color: green; }
        .fail { background: #f8d7da; color: red; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ccc; height: 160px; overflow-y: auto; background: #f9f9f9; font-family: monospace; white-space: pre-wrap; }
        #deviceStatus { margin: 10px 0; }
        .color-preview { width: 100%; height: 30px; border: 1px solid #ddd; margin: 5px 0; }
        .hidden { display: none; }
    </style>
</head>
<body>
<h1>数据棒测试</h1>

<div class="flex">
    <div class="panel panel-green">
        <h3>设备状态监控</h3>
        <button class="btn" onclick="app.selectPort('status')">选择状态串口</button>
        <button class="btn" id="connectStatus" onclick="app.connect('status')">连接</button>
        <button class="btn" id="disconnectStatus" onclick="app.disconnect('status')">断开</button>
        <div id="statusMsg"></div>
    </div>

    <div class="panel panel-blue">
        <h3>测试功能</h3>
        <div style="margin: 10px 0; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
            <button class="btn" onclick="app.selectPort('test')">选择测试串口</button>
            <div style="display: flex; align-items: center;">
                <label>SN:</label>
                <input type="text" id="scanInput" placeholder="请使用扫码枪扫描..." style="width: 200px; padding: 8px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px;" />
            </div>
            <button class="btn" onclick="app.saveRecords()">保存记录</button>
        </div>
        <div id="testMsg"></div>
    </div>
</div>

<div id="deviceStatus" class="panel hidden">
    <h3>设备状态信息</h3>
    <div class="grid" id="statusGrid"></div>
</div>

<div class="panel">
    <table>
        <thead><tr><th>时间</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>串口通信</th><th>网页访问</th><th>测试结果</th></tr></thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">测试日志...</div>

<script>
class SerialManager {
    constructor(type) {
        this.type = type;
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.connected = false;
        this.buffer = '';
    }

    async select() {
        try {
            this.port = await navigator.serial.requestPort();
            return true;
        } catch { return false; }
    }

    async connect(baudRate) {
        if (!this.port) return false;
        try {
            await this.port.open({ baudRate });
            this.reader = this.port.readable.getReader();
            if (this.type === 'test') this.writer = this.port.writable.getWriter();
            this.connected = true;
            return true;
        } catch (e) {
            console.error(`${this.type}连接失败:`, e);
            return false;
        }
    }

    async disconnect() {
        this.connected = false;
        this.buffer = '';
        if (this.reader) {
            try { await this.reader.cancel(); } catch {}
            this.reader.releaseLock();
            this.reader = null;
        }
        if (this.writer) {
            this.writer.releaseLock();
            this.writer = null;
        }
        if (this.port) {
            try { await this.port.close(); } catch {}
        }
    }
}

const app = {
    status: new SerialManager('status'),
    test: new SerialManager('test'),
    testing: false,
    records: [],

    log(msg) {
        document.getElementById('logBox').textContent += `\n${msg}`;
        document.getElementById('logBox').scrollTop = document.getElementById('logBox').scrollHeight;
    },

    statusLog(msg) {
        console.log(`[状态] ${msg}`);
    },

    updateUI(id, text) {
        document.getElementById(id).textContent = text;
    },

    async selectPort(type) {
        const port = this[type];
        const success = await port.select();
        this.updateUI(`${type}Msg`, success ? '✅ 串口已选择' : '❌ 选择失败');
        this.updateButtons();
    },

    async connect(type) {
        const port = this[type];
        if (!port.port || port.connected) return;
        
        const baudRate = type === 'status' ? 115200 : 10000000;
        this.updateUI(`${type}Msg`, '⌛ 连接中...');
        
        const success = await port.connect(baudRate);
        if (success) {
            this.updateUI(`${type}Msg`, '✅ 已连接');
            if (type === 'status') this.statusLoop();
        } else {
            this.updateUI(`${type}Msg`, '❌ 连接失败');
        }
        this.updateButtons();
    },

    async disconnect(type) {
        const port = this[type];
        await port.disconnect();
        this.updateUI(`${type}Msg`, 'ℹ️ 已断开');
        this.updateButtons();
    },

    updateButtons() {
        document.getElementById('connectStatus').disabled = !this.status.port || this.status.connected;
        document.getElementById('disconnectStatus').disabled = !this.status.connected;
    },

    async statusLoop() {
        if (!this.status.connected) return;
        try {
            const { value, done } = await this.status.reader.read();
            if (done || !value) return;
            
            const text = new TextDecoder().decode(value);
            this.status.buffer += text;
            
            if (this.status.buffer.includes('Color_C=')) {
                this.parseStatus(this.status.buffer.trim());
                this.status.buffer = '';
            }
            
            if (this.status.connected) this.statusLoop();
        } catch (e) {
            this.statusLog('读取错误: ' + e);
            await this.disconnect('status');
        }
    },

    parseStatus(data) {
        this.statusLog('解析数据: ' + data);
        const lines = data.split(/\r?\n/);
        const parsed = {};
        
        lines.forEach(line => {
            const colonMatch = line.match(/^(\w+):(.+)/);
            const equalMatch = line.match(/^(\w+)=(.+)/);
            
            if (colonMatch) parsed[colonMatch[1].toLowerCase()] = colonMatch[2];
            else if (equalMatch) parsed[equalMatch[1].toLowerCase()] = equalMatch[2];
        });

        this.displayStatus(parsed);
    },

    displayStatus(data) {
        const container = document.getElementById('deviceStatus');
        const grid = document.getElementById('statusGrid');
        container.classList.remove('hidden');
        
        const groups = {
            '系统状态': [
                { key: 'state', label: '状态', desc: data.state === 'Ready' ? '就绪' : '等待' },
                { key: 'swd', label: 'SWD烧录', desc: data.swd === 'ON' ? '开启' : '关闭' }
            ],
            '电源信息': [
                { key: 'vout', label: '工作电压' },
                { key: 'iout', label: '工作电流' },
                { key: 'pout', label: '工作功耗' }
            ],
            '模拟输入': [
                { key: 'ai0', label: 'DCDC输出' },
                { key: 'ai1', label: 'WIFI/4G供电' },
                { key: 'ai2', label: 'MCU供电' }
            ],
            '颜色传感器': [
                { key: 'tcs', label: 'TCS状态', desc: data.tcs === 'ON' ? '开启' : '关闭' },
                { key: 'color_r', label: '红色值' },
                { key: 'color_g', label: '绿色值' },
                { key: 'color_b', label: '蓝色值' },
                { key: 'color_c', label: '参考值' }
            ]
        };

        grid.innerHTML = Object.entries(groups).map(([title, items]) => `
            <div class="panel">
                <h4>${title}</h4>
                ${items.map(item => {
                    const value = data[item.key] || '-';
                    const cls = item.key === 'state' ? (data.state === 'Ready' ? 'status-ready' : 'status-wait') :
                              item.key === 'swd' || item.key === 'tcs' ? (data[item.key] === 'ON' ? 'status-on' : 'status-off') : '';
                    return `<div class="status-item">
                        <span>${item.label}:</span>
                        <span class="status-value ${cls}">${value} ${item.desc || ''}</span>
                    </div>`;
                }).join('')}
                ${title === '颜色传感器' && data.color_r && data.color_g && data.color_b ? 
                    `<div class="color-preview" style="background:rgb(${data.color_r},${data.color_g},${data.color_b})"></div>` : ''}
            </div>
        `).join('');
    },

    async startTest() {
        if (!this.test.port || this.testing) return;
        this.testing = true;
        this.updateButtons();
        this.updateUI('testMsg', '⏳ 正在测试...');
        
        try {
            const baudRate = 10000000;
            await this.test.connect(baudRate);
            this.log('📤 已发送测试指令: 0101020001783C');
            
            // 发送测试指令 (hex: 0101020001783C)
            const hexCommand = [0x01, 0x01, 0x02, 0x00, 0x01, 0x78, 0x3C];
            await this.test.writer.write(new Uint8Array(hexCommand));
            
            // 开始读取响应
            this.testReadLoop();
            
            // 设置超时
            setTimeout(async () => {
                if (this.testing) {
                    this.log('⏰ 测试超时');
                    await this.finishTest({ sn: null, imei: null, iccid: null, serial: false, web: false });
                }
            }, 10000);
            
        } catch (e) {
            this.log('❌ 测试连接失败: ' + e);
            await this.finishTest({ sn: null, imei: null, iccid: null, serial: false, web: false });
        }
    },

    async testReadLoop() {
        if (!this.testing || !this.test.connected) return;
        
        try {
            const { value, done } = await this.test.reader.read();
            if (done || !value) {
                if (this.testing) this.testReadLoop();
                return;
            }
            
            this.test.buffer += new TextDecoder().decode(value);
            this.log('📥 收到数据: ' + [...value].map(b => b.toString(16).padStart(2, '0')).join(''));
            
            // 检查数据完整性
            if (this.test.buffer.length >= 8 || this.test.buffer.includes('\n')) {
                this.log('🔄 开始解析数据...');
                const result = this.parseTestData(this.test.buffer);
                
                if (result) {
                    this.log('✅ 数据解析完成');
                    // 测试网络连接
                    this.updateUI('testMsg', '🔗 正在测试网络连接...');
                    const webResult = await this.testWebConnection();
                    result.web = webResult;
                    
                    await this.finishTest(result);
                } else {
                    // 继续读取
                    if (this.testing) this.testReadLoop();
                }
            } else {
                // 继续读取
                if (this.testing) this.testReadLoop();
            }
            
        } catch (e) {
            this.log('❌ 数据读取异常: ' + e);
            await this.finishTest({ sn: null, imei: null, iccid: null, serial: false, web: false });
        }
    },

    parseTestData(buffer) {
        this.log('📝 解析数据: ' + JSON.stringify(buffer));
        
        try {
            // 尝试JSON解析
            const jsonData = JSON.parse(buffer);
            return {
                sn: jsonData.sn || jsonData.SN || null,
                imei: jsonData.imei || jsonData.IMEI || null,
                iccid: jsonData.sim || jsonData.SIM || jsonData.iccid || jsonData.ICCID || null,
                serial: true
            };
        } catch {
            // 十六进制解析
            const hexStr = [...new Uint8Array(buffer.split('').map(c => c.charCodeAt(0)))]
                .map(b => b.toString(16).padStart(2, '0')).join('');
            
            if (hexStr.length >= 16) {
                const sn = hexStr.slice(0, 8).toUpperCase();
                const imei = hexStr.slice(8, 16);
                const iccid = hexStr.slice(16, 32);
                
                this.log(`📦 十六进制解析: SN=${sn}, IMEI=${imei}, SIM=${iccid}`);
                
                return {
                    sn: sn || null,
                    imei: imei || null,
                    iccid: iccid || null,
                    serial: !!(sn || imei || iccid)
                };
            }
        }
        
        return null;
    },

    async testWebConnection() {
        const testUrl = 'http://gw.3wlink.cn:22011/main?dgwkey=ZBsQU5uQoNWdK9x6xG58-o6tQmBaKYN0v9e3R0X37rY';
        this.log('🌐 测试网址: ' + testUrl);
        
        try {
            // 直接访问
            const response = await fetch(testUrl, { 
                method: 'GET', 
                mode: 'cors', 
                cache: 'no-cache',
                timeout: 5000
            });
            
            if (response.ok) {
                this.log('✅ 网络访问成功');
                return true;
            }
        } catch (e) {
            this.log('❌ 网络访问失败: ' + e.message);
        }
        
        // 尝试代理
        const proxies = [
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/',
            'https://corsproxy.io/?'
        ];
        
        for (let proxy of proxies) {
            try {
                this.log('🔄 尝试代理: ' + proxy.split('/')[2]);
                const response = await fetch(proxy + encodeURIComponent(testUrl), {
                    timeout: 3000
                });
                
                if (response.ok) {
                    this.log('✅ 代理访问成功');
                    return true;
                }
            } catch (e) {
                this.log('❌ 代理失败: ' + e.message);
            }
        }
        
        this.log('❌ 所有网络测试失败');
        return false;
    },

    async finishTest(result) {
        this.testing = false;
        result.status = (result.serial && result.web) ? '通过' : '不通过';
        result.timestamp = Date.now();
        
        this.addTestResult(result);
        this.log(`📊 测试完成: ${result.status}`);
        this.updateUI('testMsg', `✅ 测试完成: ${result.status}`);
        
        await this.test.disconnect();
        this.updateButtons();
    },

    addTestResult(result) {
        this.records.push(result);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${new Date(result.timestamp).toLocaleString()}</td>
            <td>${result.sn || '-'}</td>
            <td>${result.imei || '-'}</td>
            <td>${result.iccid || '-'}</td>
            <td class="${result.serial ? 'pass' : 'fail'}">${result.serial ? '正常' : '异常'}</td>
            <td class="${result.web ? 'pass' : 'fail'}">${result.web ? '正常' : '异常'}</td>
            <td class="${result.status === '通过' ? 'pass' : 'fail'}">${result.status}</td>
        `;
        document.getElementById('resultBody').insertBefore(row, document.getElementById('resultBody').firstChild);
    },

    saveRecords() {
        if (!this.records.length) return alert('没有测试记录');
        
        const csv = [
            ['时间', 'SN', 'IMEI', 'ICCID', '串口通信', '网页访问', '测试结果'],
            ...this.records.map(r => [
                new Date(r.timestamp).toLocaleString(),
                r.sn || '-', r.imei || '-', r.iccid || '-',
                r.serial ? '正常' : '异常',
                r.web ? '正常' : '异常',
                r.status
            ])
        ].map(row => row.join(',')).join('\n');
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'test_records.csv';
        a.click();
        URL.revokeObjectURL(url);
    },

    setupScanInput() {
        const scanInput = document.getElementById('scanInput');
        let isNewScan = true; // 标记是否是新的扫码
        
        // 自动聚焦到输入框
        scanInput.focus();
        
        // 处理输入事件 - 新输入时清空之前的值
        scanInput.addEventListener('input', (e) => {
            if (isNewScan) {
                // 如果是新的扫码，清空之前的值，只保留当前输入的字符
                const currentChar = e.data; // 当前输入的字符
                if (currentChar) {
                    scanInput.value = currentChar;
                }
                isNewScan = false;
            }
        });
        
        // 处理回车键（扫码枪通常会自动添加回车）
        scanInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const value = e.target.value;
                if (value) {
                    this.log(`🔍 扫码完成: ${value}`);
                    this.updateUI('testMsg', `✅ 扫码结果: ${value}`);
                    this.processScanResult(value);
                    isNewScan = true; // 标记下次输入为新扫码
                }
            }
        });
        
        // 失焦后重新聚焦（确保扫码枪始终可用）
        scanInput.addEventListener('blur', () => {
            setTimeout(() => scanInput.focus(), 100);
        });
    },

    processScanResult(scanData) {
        // 清空日志窗口
        document.getElementById('logBox').textContent = '测试日志...';
        
        // 处理扫码结果
        this.log(`📋 处理扫码数据: ${scanData}`);
        
        // 自动开始测试流程
        this.startTest();
        
        // 保持输入框聚焦，不清空值（让用户可以看到扫码结果）
        setTimeout(() => {
            document.getElementById('scanInput').focus();
        }, 100);
    },

    async init() {
        this.updateButtons();
        this.setupScanInput();
        
        // 自动检测串口
        const ports = await navigator.serial.getPorts();
        if (ports.length >= 1) {
            this.status.port = ports[0];
            this.updateUI('statusMsg', '✅ 自动选择状态串口');
            if (ports.length >= 2) {
                this.test.port = ports[1];
                this.updateUI('testMsg', '✅ 自动选择测试串口');
            }
            this.updateButtons();
        }
    }
};

// 初始化
if ('serial' in navigator) app.init();
else alert('浏览器不支持串口功能');
</script>
</body>
</html>
