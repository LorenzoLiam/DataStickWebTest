<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 å•æ¿æµ‹è¯•</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background-color: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .status-reporting { color: #ffc107; }
        .status-report-success { color: #28a745; }
        .status-report-failed { color: #dc3545; }
        .flex { display: flex; gap: 20px; flex-wrap: wrap; }
        .flex > div { flex: 1; min-width: 300px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .status-item { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .status-item span:first-child { color: #555; }
        .status-value { font-weight: bold; }
        .status-ready { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-on { color: #28a745; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background-color: #fff; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background-color: #f8f9fa; color: #495057; font-weight: 600; }
        .pass { background-color: #d1f2d1; color: #28a745; }
        .fail { background-color: #f8d7da; color: #dc3545; }
        .testing { background-color: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 160px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .color-preview { width: 100%; height: 30px; border: 1px solid #ddd; margin-top: 10px; border-radius: 4px; }
        .hidden { display: none; }
        input[type="text"] { width: 200px; padding: 8px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px; }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1>å•æ¿æµ‹è¯•</h1>
    <div style="display: flex; gap: 10px;">
        <button class="btn" id="saveRecordsBtn">ä¿å­˜è®°å½•</button>
        <button class="btn" id="switchInterfaceBtn" style="background-color: #28a745; color: white; font-weight: bold;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<div class="panel">
    <div class="flex">
        <div class="panel panel-green" style="margin: 10px; flex: 1;">
            <h4>æµ‹è¯•æ¶ä¸²å£</h4>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="selectStatusBtn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="toggleStatusBtn">è¿æ¥</button>
                <div id="statusMsg"></div>
            </div>
        </div>

        <div class="panel panel-blue" style="margin: 10px; flex: 1;">
            <h4>æ•°æ®æ£’ä¸²å£</h4>
            <div style="margin: 10px 0; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn" id="selectTestBtn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="toggleTestBtn">è¿æ¥</button>
                <div style="display: flex; align-items: center;">
                    <label for="scanInput">SN:</label>
                    <input type="text" id="scanInput" placeholder="è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ..." />
                </div>
                <div id="testMsg"></div>
            </div>
        </div>
    </div>
</div>


<div class="panel">
    <table>
        <thead><tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>å·¥ä½œç”µå‹</th><th>å·¥ä½œç”µæµ</th><th>DCDC</th><th>ç½‘ç»œä¾›ç”µ</th><th>MCUä¾›ç”µ</th><th>ç”µæºç¯</th><th>ä¸²å£ç¯</th><th>ç½‘ç»œç¯</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
    // ==================================================================================
    // é…ç½® & UI å…ƒç´ 
    // ==================================================================================
    const config = {
        aes: { keyString: "me%ov2Ied|eicegh", ivString: "me%ov2Ied|eicegh" },
        urls: {
            test: "http://gw.3wlink.cn:22011/?dgwkey=",
            report: "https://daantest.free.beeceptor.com" // ä¸ŠæŠ¥æœåŠ¡å™¨URL
        },
        baudRates: { status: 115200, test: 10000000 },
        timeouts: {
            dsn: 3000,      // DSNå“åº”è¶…æ—¶
            imei: 3000,     // IMEIå“åº”è¶…æ—¶
            iccid: 3000,    // ICCIDå“åº”è¶…æ—¶
            rst: 15000,     // AT+RSTé‡ç½®ç­‰å¾…æ—¶é—´
            led: 2000,      // LEDæµ‹è¯•è¶…æ—¶
            fetch: 5000,    // ç½‘ç»œè®¿é—®è¶…æ—¶
            report: 10000   // ä¸ŠæŠ¥è¶…æ—¶
        },
        sampling: {
            count: 4,       // é‡‡æ ·æ¬¡æ•°
            interval: 500   // é‡‡æ ·é—´éš”(ms)
        },
        autoReport: true // è‡ªåŠ¨ä¸ŠæŠ¥æ‰€æœ‰æµ‹è¯•ç»“æœ
    };

    const ui = {
        selectStatusBtn: document.getElementById('selectStatusBtn'),
        toggleStatusBtn: document.getElementById('toggleStatusBtn'),
        statusMsg: document.getElementById('statusMsg'),
        selectTestBtn: document.getElementById('selectTestBtn'),
        toggleTestBtn: document.getElementById('toggleTestBtn'),
        scanInput: document.getElementById('scanInput'),
        saveRecordsBtn: document.getElementById('saveRecordsBtn'),
        testMsg: document.getElementById('testMsg'),
        resultBody: document.getElementById('resultBody'),
        logBox: document.getElementById('logBox'),
    };

    // ==================================================================================
    // æ¨¡å—: åŠ å¯†å·¥å…·
    // ==================================================================================
    const DgwCrypto = {
        _key: null, _iv: null,
        async init() {
            if (this._key) return;
            try {
                const keyBytes = new TextEncoder().encode(config.aes.keyString);
                this._iv = new TextEncoder().encode(config.aes.ivString);
                this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
            } catch (error) {
                console.error(":", error);
                throw error;
            }
        },
        async encrypt(plainText) {
            if (!this._key) { await this.init(); }
            try {
                const textBytes = new TextEncoder().encode(plainText);
                const blockSize = 16;
                let paddedData;
                if (textBytes.length % blockSize === 0) {
                    paddedData = new Uint8Array(textBytes);
                } else {
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    paddedData = new Uint8Array(textBytes.length + paddingNeeded);
                    paddedData.set(textBytes);
                }
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                const encryptedArray = new Uint8Array(encrypted);
                const truncated = encryptedArray.slice(0, paddedData.length);
                const base64 = btoa(String.fromCharCode(...truncated));
                return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            } catch (error) {
                console.error('åŠ å¯†å¤±è´¥:', error);
                return null;
            }
        }
    };

    // ==================================================================================
    // æ¨¡å—: ä¸²å£ç®¡ç†å™¨
    // ==================================================================================
    class SerialManager {
        constructor(type) {
            this.type = type;
            this.port = null;
            this.reader = null;
            this.writer = null;
            this.connected = false;
            this.buffer = '';
            this.readLoopActive = false;
        }
        async select() { try { this.port = await navigator.serial.requestPort(); return true; } catch { return false; } }
        async connect(baudRate) {
            if (!this.port) return false;
            try {
                await this.port.open({ baudRate });
                this.writer = this.port.writable?.getWriter();
                this.connected = true;
                return true;
            } catch (e) {
                console.error(`${this.type} connection failed:`, e);
                return false;
            }
        }
        async disconnect() {
            await this.stopReadLoop();
            if (this.writer) { try { await this.writer.close(); } catch { /*  å¿½ç•¥  */ } finally { this.writer = null; } } 
            if (this.port) { try { await this.port.close(); } catch { /*  å¿½ç•¥  */ } } 
            this.connected = false;
            this.buffer = '';
        }
        async readLoop(onData, onError) {
            if (!this.port?.readable || !this.connected) return;
            this.readLoopActive = true;
            this.reader = this.port.readable.getReader();
            try {
                while (this.connected && this.readLoopActive) {
                    const { value, done } = await this.reader.read();
                    if (done) break;
                    if (onData) onData(new TextDecoder().decode(value));
                }
            } catch (e) {
                if (this.readLoopActive) { 
                    if (onError) onError(e);
                }
            } finally {
                if(this.reader) {
                    this.reader.releaseLock();
                    this.reader = null;
                }
            }
            this.readLoopActive = false;
        }
        async stopReadLoop() {
            if (this.readLoopActive) {
                this.readLoopActive = false;
                if (this.reader) {
                    try {
                        await this.reader.cancel();
                    } catch (e) { /* å¿½ç•¥ */ }
                }
            }
        }
    }

    // ==================================================================================
    // æ¨¡å—: UI ç®¡ç†å™¨
    // ==================================================================================
    const UIManager = {
        init(appState) {
            this.state = appState;
        },

        log(msg) {
            const timestamp = new Date().toLocaleTimeString();
            ui.logBox.textContent += `\n[${timestamp}] ${msg}`;
            ui.logBox.scrollTop = ui.logBox.scrollHeight;
        },

        clearLog() {
            ui.logBox.textContent = 'æµ‹è¯•æ—¥å¿—...';
        },

        update(id, text, type = 'info') {
            const el = ui[id];
            if (!el) return;
            el.textContent = text;
            el.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black';
        },

        updateButtons(app) {
            // çŠ¶æ€ä¸²å£æŒ‰é’®
            if (app.serial.status.connected) {
                ui.toggleStatusBtn.textContent = 'æ–­å¼€';
                ui.toggleStatusBtn.disabled = false;
            } else {
                ui.toggleStatusBtn.textContent = 'è¿æ¥';
                ui.toggleStatusBtn.disabled = !app.serial.status.port;
            }

            // æµ‹è¯•ä¸²å£æŒ‰é’®
            if (app.serial.test.connected) {
                ui.toggleTestBtn.textContent = 'æ–­å¼€';
                ui.toggleTestBtn.disabled = false;
            } else {
                ui.toggleTestBtn.textContent = 'è¿æ¥';
                ui.toggleTestBtn.disabled = !app.serial.test.port;
            }

            const testInProgress = this.state.test.inProgress || this.state.device.initializing;
            ui.selectTestBtn.disabled = testInProgress;

            ui.scanInput.disabled = testInProgress || !this.state.device.ready || this.state.device.waitingForInitialization || !app.serial.test.connected;
            ui.saveRecordsBtn.disabled = app.records.length === 0 || testInProgress;

            if (this.state.device.initializing) {
                ui.scanInput.placeholder = 'è®¾å¤‡åˆå§‹åŒ–ä¸­ï¼Œè¯·ç¨å€™...';
            } else if (this.state.device.waitingForInitialization) {
                ui.scanInput.placeholder = 'ç­‰å¾…è®¾å¤‡åˆå§‹åŒ–ï¼Œè¯·å°†æµ‹è¯•æ¶ç§»å¼€...';
            } else if (!this.state.device.ready) {
                ui.scanInput.placeholder = 'è®¾å¤‡æœªå°±ç»ªï¼Œè¯·è¿æ¥çŠ¶æ€ä¸²å£...';
            } else if (!app.serial.test.connected) {
                ui.scanInput.placeholder = 'è¯·è¿æ¥æµ‹è¯•ä¸²å£...';
            } else {
                ui.scanInput.placeholder = 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...';
            }
        },

        addOrUpdateTestResult(record) {
            const { row } = record;
            if (!row) return;

            const getStatusDisplay = (val) => {
                if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
                if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
                return { text: 'å¾…æµ‹è¯•', className: '' }; 
            };

            const updateCell = (cell, { text, className = '' }) => {
                cell.textContent = text;
                cell.className = className;
            };

            const columns = [
                { text: new Date(record.timestamp).toLocaleString() },
                { text: record.sn, className: record.snMismatch ? 'fail' : (record.snMatch ? 'pass' : '') },
                { text: record.imei, className: (record.imei !== 'å¾…æµ‹è¯•') ? 'pass' : (record.imeiFailed ? 'fail' : '') },
                { text: record.iccid, className: (record.iccid !== 'å¾…æµ‹è¯•') ? 'pass' : (record.iccidFailed ? 'fail' : '') },
                getStatusDisplay(record.serial),
                getStatusDisplay(record.vout),
                getStatusDisplay(record.iout),
                getStatusDisplay(record.ai0),
                getStatusDisplay(record.ai1),
                getStatusDisplay(record.ai2),
                getStatusDisplay(record.powerLight),
                getStatusDisplay(record.rs485Light),
                getStatusDisplay(record.networkLight),
                getStatusDisplay(record.web),
                (() => { // æµ‹è¯•ç»“æœæ˜¾ç¤º
                    if (record.status === 'pending') return { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' };
                    return getStatusDisplay(record.status);
                })(),
                (() => { // ä¸ŠæŠ¥çŠ¶æ€
                    if (record.reportFailed) return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    if (record.reported) return { text: 'å·²ä¸ŠæŠ¥', className: 'pass' };
                    //if (record.status !== 'pending') return { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' };
                    return { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' };
                })()
            ];

            columns.forEach((col, i) => updateCell(row.cells[i], col));
        }
    };

    // ==================================================================================
    // æ¨¡å—: è®°å½•ç®¡ç†
    // ==================================================================================
    const RecordManager = {
        init(records, uiManager) {
            this.records = records;
            this.uiManager = uiManager;
        },

        createOrUpdate(partialResult) {
            let record = this.records.find(r => r.sn === partialResult.sn);
            if (!record) {
                record = {
                    sn: partialResult.sn,
                    row: ui.resultBody.insertRow(0)
                };
                this.records.unshift(record);
                for (let i = 0; i < 16; i++) record.row.insertCell();
            }
            
            if (partialResult.isNewTest) {
                Object.assign(record, {
                    timestamp: Date.now(),
                    imei: 'å¾…æµ‹è¯•', iccid: 'å¾…æµ‹è¯•',
                    vout: 'pending', iout: 'pending', ai0: 'pending', ai1: 'pending', ai2: 'pending',
                    powerLight: 'pending', rs485Light: 'pending', networkLight: 'pending',
                    serial: 'pending', web: 'pending', status: 'pending',
                    snMismatch: false, snMatch: false, reported: false, reportFailed: false, imeiFailed: false, iccidFailed: false
                });
            }

            Object.assign(record, partialResult);
            this.uiManager.addOrUpdateTestResult(record);
            return record;
        },

        async report() {
            if (this.records.length === 0) {
                this.uiManager.log('âš ï¸ æ²¡æœ‰æµ‹è¯•ç»“æœå¯ä¸ŠæŠ¥');
                return;
            }
            this.uiManager.log('ğŸ“® ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...');
            try {
                const recordsToReport = this.records.filter(r => r.status !== 'pending' && !r.reported);

                const reportData = { deviceId: 'DGS-100', results: recordsToReport.map(r => ({ sn: r.sn, imei: r.imei, iccid: r.iccid, serialTest: r.serial, webTest: r.web, overallStatus: r.status })) };
                
                const response = await fetch(config.urls.report, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                    body: JSON.stringify(reportData),
                    signal: AbortSignal.timeout(config.timeouts.report)
                });

                if (response.ok) {
                    this.uiManager.log(`âœ… ä¸ŠæŠ¥æˆåŠŸï¼Œå“åº”: ${response.status}`);
                    recordsToReport.forEach(record => this.createOrUpdate({ sn: record.sn, reported: true, reportFailed: false }));
                } else {
                    throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status} - ${response.statusText}`);
                }
            } catch (error) {
                this.uiManager.log(`âŒ ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
                this.records.filter(r => r.status !== 'pending' && !r.reported).forEach(record => {
                    this.createOrUpdate({ sn: record.sn, reportFailed: true });
                });
            }
        },

        saveToCSV() {
            if (this.records.length === 0) { alert('æ²¡æœ‰æµ‹è¯•è®°å½•å¯ä¾›ä¿å­˜ã€‚'); return; }
            const header = ['æ—¶é—´', 'SN', 'IMEI', 'ICCID', 'ä¸²å£é€šä¿¡', 'å·¥ä½œç”µå‹', 'å·¥ä½œç”µæµ', 'DCDC', 'ç½‘ç»œä¾›ç”µ', 'MCUä¾›ç”µ', 'ç”µæºç¯', 'ä¸²å£ç¯', 'ç½‘ç»œç¯', 'ç½‘é¡µè®¿é—®', 'æµ‹è¯•ç»“æœ'];
            const formatResult = (val) => {
                if (val === true) return 'æ­£å¸¸';
                if (val === false) return 'å¼‚å¸¸';
                return val === 'pending' ? 'å¾…æµ‹è¯•' : (val || 'å¾…æµ‹è¯•');
            };
            const rows = this.records.map(r => [ new Date(r.timestamp).toLocaleString('zh-CN'), r.sn, formatResult(r.imei), formatResult(r.iccid), formatResult(r.serial), formatResult(r.vout), formatResult(r.iout), formatResult(r.ai0), formatResult(r.ai1), formatResult(r.ai2), formatResult(r.powerLight), formatResult(r.rs485Light), formatResult(r.networkLight), formatResult(r.web), formatResult(r.status) ]);
            const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
            const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `æ•°æ®æ£’æµ‹è¯•è®°å½•_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };

    // ==================================================================================
    // æ¨¡å—: ä¸»åº”ç”¨
    // ==================================================================================
    const app = {
        state: {
            reporting: false,
            test: { inProgress: false, currentSN: '', currentStep: '', stepTimeouts: {}, stepRetryCount: {} },
            device: { ready: false, initializing: false, waitingForInitialization: false, status: null, colorR: 0 }
        },
        serial: {
            status: new SerialManager('status'),
            test: new SerialManager('test'),
        },
        records: [],

        async init() {
            UIManager.init(this.state);
            RecordManager.init(this.records, UIManager);

            try {
                await DgwCrypto.init();
            } catch (e) {
                alert('URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚');
                UIManager.log('âŒ URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
                return;
            }

            this.setupEventListeners();
            await this.loadSavedPorts();
            UIManager.updateButtons(this);
            ui.scanInput.focus();
            UIManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
        },

        setupEventListeners() {
            ui.selectStatusBtn.addEventListener('click', () => this.selectPort('status'));
            ui.toggleStatusBtn.addEventListener('click', () => this.toggleConnection('status'));
            ui.selectTestBtn.addEventListener('click', () => this.selectPort('test'));
            ui.toggleTestBtn.addEventListener('click', () => this.toggleConnection('test'));
            ui.saveRecordsBtn.addEventListener('click', () => RecordManager.saveToCSV());

            ui.scanInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const value = ui.scanInput.value.trim();
                    if (value && !this.state.test.inProgress) {
                        TestRunner.startTest(value, this);
                    } else if (this.state.test.inProgress) {
                        UIManager.log('âš ï¸ æµ‹è¯•è¿›è¡Œä¸­ï¼Œè¯·å‹¿é‡å¤æ‰«ç ');
                    }
                }
            });
            ui.scanInput.addEventListener('blur', () => { if (!this.state.test.inProgress) { setTimeout(() => ui.scanInput.focus(), 100); } });

            // ç•Œé¢åˆ‡æ¢åŠŸèƒ½
            document.getElementById('switchInterfaceBtn').addEventListener('click', () => {
                window.location.href = 'complete_machine.html';
            });
        },

        async loadSavedPorts() {
            const load = async (type) => {
                try {
                    const savedIndex = localStorage.getItem(`serialPort_${type}`);
                    if (savedIndex === null) return;
                    const allPorts = await navigator.serial.getPorts();
                    const port = allPorts[parseInt(savedIndex, 10)] || null;
                    if (port) {
                        this.serial[type].port = port;
                        UIManager.update(`${type}Msg`, 'âœ… ä¸²å£å·²åŠ è½½');
                    }
                } catch (e) {
                    console.error('æœªèƒ½åŠ è½½ç«¯å£é€‰æ‹©:', e);
                }
            };
            await load('status');
            await load('test');
        },

        async selectPort(type) {
            const manager = this.serial[type];
            if (await manager.select()) {
                UIManager.update(`${type}Msg`, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
                try {
                    const allPorts = await navigator.serial.getPorts();
                    const portIndex = allPorts.indexOf(manager.port);
                    if (portIndex > -1) {
                        localStorage.setItem(`serialPort_${type}`, portIndex.toString());
                        UIManager.log(`ğŸ’¾ å·²ä¿å­˜ ${type === 'status' ? 'çŠ¶æ€' : 'æµ‹è¯•'} ä¸²å£é€‰æ‹©`);
                    }
                } catch (e) {
                    console.error('ä¿æŒé€‰æ‹©ç«¯å£å¤±è´¥:', e);
                }
            }
            UIManager.updateButtons(this);
        },

        async toggleConnection(type) {
            const manager = this.serial[type];
            if (manager.connected) {
                await manager.disconnect();
                UIManager.update(`${type}Msg`, 'â„¹ï¸ å·²æ–­å¼€');
                if (type === 'status') {
                    this.state.device.ready = false;
                    this.state.device.status = null;
                }
            } else {
                UIManager.update(`${type}Msg`, 'âŒ› è¿æ¥ä¸­...');
                if (await manager.connect(config.baudRates[type])) {
                    UIManager.update(`${type}Msg`, 'âœ… å·²è¿æ¥', 'success');
                    if (type === 'status') {
                        TestRunner.startStatusReadLoop(this);
                        setTimeout(() => TestRunner.checkAndInitializeDevice(this), 1000);
                    }
                } else {
                    UIManager.update(`${type}Msg`, 'âŒ è¿æ¥å¤±è´¥', 'error');
                }
            }
            UIManager.updateButtons(this);
        },
    };

    // ==================================================================================
    // æ¨¡å—: æµ‹è¯•æ‰§è¡Œå™¨
    // ==================================================================================
    const TestRunner = {
        async startTest(sn, app) {
            if (!app.serial.test.port || app.state.test.inProgress || !sn || !app.state.device.ready) {
                if (!app.state.device.ready) UIManager.log('âš ï¸ è®¾å¤‡æœªå°±ç»ªï¼Œè¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€è¿›è¡Œåˆå§‹åŒ–');
                return;
            }
            app.state.test.inProgress = true;
            app.state.test.stepRetryCount = {};
            UIManager.updateButtons(app);
            UIManager.update('testMsg', 'â³ æ­£åœ¨æµ‹è¯•...');
            UIManager.clearLog();
            UIManager.log(`ğŸš€ å¼€å§‹æµ‹è¯• SN: ${sn}`);

            RecordManager.createOrUpdate({ sn, isNewTest: true });

            try {
                if (!app.serial.test.connected) throw new Error('æµ‹è¯•ä¸²å£æœªè¿æ¥');
                app.state.test.currentStep = 'WAITING_FOR_DSN';
                await this.startTestReadLoop(sn, app);
                app.serial.test.buffer = '';
                const command = `ccmd DSN;${sn}\r\n`;
                await app.serial.test.writer.write(new TextEncoder().encode(command));
                UIManager.log(`ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ${command.trim()}`);
            } catch (e) {
                UIManager.log(`âŒ æµ‹è¯•å¯åŠ¨å¤±è´¥: ${e.message}`);
                await this.finishTest({ sn, serial: false, web: false }, app);
            }
        },

        async startTestReadLoop(sn, app) {
            await app.serial.test.stopReadLoop();
            app.state.test.currentSN = sn;
            const stepHandlers = {
                'WAITING_FOR_DSN': (buffer) => this.handleDsnResponse(buffer, sn, app),
                'WAITING_FOR_IMEI': (buffer) => this.handleImeiResponse(buffer, sn, app),
                'WAITING_FOR_ICCID': (buffer) => this.handleIccidResponse(buffer, sn, app),
            };

            app.serial.test.readLoop(async (textData) => {
                app.serial.test.buffer += textData;
                const handler = stepHandlers[app.state.test.currentStep];
                if (handler && (app.serial.test.buffer.includes('\n') || app.serial.test.buffer.includes('\r'))) {
                    await handler(app.serial.test.buffer);
                }
            }, (e) => {
                if (app.state.test.inProgress) {
                    UIManager.log(`âŒ æµ‹è¯•ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                    this.finishTest({ sn, serial: false, web: false }, app);
                }
            });

            this.setStepTimeout('WAITING_FOR_DSN', () => this.handleStepTimeout('WAITING_FOR_DSN', sn, app, () => {
                UIManager.log(`ğŸ”„ DSNå“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•...`);
                const command = `ccmd DSN;${sn}\r\n`;
                app.serial.test.writer.write(new TextEncoder().encode(command));
                this.setStepTimeout('WAITING_FOR_DSN', () => this.finishTest({ sn, serial: false, web: false }, app), config.timeouts.dsn, app);
            }), config.timeouts.dsn, app);
        },

        async handleDsnResponse(buffer, sn, app) {
            const match = buffer.match(/DSN;(\S+?)[\r\n]/);
            if (!match) return;
            this.clearStepTimeout('WAITING_FOR_DSN', app);
            const receivedValue = match[1].trim();
            if (receivedValue === sn) {
                UIManager.log(`âœ… æ”¶åˆ° DSN: ${receivedValue}ï¼ŒSN åŒ¹é…æˆåŠŸ`);
                RecordManager.createOrUpdate({ sn, snMatch: true, snMismatch: false });
                await this.startImeiTest(sn, app);
            } else {
                UIManager.log(`âŒ SNä¸åŒ¹é…! å‘é€: ${sn}, æ”¶åˆ°: ${receivedValue}`);
                RecordManager.createOrUpdate({ sn, snMismatch: true });
                await this.finishTest({ sn, serial: false, web: false }, app);
            }
            app.serial.test.buffer = '';
        },

        async handleImeiResponse(buffer, sn, app) {
            const match = buffer.match(/IME;(\S+?)[\r\n]/);
            if (!match) return;
            this.clearStepTimeout('WAITING_FOR_IMEI', app);
            const receivedValue = match[1].trim();
            if (receivedValue.toLowerCase() === 'error') {
                UIManager.log(`âŒ æ”¶åˆ° IME ERROR`);
                RecordManager.createOrUpdate({ sn, imei: 'å¾…æµ‹è¯•', imeiFailed: true });
            } else {
                UIManager.log(`âœ… æ”¶åˆ° IME: ${receivedValue}`);
                RecordManager.createOrUpdate({ sn, imei: receivedValue });
            }
            await this.startIccidTest(sn, app);
            app.serial.test.buffer = '';
        },

        async handleIccidResponse(buffer, sn, app) {
            const match = buffer.match(/ICC;(\S+?)[\r\n]/);
            if (!match) return;
            this.clearStepTimeout('WAITING_FOR_ICCID', app);
            const receivedValue = match[1].trim();
            if (receivedValue.toLowerCase() === 'error') {
                UIManager.log(`âŒ æ”¶åˆ° ICC ERROR`);
                RecordManager.createOrUpdate({ sn, iccid: 'å¾…æµ‹è¯•', iccidFailed: true });
            } else {
                UIManager.log(`âœ… æ”¶åˆ° ICC: ${receivedValue}`);
                RecordManager.createOrUpdate({ sn, iccid: receivedValue });
            }
            UIManager.log(`âœ… ä¸²å£é€šä¿¡æµ‹è¯•: æ­£å¸¸`);
            RecordManager.createOrUpdate({ sn, serial: true });
            await this.startComponentAndLedTests(sn, app);
            app.serial.test.buffer = '';
        },

        async startImeiTest(sn, app) {
            app.state.test.currentStep = 'WAITING_FOR_IMEI';
            try {
                await app.serial.test.writer.write(new TextEncoder().encode('ccmd IME\r\n'));
                UIManager.log('ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ccmd IME');
                this.setStepTimeout('WAITING_FOR_IMEI', () => this.handleStepTimeout('WAITING_FOR_IMEI', sn, app, () => {
                    UIManager.log(`ğŸ”„ IMEIå“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•...`);
                    app.serial.test.writer.write(new TextEncoder().encode('ccmd IME\r\n'));
                    this.setStepTimeout('WAITING_FOR_IMEI', () => { RecordManager.createOrUpdate({ sn, imei: 'å¾…æµ‹è¯•', imeiFailed: true }); this.startIccidTest(sn, app); }, config.timeouts.imei, app);
                }), config.timeouts.imei, app);
            } catch (error) {
                UIManager.log(`âŒ å‘é€ IMEI æŸ¥è¯¢å‘½ä»¤å¤±è´¥: ${error.message}`);
                await this.startIccidTest(sn, app);
            }
        },

        async startIccidTest(sn, app) {
            app.state.test.currentStep = 'WAITING_FOR_ICCID';
            try {
                await app.serial.test.writer.write(new TextEncoder().encode('ccmd ICC\r\n'));
                UIManager.log('ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ccmd ICC');
                this.setStepTimeout('WAITING_FOR_ICCID', () => this.handleStepTimeout('WAITING_FOR_ICCID', sn, app, () => {
                    UIManager.log(`ğŸ”„ ICCIDå“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•...`);
                    app.serial.test.writer.write(new TextEncoder().encode('ccmd ICC\r\n'));
                    this.setStepTimeout('WAITING_FOR_ICCID', () => { RecordManager.createOrUpdate({ sn, iccid: 'å¾…æµ‹è¯•', iccidFailed: true }); this.startComponentAndLedTests(sn, app); }, config.timeouts.iccid, app);
                }), config.timeouts.iccid, app);
            } catch (error) {
                UIManager.log(`âŒ å‘é€ ICCID æŸ¥è¯¢å‘½ä»¤å¤±è´¥: ${error.message}`);
                await this.startComponentAndLedTests(sn, app);
            }
        },

        async startComponentAndLedTests(sn, app) {
            app.state.test.currentStep = 'COMPONENT_TESTS';
            const getAvg = async (key) => this.getAverageValue(() => parseFloat(app.state.device.status?.[key]) || 0);
            const tests = [
                { key: 'vout', name: 'å·¥ä½œç”µå‹', low: 4.9, high: 5.1, unit: 'V' },
                { key: 'iout', name: 'å·¥ä½œç”µæµ', low: 50, high: 200, unit: 'mA' },
                { key: 'ai0', name: 'DCDCä¾›ç”µ', low: 3800, high: 4100, unit: 'mV' },
                { key: 'ai1', name: 'ç½‘ç»œä¾›ç”µ', low: 3800, high: 4100, unit: 'mV' },
                { key: 'ai2', name: 'MCUä¾›ç”µ', low: 3200, high: 3400, unit: 'mV' },
            ];
            for (const t of tests) {
                UIManager.log(`âš¡ æµ‹è¯•${t.name}...`);
                const val = await getAvg(t.key);
                const pass = val >= t.low && val < t.high;
                UIManager.log(`ğŸ“Š ${t.name}: ${val.toFixed(3)}${t.unit}, ç»“æœ: ${pass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
                RecordManager.createOrUpdate({ sn, [t.key]: pass });
            }
            await this.startLedTests(sn, app);
        },

        async startLedTests(sn, app) {
            app.state.test.currentStep = 'LED_TESTS';
            UIManager.log('ğŸ” å¼€å§‹ LED æŒ‡ç¤ºç¯æµ‹è¯•...');
            const send = (cmd) => app.serial.test.writer.write(new TextEncoder().encode(cmd));
            const delay = (ms) => new Promise(res => setTimeout(res, ms));
            const getAvgColorR = () => this.getAverageValue(() => parseFloat(app.state.device.status?.color_r) || app.state.device.colorR || 0);

            await send('ccmd LED;6;0\r\n'); await delay(1000);
            let colorR = await getAvgColorR();
            let pass = colorR > 26;
            UIManager.log(`ğŸ“Š ç”µæºæŒ‡ç¤ºç¯ Color_R å¹³å‡å€¼: ${colorR.toFixed(3)}, ç»“æœ: ${pass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            RecordManager.createOrUpdate({ sn, powerLight: pass });

            await send('ccmd LED;3;1\r\n'); await delay(1000);
            colorR = await getAvgColorR();
            pass = (colorR / 2) > 26;
            UIManager.log(`ğŸ“Š 485æŒ‡ç¤ºç¯ å¹³å‡å€¼: ${colorR.toFixed(3)}, ç»“æœ: ${pass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            RecordManager.createOrUpdate({ sn, rs485Light: pass });

            await send('ccmd LED;4;1\r\n'); await delay(1000);
            colorR = await getAvgColorR();
            pass = (colorR / 3) > 26;
            UIManager.log(`ğŸ“Š ç½‘ç»œæŒ‡ç¤ºç¯ å¹³å‡å€¼: ${colorR.toFixed(3)}, ç»“æœ: ${pass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            RecordManager.createOrUpdate({ sn, networkLight: pass });

            await this.sendRstAndWait(sn, app);
        },

        async sendRstAndWait(sn, app) {
            try {
                UIManager.log('ğŸ“¤ å‘é€ AT+RST å‘½ä»¤è¿›è¡Œè®¾å¤‡é‡ç½®...');
                app.serial.status.buffer = '';
                await app.serial.status.writer.write(new TextEncoder().encode('AT+RST\r\n'));
                app.state.test.currentStep = 'WAITING_FOR_RST';
                UIManager.log(`â³ ç­‰å¾… ${config.timeouts.rst / 1000} ç§’è®¾å¤‡é‡ç½®å®Œæˆ...`);
                await new Promise(resolve => setTimeout(resolve, config.timeouts.rst));
                UIManager.log('âœ… è®¾å¤‡é‡ç½®å®Œæˆï¼Œå¼€å§‹ç½‘ç»œè¿æ¥æµ‹è¯•');
                await this.startWebTest(sn, app);
            } catch (error) {
                UIManager.log(`âŒ å‘é€ AT+RST å‘½ä»¤å¤±è´¥: ${error.message}`);
                await this.finishTest({ sn, serial: false, web: false }, app);
            }
        },

        async _generateTestUrl(sn) {
            const encrypted = await DgwCrypto.encrypt("DAAN" + sn);
            return encrypted ? `${config.urls.test}${encrypted}` : null;
        },

        async startWebTest(sn, app) {
            UIManager.update('testMsg', 'ğŸ”— æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...');
            const testUrl = await this._generateTestUrl(sn);

            let webResult = false;
            if (testUrl) {
                UIManager.log(`ğŸŒ æµ‹è¯•ç½‘å€: ${testUrl}`);
                try {
                    const proxiedUrl = `https://cors.lorenzoliam.workers.dev/?url=${encodeURIComponent(testUrl)}`;
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), config.timeouts.fetch);
                    const response = await fetch(proxiedUrl, { signal: controller.signal, mode: 'cors', cache: 'no-cache' });
                    clearTimeout(timeoutId);
                    if (response.ok) {
                        UIManager.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ');
                        webResult = true;
                    }
                } catch (e) {
                    UIManager.log(`âŒ ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}`);
                }
            } else {
                UIManager.log('âŒ URL ç”Ÿæˆå¤±è´¥');
            }
            const currentRecord = app.records.find(r => r.sn === sn);
            await this.finishTest({ ...currentRecord, sn, web: webResult }, app);
        },

        async finishTest(result, app) {
            await app.serial.test.stopReadLoop();
            if (!app.state.test.inProgress) return;
            app.state.test.inProgress = false; 
            Object.values(app.state.test.stepTimeouts).forEach(clearTimeout);
            app.state.test.stepTimeouts = {};
            app.state.test.stepRetryCount = {};
            app.state.test.currentStep = 'DONE';

            const finalStatus = !!(result.serial && result.web);
            RecordManager.createOrUpdate({ ...result, status: finalStatus });

            UIManager.log(`ğŸ“Š æµ‹è¯•å®Œæˆ: ${finalStatus ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            UIManager.update('testMsg', `âœ… æµ‹è¯•å®Œæˆ: ${finalStatus ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`, finalStatus ? 'success' : 'error');

            if (config.autoReport) {
                app.state.reporting = true;
                UIManager.updateButtons(app);
                await RecordManager.report();
                app.state.reporting = false;
            }

            UIManager.updateButtons(app);
            ui.scanInput.value = '';
            ui.scanInput.focus();
        },

        startStatusReadLoop(app) {
            app.serial.status.readLoop((text) => {
                app.serial.status.buffer += text;
                if (app.serial.status.buffer.includes('Color_C=')) {
                    this.parseStatus(app.serial.status.buffer.trim(), app);
                    app.serial.status.buffer = '';
                }
            }, (err) => {
                UIManager.log(`âŒ çŠ¶æ€ä¸²å£è¯»å–é”™è¯¯: ${err.message}`);
                app.toggleConnection('status');
            });
        },

        parseStatus(data, app) {
            const parsed = {};
            data.split(/\r?\n/).forEach(line => {
                const match = line.match(/^(\w+)[=:]\s*(.+)/);
                if (match) parsed[match[1].toLowerCase()] = match[2].trim();
            });

            if (parsed.color_r) app.state.device.colorR = parseFloat(parsed.color_r) || 0;

            const previousState = app.state.device.status?.state;
            app.state.device.status = parsed;
            const currentState = parsed.state;

            if (previousState !== currentState) {
                if (previousState === 'Ready' && currentState === 'Wait') {
                    UIManager.log('ğŸš€ æ£€æµ‹åˆ°è®¾å¤‡ä» Ready å˜ä¸º Waitï¼Œè‡ªåŠ¨å¼€å§‹åˆå§‹åŒ–...');
                    app.state.device.waitingForInitialization = false;
                    setTimeout(() => this.initializeDevice(app), 500);
                } else if (currentState === 'Ready') {
                    app.state.device.ready = true;
                    app.state.device.waitingForInitialization = false;
                    if (previousState === 'Wait') {
                        UIManager.update('statusMsg', 'âœ… è®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•', 'success');
                        UIManager.log('âœ… è®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œç°åœ¨å¯ä»¥å¼€å§‹æµ‹è¯•');
                    }
                } else if (currentState === 'Wait') {
                    app.state.device.ready = false;
                }
            }
            UIManager.updateButtons(app);
        },

        async checkAndInitializeDevice(app) {
            if (!app.serial.status.connected || !app.state.device.status) return;
            const state = app.state.device.status.state;
            if (state === 'Wait') {
                UIManager.log('ğŸ”§ æ£€æµ‹åˆ°è®¾å¤‡å¤„äºWaitçŠ¶æ€ï¼Œå¼€å§‹åˆå§‹åŒ–...');
                await this.initializeDevice(app);
            } else if (state === 'Ready') {
                UIManager.log('âš ï¸ è®¾å¤‡å·²å¤„äºReadyçŠ¶æ€ï¼Œè¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€è¿›è¡Œåˆå§‹åŒ–');
                UIManager.update('statusMsg', 'âš ï¸ è¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€ï¼Œç­‰å¾…è®¾å¤‡å˜ä¸ºWaitçŠ¶æ€åè‡ªåŠ¨åˆå§‹åŒ–', 'error');
                app.state.device.ready = false;
                app.state.device.waitingForInitialization = true;
                UIManager.updateButtons(app);
            }
        },

        async initializeDevice(app) {
            if (app.state.device.initializing || !app.serial.status.connected) return;
            app.state.device.initializing = true;
            app.state.device.ready = false;
            UIManager.updateButtons(app);
            UIManager.update('statusMsg', 'ğŸ”§ æ­£åœ¨åˆå§‹åŒ–è®¾å¤‡...');
            try {
                const commands = [
                    { cmd: 'AT+CAL\r\n', delay: 100, desc: 'æ ¡å‡†å‘½ä»¤' },
                    { cmd: 'AT+TCS=ON\r\n', delay: 100, desc: 'å¼€å¯TCSä¼ æ„Ÿå™¨' },
                    { cmd: 'AT+TIME=500\r\n', delay: 100, desc: 'è®¾ç½®æ—¶é—´å‚æ•°' }
                ];
                for (const command of commands) {
                    UIManager.log(`ğŸ“¤ å‘é€${command.desc}: ${command.cmd.trim()}`);
                    await app.serial.status.writer.write(new TextEncoder().encode(command.cmd));
                    if (command.delay > 0) await new Promise(resolve => setTimeout(resolve, command.delay));
                }
                UIManager.log('âœ… åˆå§‹åŒ–å®Œæˆï¼Œè¯·åˆä¸Šæµ‹è¯•æ¶å¼€è¿›è¡Œæµ‹è¯•...');
                UIManager.update('statusMsg', 'âœ… è®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œè¯·åˆä¸Šæµ‹è¯•æ¶å¼€è¿›è¡Œæµ‹è¯•...', 'success');
            } catch (error) {
                UIManager.log(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                UIManager.update('statusMsg', 'âŒ è®¾å¤‡åˆå§‹åŒ–å¤±è´¥', 'error');
            } finally {
                app.state.device.initializing = false;
                UIManager.updateButtons(app);
            }
        },

        async getAverageValue(sampleFunction) {
            const samples = [];
            for (let i = 0; i < config.sampling.count; i++) {
                samples.push(await sampleFunction());
                if (i < config.sampling.count - 1) await new Promise(resolve => setTimeout(resolve, config.sampling.interval));
            }
            samples.sort((a, b) => a - b);
            if (samples.length <= 2) return samples[0] || 0;
            const validSamples = samples.slice(1, -1);
            const average = validSamples.reduce((sum, val) => sum + val, 0) / validSamples.length;
            UIManager.log(`ğŸ“Š é‡‡æ ·æ•°æ®: [${samples.join(', ')}] -> å¹³å‡å€¼: ${average.toFixed(3)}`);
            return average;
        },

        setStepTimeout(step, callback, timeout, app) {
            this.clearStepTimeout(step, app);
            app.state.test.stepTimeouts[step] = setTimeout(callback, timeout);
        },

        clearStepTimeout(step, app) {
            if (app.state.test.stepTimeouts[step]) clearTimeout(app.state.test.stepTimeouts[step]);
        },

        handleStepTimeout(step, sn, app, retryCallback) {
            if (!app.state.test.stepRetryCount[step]) app.state.test.stepRetryCount[step] = 0;
            app.state.test.stepRetryCount[step]++;
            if (app.state.test.stepRetryCount[step] <= 1) {
                retryCallback();
            } else {
                this.finishTest({ sn, serial: false, web: false }, app);
            }
        },
    };

    // ==================================================================================
    // åº”ç”¨å¯åŠ¨
    // ==================================================================================
    if ('serial' in navigator) {
        app.init();
    } else {
        alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
        document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>';
    }
</script>
</body>
</html>
