<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ•°æ®æ£’æµ‹è¯•</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background-color: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .status-reporting { color: #ffc107; }
        .status-report-success { color: #28a745; }
        .status-report-failed { color: #dc3545; }
        .flex { display: flex; gap: 20px; flex-wrap: wrap; }
        .flex > div { flex: 1; min-width: 300px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .status-item { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .status-item span:first-child { color: #555; }
        .status-value { font-weight: bold; }
        .status-ready { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-on { color: #28a745; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background-color: #fff; }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background-color: #f8f8f8; }
        .pass { background-color: #d4edda; color: #155724; }
        .fail { background-color: #f8d7da; color: #721c24; }
        .testing { background-color: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 160px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .color-preview { width: 100%; height: 30px; border: 1px solid #ddd; margin-top: 10px; border-radius: 4px; }
        .hidden { display: none; }
        input[type="text"] { width: 200px; padding: 8px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px; }
    </style>
</head>
<body>
<h1>æ•°æ®æ£’æµ‹è¯•</h1>

<div class="panel">
    <div class="flex">
        <div class="panel panel-green" style="margin: 10px; flex: 1;">
            <h4>ç¡¬ä»¶ä¸²å£</h4>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="selectStatusBtn">é€‰æ‹©çŠ¶æ€ä¸²å£</button>
                <button class="btn" id="toggleStatusBtn">è¿æ¥</button>
                <div id="statusMsg"></div>
            </div>
        </div>

        <div class="panel panel-blue" style="margin: 10px; flex: 1;">
            <h4>è½¯ä»¶ä¸²å£</h4>
            <div style="margin: 10px 0; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn" id="selectTestBtn">é€‰æ‹©æµ‹è¯•ä¸²å£</button>
                <button class="btn" id="toggleTestBtn">è¿æ¥</button>
                <div style="display: flex; align-items: center;">
                    <label for="scanInput">SN:</label>
                    <input type="text" id="scanInput" placeholder="è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ..." />
                </div>
                <button class="btn" id="saveRecordsBtn">ä¿å­˜è®°å½•</button>
                <div id="testMsg"></div>
            </div>
        </div>
    </div>
</div>


<div class="panel">
    <table>
        <thead><tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>å·¥ä½œç”µå‹</th><th>å·¥ä½œç”µæµ</th><th>DCDC</th><th>ç½‘ç»œä¾›ç”µ</th><th>MCUä¾›ç”µ</th><th>ç”µæºç¯</th><th>ä¸²å£ç¯</th><th>ç½‘ç»œç¯</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
    const config = {
        aes: { keyString: "me%ov2Ied|eicegh", ivString: "me%ov2Ied|eicegh" },
        urls: { 
            test: "http://gw.3wlink.cn:22011/?dgwkey=",
            report: "https://webhook.site/02ce59b3-856d-4142-b71f-9e5256be505a" // ä¸ŠæŠ¥æœåŠ¡å™¨URL
        },
        baudRates: { status: 115200, test: 10000000 },
        timeouts: { 
            dsn: 5000,      // DSNå“åº”è¶…æ—¶
            imei: 5000,     // IMEIå“åº”è¶…æ—¶
            iccid: 5000,    // ICCIDå“åº”è¶…æ—¶
            rst: 20000,     // AT+RSTé‡ç½®ç­‰å¾…æ—¶é—´
            led: 2000,      // LEDæµ‹è¯•è¶…æ—¶
            fetch: 5000,    // ç½‘ç»œè®¿é—®è¶…æ—¶
            report: 10000   // ä¸ŠæŠ¥è¶…æ—¶
        },
        autoReport: true // è‡ªåŠ¨ä¸ŠæŠ¥æ‰€æœ‰æµ‹è¯•ç»“æœ
    };

    const ui = {
        selectStatusBtn: document.getElementById('selectStatusBtn'),
        toggleStatusBtn: document.getElementById('toggleStatusBtn'),
        statusMsg: document.getElementById('statusMsg'),
        selectTestBtn: document.getElementById('selectTestBtn'),
        toggleTestBtn: document.getElementById('toggleTestBtn'),
        scanInput: document.getElementById('scanInput'),
        saveRecordsBtn: document.getElementById('saveRecordsBtn'),
        testMsg: document.getElementById('testMsg'),
        resultBody: document.getElementById('resultBody'),
        logBox: document.getElementById('logBox'),
    };

    const DgwCrypto = {
        _key: null, _iv: null,
        async init() {
            if (this._key) return;
            try {
                const keyBytes = new TextEncoder().encode(config.aes.keyString);
                this._iv = new TextEncoder().encode(config.aes.ivString);
                this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
            } catch (error) {
                console.error(":", error);
                throw error;
            }
        },
        async encrypt(plainText) {
            if (!this._key) { await this.init(); }
            try {
                const textBytes = new TextEncoder().encode(plainText);
                const blockSize = 16;
                let paddedData;
                if (textBytes.length % blockSize === 0) {
                    paddedData = new Uint8Array(textBytes);
                } else {
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    paddedData = new Uint8Array(textBytes.length + paddingNeeded);
                    paddedData.set(textBytes);
                }
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                const encryptedArray = new Uint8Array(encrypted);
                const truncated = encryptedArray.slice(0, paddedData.length);
                const base64 = btoa(String.fromCharCode(...truncated));
                return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            } catch (error) {
                console.error('åŠ å¯†å¤±è´¥:', error);
                return null;
            }
        }
    };

    // æ ¹æ®SNç”ŸæˆåŠ å¯†åçš„æµ‹è¯•URL
    async function generateTestUrl(sn) {
        const plainText = "DAAN" + sn;
        const encrypted = await DgwCrypto.encrypt(plainText);
        return encrypted ? `${config.urls.test}${encrypted}` : null;
    }

    // åˆ›å»ºDOMå…ƒç´ çš„è¾…åŠ©å‡½æ•°
    function createElement(tag, options = {}) {
        const el = document.createElement(tag);
        if (options.text) el.textContent = options.text;
        if (options.className) el.className = options.className;
        if (options.style) Object.assign(el.style, options.style);
        return el;
    }

    // ä¸²å£ç®¡ç†ç±»ï¼Œå°è£…äº†è¿æ¥ã€æ–­å¼€ã€è¯»å†™ç­‰æ“ä½œ
    class SerialManager {
        constructor(type) { this.type = type; this.port = null; this.reader = null; this.writer = null; this.connected = false; this.buffer = ''; this.readLoopActive = false; }
        async select() { try { this.port = await navigator.serial.requestPort(); return true; } catch { return false; } }
        async connect(baudRate) { if (!this.port) return false; try { await this.port.open({ baudRate }); this.reader = this.port.readable?.getReader(); this.writer = this.port.writable?.getWriter(); this.connected = true; return true; } catch (e) { console.error(`${this.type} connection failed:`, e); return false; } }
        async disconnect() { this.readLoopActive = false; if (!this.connected && !this.port) return; if (this.reader) { try { await this.reader.cancel(); } catch { /* Ignore */ } finally { this.reader = null; } } if (this.writer) { try { await this.writer.close(); } catch { /* Ignore */ } finally { this.writer = null; } } if (this.port) { try { await this.port.close(); } catch { /* Ignore */ } } this.connected = false; this.buffer = ''; }
        async readLoop(onData, onError) {
            if (!this.reader || !this.connected) return;
            this.readLoopActive = true;
            while (this.connected && this.readLoopActive) {
                try {
                    const { value, done } = await this.reader.read();
                    if (done) break;
                    if (onData) onData(new TextDecoder().decode(value));
                } catch (e) {
                    if (this.connected) { if (onError) onError(e); }
                    break;
                }
            }
            this.readLoopActive = false;
        }
    }

    // ä¸»åº”ç”¨é€»è¾‘å¯¹è±¡
    const app = {
        status: new SerialManager('status'),
        test: new SerialManager('test'),
        testing: false,
        records: [],
        stepTimeouts: {},
        currentTestStep: '',
        retryState: {},
        stepRetryCount: {},
        currentColorR: 0,
        currentTestingSN: '',
        reporting: false,
        initializing: false,
        deviceReady: false,
        currentDeviceStatus: null,
        previousDeviceState: null,
        waitingForInitialization: false,

        // åœ¨æ—¥å¿—æ¡†ä¸­æ‰“å°ä¸€æ¡å¸¦æ—¶é—´æˆ³çš„æ—¥å¿—
        log(msg) {
            const timestamp = new Date().toLocaleTimeString();
            ui.logBox.textContent += `\n[${timestamp}] ${msg}`;
            ui.logBox.scrollTop = ui.logBox.scrollHeight;
        },

        // æ¸…ç©ºæ—¥å¿—æ¡†
        clearLog() {
            ui.logBox.textContent = 'æµ‹è¯•æ—¥å¿—...';
        },

        // æ›´æ–°UIå…ƒç´ ï¼ˆå¦‚çŠ¶æ€æ¶ˆæ¯ï¼‰çš„æ–‡æœ¬å’Œé¢œè‰²
        updateUI(id, text, type = 'info') {
            const el = ui[id];
            if (!el) return;
            el.textContent = text;
            el.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black';
        },

        // è¯·æ±‚ç”¨æˆ·é€‰æ‹©ä¸€ä¸ªä¸²å£
        async selectPort(type) {
            const manager = this[type];
            const success = await manager.select();
            this.updateUI(`${type}Msg`, success ? 'âœ… ä¸²å£å·²é€‰æ‹©' : 'âŒ é€‰æ‹©å¤±è´¥', success ? 'success' : 'error');
            if (success) { await this.savePortSelection(type, manager.port); }
            this.updateButtons();
        },

        // å°†ç”¨æˆ·é€‰æ‹©çš„ä¸²å£ä¿å­˜åˆ°localStorageï¼Œä»¥ä¾¿ä¸‹æ¬¡è‡ªåŠ¨åŠ è½½
        async savePortSelection(type, selectedPort) {
            try {
                const allPorts = await navigator.serial.getPorts();
                const portIndex = allPorts.indexOf(selectedPort);
                if (portIndex > -1) { localStorage.setItem(`serialPort_${type}`, portIndex.toString()); this.log(`ğŸ’¾ å·²ä¿å­˜ ${type === 'status' ? 'çŠ¶æ€' : 'æµ‹è¯•'} ä¸²å£é€‰æ‹©`); }
            } catch (e) {
                console.error('ä¿æŒé€‰æ‹©ç«¯å£å¤±è´¥:', e);
            }
        },

        // ä»localStorageåŠ è½½ä¹‹å‰ä¿å­˜çš„ä¸²å£
        async loadPortSelection(type) {
            try {
                const savedIndex = localStorage.getItem(`serialPort_${type}`);
                if (savedIndex === null) return null;
                const allPorts = await navigator.serial.getPorts();
                return allPorts[parseInt(savedIndex, 10)] || null;
            } catch (e) {
                console.error('æœªèƒ½åŠ è½½ç«¯å£é€‰æ‹©:', e);
                return null;
            }
        },

        // è¿æ¥æŒ‡å®šç±»å‹çš„ä¸²å£
        async connect(type) {
            const manager = this[type];
            if (!manager.port || manager.connected) return;
            this.updateUI(`${type}Msg`, 'âŒ› è¿æ¥ä¸­...');
            const success = await manager.connect(config.baudRates[type]);
            this.updateUI(`${type}Msg`, success ? 'âœ… å·²è¿æ¥' : 'âŒ è¿æ¥å¤±è´¥', success ? 'success' : 'error');
            if (success && type === 'status') { 
                this.startStatusReadLoop();
                // ç­‰å¾…çŠ¶æ€æ•°æ®åå†è¿›è¡Œåˆå§‹åŒ–æ£€æŸ¥
                setTimeout(() => {
                    // æ¯æ¬¡ç‚¹å‡»è¿æ¥æ—¶éƒ½è¿›è¡Œæ£€æŸ¥
                    this.checkAndInitializeDevice();
                }, 1000);
            }
            this.updateButtons();
        },
        
        // åˆ‡æ¢è¿æ¥çŠ¶æ€
        async toggleConnection(type) {
            const manager = this[type];
            if (manager.connected) {
                await this.disconnect(type);
            } else {
                await this.connect(type);
            }
        },

        // æ–­å¼€æŒ‡å®šç±»å‹çš„ä¸²å£
        async disconnect(type) {
            await this[type].disconnect();
            this.updateUI(`${type}Msg`, 'â„¹ï¸ å·²æ–­å¼€');
            if (type === 'status') { 
                this.deviceReady = false;
                this.currentDeviceStatus = null;
            }
            this.updateButtons();
        },

        // æ ¹æ®åº”ç”¨çŠ¶æ€æ›´æ–°æŒ‰é’®çš„å¯ç”¨æ€§
        updateButtons() {
            // çŠ¶æ€ä¸²å£æŒ‰é’®
            if (this.status.connected) {
                ui.toggleStatusBtn.textContent = 'æ–­å¼€';
                ui.toggleStatusBtn.disabled = false;
            } else {
                ui.toggleStatusBtn.textContent = 'è¿æ¥';
                ui.toggleStatusBtn.disabled = !this.status.port;
            }
            
            // æµ‹è¯•ä¸²å£æŒ‰é’®
            if (this.test.connected) {
                ui.toggleTestBtn.textContent = 'æ–­å¼€';
                ui.toggleTestBtn.disabled = false;
            } else {
                ui.toggleTestBtn.textContent = 'è¿æ¥';
                ui.toggleTestBtn.disabled = !this.test.port;
            }
            
            const testInProgress = this.testing || this.initializing;
            ui.selectTestBtn.disabled = testInProgress;
            
            // SNè¾“å…¥æ¡†éœ€è¦è®¾å¤‡å°±ç»ªã€æµ‹è¯•ä¸²å£å·²è¿æ¥ä¸”æ²¡æœ‰æ­£åœ¨æµ‹è¯•æˆ–åˆå§‹åŒ–æ—¶æ‰èƒ½ä½¿ç”¨
            ui.scanInput.disabled = testInProgress || !this.deviceReady || this.waitingForInitialization || !this.test.connected;
            
            ui.saveRecordsBtn.disabled = this.records.length === 0 || testInProgress;
            
            // æ›´æ–°è¾“å…¥æ¡†çš„æç¤ºæ–‡æœ¬
            if (this.initializing) {
                ui.scanInput.placeholder = 'è®¾å¤‡åˆå§‹åŒ–ä¸­ï¼Œè¯·ç¨å€™...';
            } else if (this.waitingForInitialization) {
                ui.scanInput.placeholder = 'ç­‰å¾…è®¾å¤‡åˆå§‹åŒ–ï¼Œè¯·å°†æµ‹è¯•æ¶ç§»å¼€...';
            } else if (!this.deviceReady) {
                ui.scanInput.placeholder = 'è®¾å¤‡æœªå°±ç»ªï¼Œè¯·è¿æ¥çŠ¶æ€ä¸²å£...';
            } else if (!this.test.connected) {
                ui.scanInput.placeholder = 'è¯·è¿æ¥æµ‹è¯•ä¸²å£...';
            } else {
                ui.scanInput.placeholder = 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...';
            }
        },

        // å¯åŠ¨çŠ¶æ€ç›‘æ§ä¸²å£çš„å¾ªç¯è¯»å–
        startStatusReadLoop() {
            this.status.readLoop((text) => {
                this.status.buffer += text;
                if (this.status.buffer.includes('Color_C=')) {
                    this.parseStatus(this.status.buffer.trim());
                    this.status.buffer = '';
                }
            }, (err) => {
                this.log(`âŒ çŠ¶æ€ä¸²å£è¯»å–é”™è¯¯: ${err.message}`);
                this.disconnect('status');
            });
        },

        // è§£æä»çŠ¶æ€ä¸²å£æ”¶åˆ°çš„æ•°æ®
        parseStatus(data) {
            const parsed = {};
            data.split(/\r?\n/).forEach(line => {
                const match = line.match(/^(\w+)[=:]\s*(.+)/);
                if (match) { parsed[match[1].toLowerCase()] = match[2].trim(); }
            });
            
            // æ›´æ–° Color_R å€¼ç”¨äº LED æµ‹è¯•
            if (parsed.color_r) {
                this.currentColorR = parseFloat(parsed.color_r) || 0;
            }
            
            const previousState = this.currentDeviceStatus?.state;
            this.currentDeviceStatus = parsed;
            const currentState = parsed.state;
            
            // æ£€æµ‹çŠ¶æ€å˜åŒ–
            if (previousState !== currentState) {
                this.log(`ğŸ”„ è®¾å¤‡çŠ¶æ€å˜åŒ–: ${previousState || '\u672a\u77e5'} -> ${currentState}`);
                
                // å¦‚æœä» Ready å˜ä¸º Waitï¼Œè‡ªåŠ¨å¼€å§‹åˆå§‹åŒ–
                if (previousState === 'Ready' && currentState === 'Wait') {
                    this.log('ğŸš€ æ£€æµ‹åˆ°è®¾å¤‡ä» Ready å˜ä¸º Waitï¼Œè‡ªåŠ¨å¼€å§‹åˆå§‹åŒ–...');
                    this.waitingForInitialization = false;
                    setTimeout(() => this.initializeDevice(), 500);
                }
                // å¦‚æœä» Wait å˜ä¸º Readyï¼Œè®¾å¤‡å°±ç»ª
                else if (previousState === 'Wait' && currentState === 'Ready') {
                    this.deviceReady = true;
                    this.waitingForInitialization = false;
                    this.updateUI('statusMsg', 'âœ… è®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•', 'success');
                    this.log('âœ… è®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œç°åœ¨å¯ä»¥å¼€å§‹æµ‹è¯•');
                }
                // å¦‚æœçŠ¶æ€æ˜¯ Readyï¼Œä½†ä¹‹å‰ä¸æ˜¯åˆå§‹åŒ–çŠ¶æ€
                else if (currentState === 'Ready') {
                    this.deviceReady = true;
                    this.waitingForInitialization = false;
                }
                // å¦‚æœçŠ¶æ€æ˜¯ Wait
                else if (currentState === 'Wait') {
                    this.deviceReady = false;
                }
            }
            
            this.updateButtons();
        },


        // æ£€æŸ¥è®¾å¤‡çŠ¶æ€å¹¶è¿›è¡Œåˆå§‹åŒ–
        async checkAndInitializeDevice() {
            if (!this.status.connected || !this.currentDeviceStatus) {
                return;
            }

            const state = this.currentDeviceStatus.state;
            if (state === 'Wait') {
                this.log('ğŸ”§ æ£€æµ‹åˆ°è®¾å¤‡å¤„äºWaitçŠ¶æ€ï¼Œå¼€å§‹åˆå§‹åŒ–...');
                await this.initializeDevice();
            } else if (state === 'Ready') {
                this.log('âš ï¸ è®¾å¤‡å·²å¤„äºReadyçŠ¶æ€ï¼Œè¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€è¿›è¡Œåˆå§‹åŒ–');
                this.updateUI('statusMsg', 'âš ï¸ è¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€ï¼Œç­‰å¾…è®¾å¤‡å˜ä¸ºWaitçŠ¶æ€åè‡ªåŠ¨åˆå§‹åŒ–', 'error');
                this.deviceReady = false;
                this.waitingForInitialization = true;
                this.updateButtons();
            } else {
                this.log('âš ï¸ è®¾å¤‡çŠ¶æ€æœªçŸ¥ï¼š' + state);
            }
        },

        // æ‰§è¡Œè®¾å¤‡åˆå§‹åŒ–å‘½ä»¤åºåˆ—
        async initializeDevice() {
            if (this.initializing || !this.status.connected) {
                return;
            }

            this.initializing = true;
            this.deviceReady = false;
            this.updateButtons();
            this.updateUI('statusMsg', 'ğŸ”§ æ­£åœ¨åˆå§‹åŒ–è®¾å¤‡...');

            try {
                // å‘é€åˆå§‹åŒ–å‘½ä»¤åºåˆ—å‰æ¸…ç©ºç¼“å†²åŒº
                this.clearSerialBuffer('status');
                
                const commands = [
                    { cmd: 'AT+CAL\r\n', delay: 50, desc: 'æ ¡å‡†å‘½ä»¤' },
                    { cmd: 'AT+TCS=ON\r\n', delay: 50, desc: 'å¼€å¯TCSä¼ æ„Ÿå™¨' },
                    { cmd: 'AT+TIME=1000\r\n', delay: 50, desc: 'è®¾ç½®æ—¶é—´å‚æ•°' }
                ];

                for (const command of commands) {
                    this.log(`ğŸ“¤ å‘é€${command.desc}: ${command.cmd.trim()}`);
                    await this.status.writer.write(new TextEncoder().encode(command.cmd));
                    if (command.delay > 0) {
                        await new Promise(resolve => setTimeout(resolve, command.delay));
                    }
                }

                this.log('âœ… åˆå§‹åŒ–å®Œæˆï¼Œè¯·åˆä¸Šæµ‹è¯•æ¶å¼€è¿›è¡Œæµ‹è¯•...');
                this.updateUI('statusMsg', 'âœ… è®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œè¯·åˆä¸Šæµ‹è¯•æ¶å¼€è¿›è¡Œæµ‹è¯•...', 'success');
                
                // ä¸åœ¨è¿™é‡Œç›´æ¥è®¾ç½® deviceReadyï¼Œç­‰å¾… parseStatus ä¸­æ£€æµ‹åˆ° Ready çŠ¶æ€æ—¶å†è®¾ç½®

            } catch (error) {
                this.log(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                this.updateUI('statusMsg', 'âŒ è®¾å¤‡åˆå§‹åŒ–å¤±è´¥', 'error');
            } finally {
                this.initializing = false;
                this.updateButtons();
            }
        },

        // éªŒè¯è®¾å¤‡ç”µå‹å’Œç”µæµå‚æ•°
        validateDeviceParameters(status) {
            if (!status) return {};

            const vout = parseFloat(status.vout) || 0;
            const iout = parseFloat(status.iout) || 0;
            const ai0 = parseFloat(status.ai0) || 0;
            const ai1 = parseFloat(status.ai1) || 0;
            const ai2 = parseFloat(status.ai2) || 0;

            return {
                vout: vout >= 4.9 && vout < 5.1,
                iout: iout >= 50 && iout < 200,
                ai0: ai0 >= 3800 && ai0 < 4100,
                ai1: ai1 >= 3800 && ai1 < 4100,
                ai2: ai2 >= 3200 && ai2 < 3400,
                voutValue: vout,
                ioutValue: iout,
                ai0Value: ai0,
                ai1Value: ai1,
                ai2Value: ai2
            };
        },

        // å¼€å§‹å®Œæ•´çš„æµ‹è¯•æµç¨‹
        async startTest(sn) {
            if (!this.test.port || this.testing || !sn || !this.deviceReady) {
                if (!this.deviceReady) {
                    this.log('âš ï¸ è®¾å¤‡æœªå°±ç»ªï¼Œè¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€è¿›è¡Œåˆå§‹åŒ–');
                    this.updateUI('testMsg', 'âš ï¸ è¯·å…ˆå°†æµ‹è¯•æ¶ç§»å¼€è¿›è¡Œåˆå§‹åŒ–', 'error');
                }
                return;
            }
            
            // éªŒè¯è®¾å¤‡å‚æ•°
            const validation = this.validateDeviceParameters(this.currentDeviceStatus);
            
            this.testing = true;
            this.retryState = {};
            this.stepRetryCount = {};
            this.updateButtons();
            this.updateUI('testMsg', 'â³ æ­£åœ¨æµ‹è¯•...');
            this.clearLog();
            this.log(`ğŸš€ å¼€å§‹æµ‹è¯• SN: ${sn}`);
            
            // åˆ›å»ºåŒ…å«éªŒè¯ç»“æœçš„æµ‹è¯•è®°å½•
            const initialResult = {
                sn,
                vout: validation.vout,
                iout: validation.iout,
                ai0: validation.ai0,
                ai1: validation.ai1,
                ai2: validation.ai2,
                networkLight: '-',
                rs485Light: '-',
                powerLight: '-'
            };
            
            this.addOrUpdateTestResult(initialResult);

            // ä¸å†è®¾ç½®å…¨å±€è¶…æ—¶ï¼Œæ¯ä¸ªæµ‹è¯•æ­¥éª¤éƒ½æœ‰ç‹¬ç«‹è¶…æ—¶

            try {
                // ä¸å†è‡ªåŠ¨æ–­å¼€è¿æ¥ï¼Œä½¿ç”¨ç°æœ‰è¿æ¥æˆ–ç”±ç”¨æˆ·æ‰‹åŠ¨è¿æ¥
                if (!this.test.connected) {
                    this.log('âš ï¸ æµ‹è¯•ä¸²å£æœªè¿æ¥ï¼Œè¯·å…ˆè¿æ¥æµ‹è¯•ä¸²å£');
                    throw new Error('æµ‹è¯•ä¸²å£æœªè¿æ¥');
                }
                
                this.currentTestStep = 'WAITING_FOR_DSN';
                this.startTestReadLoop(sn);
                this.clearSerialBuffer('test'); // æ¸…ç©ºæµ‹è¯•ä¸²å£ç¼“å†²åŒº
                const command = `ccmd DSN;${sn}\r\n`;
                await this.test.writer.write(new TextEncoder().encode(command));
                this.log(`ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ${command.trim()}`);
            } catch (e) {
                this.log(`âŒ æµ‹è¯•å¯åŠ¨å¤±è´¥: ${e.message}`);
                this.finishTest({ sn, serial: false, web: false });
            }
        },

        // å¯åŠ¨æµ‹è¯•ä¸²å£çš„å¾ªç¯è¯»å–ï¼Œæ–°çš„æµ‹è¯•æµç¨‹
        startTestReadLoop(sn) {
            this.processingData = false;
            this.test.buffer = '';
            this.currentTestingSN = sn; // ä¿å­˜å½“å‰æµ‹è¯•çš„SNåˆ°å®ä¾‹å˜é‡
            
            this.test.readLoop(async (textData) => {
                if (this.processingData) return;
                this.test.buffer += textData;

                try {
                    // DSN å“åº”å¤„ç†
                    if (this.currentTestStep === 'WAITING_FOR_DSN') {
                        // ç­‰å¾…æ¥æ”¶åˆ°æ¢è¡Œç¬¦æˆ–è¶³å¤Ÿé•¿çš„æ•°æ®å†å¤„ç†ï¼Œé¿å…SNè¢«æˆªæ–­ (DSN; + 20ä½SN = 24å­—ç¬¦)
                        if (this.test.buffer.includes('\n') || this.test.buffer.includes('\r') || 
                            (this.test.buffer.includes('DSN;') && this.test.buffer.length >= 24)) {
                            const match = this.test.buffer.match(/DSN;(\S+)/);
                            if (match) {
                                this.processingData = true;
                                const receivedValue = match[1].trim();
                                const expectedSN = this.currentTestingSN; // ä½¿ç”¨ä¿å­˜çš„SN
                            
                                // æ¸…é™¤ DSN è¶…æ—¶
                                if (this.stepTimeouts['WAITING_FOR_DSN']) {
                                    clearTimeout(this.stepTimeouts['WAITING_FOR_DSN']);
                                    delete this.stepTimeouts['WAITING_FOR_DSN'];
                                }
                            
                                if (receivedValue === expectedSN) {
                                    this.log(`âœ… æ”¶åˆ° DSN: ${receivedValue}ï¼ŒSN åŒ¹é…æˆåŠŸ`);
                                    this.addOrUpdateTestResult({ sn: expectedSN, snMatch: true, snMismatch: false });
                                    // SN åŒ¹é…åå¼€å§‹ IMEI æµ‹è¯•
                                    this.startImeiIccidTests(expectedSN);
                                } else {
                                    // SNä¸åŒ¹é…ï¼Œå°è¯•é‡è¯•
                                    if (!this.stepRetryCount['SN_MISMATCH']) {
                                        this.stepRetryCount['SN_MISMATCH'] = 0;
                                    }
                                    this.stepRetryCount['SN_MISMATCH']++;
                                    
                                    if (this.stepRetryCount['SN_MISMATCH'] <= 1) {
                                        this.log(`âŒ SNä¸åŒ¹é…! å‘é€: ${expectedSN}, æ”¶åˆ°: ${receivedValue}ï¼Œæ­£åœ¨é‡è¯•... (ç¬¬ ${this.stepRetryCount['SN_MISMATCH']} æ¬¡)`);
                                        this.addOrUpdateTestResult({ sn: expectedSN, snMismatch: true });
                                        
                                        // æ¸…ç©ºç¼“å†²åŒºå¹¶é‡æ–°å‘é€DSNå‘½ä»¤
                                        this.clearSerialBuffer('test');
                                        const command = `ccmd DSN;${expectedSN}\r\n`;
                                        await this.test.writer.write(new TextEncoder().encode(command));
                                        this.log(`ğŸ“¤ é‡æ–°å‘é€æŒ‡ä»¤: ${command.trim()}`);
                                        
                                        // é‡æ–°è®¾ç½®è¶…æ—¶
                                        this.setStepTimeout('WAITING_FOR_DSN', () => {
                                            this.log(`â° DSNå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œæµ‹è¯•å¤±è´¥`);
                                            this.finishTest({ sn: expectedSN, serial: false, web: false });
                                        }, config.timeouts.dsn);
                                    } else {
                                        this.log(`âŒ SNæœ€ç»ˆä¸åŒ¹é…! å‘é€: ${expectedSN}, æ”¶åˆ°: ${receivedValue}`);
                                        this.addOrUpdateTestResult({ sn: expectedSN, snMismatch: true });
                                        this.finishTest({ sn: expectedSN, serial: false, web: false });
                                    }
                                }
                            
                                this.test.buffer = '';
                                this.processingData = false;
                            }
                        }
                    }
                    // IMEI å“åº”å¤„ç†
                    else if (this.currentTestStep === 'WAITING_FOR_IMEI') {
                        // ç­‰å¾…æ¥æ”¶åˆ°æ¢è¡Œç¬¦æˆ–è¶³å¤Ÿé•¿çš„æ•°æ®å†å¤„ç†ï¼Œé¿å…IMEIè¢«æˆªæ–­ (IME; + 15ä½IMEI = 19å­—ç¬¦)
                        if (this.test.buffer.includes('\n') || this.test.buffer.includes('\r') || 
                            (this.test.buffer.includes('IME;') && this.test.buffer.length >= 19)) {
                            const match = this.test.buffer.match(/IME;(\S+)/);
                            if (match) {
                                this.processingData = true;
                                const receivedValue = match[1].trim();
                                const expectedSN = this.currentTestingSN;
                            
                                // æ¸…é™¤ IMEI è¶…æ—¶
                                if (this.stepTimeouts['WAITING_FOR_IMEI']) {
                                    clearTimeout(this.stepTimeouts['WAITING_FOR_IMEI']);
                                    delete this.stepTimeouts['WAITING_FOR_IMEI'];
                                }
                            
                                if (receivedValue.toLowerCase() === 'error') {
                                    this.log(`âŒ æ”¶åˆ° IME ERROR`);
                                    this.addOrUpdateTestResult({ sn: expectedSN, imei: '-', imeiFailed: true });
                                } else {
                                    this.log(`âœ… æ”¶åˆ° IME: ${receivedValue}`);
                                    this.addOrUpdateTestResult({ sn: expectedSN, imei: receivedValue });
                                }
                            
                                this.startIccidTest(expectedSN);
                                this.test.buffer = '';
                                this.processingData = false;
                            }
                        }
                    }
                    // ICCID å“åº”å¤„ç†
                    else if (this.currentTestStep === 'WAITING_FOR_ICCID') {
                        // ç­‰å¾…æ¥æ”¶åˆ°æ¢è¡Œç¬¦æˆ–è¶³å¤Ÿé•¿çš„æ•°æ®å†å¤„ç†ï¼Œé¿å…ICCIDè¢«æˆªæ–­ (ICC; + 20ä½ICCID = 24å­—ç¬¦)
                        if (this.test.buffer.includes('\n') || this.test.buffer.includes('\r') || 
                            (this.test.buffer.includes('ICC;') && this.test.buffer.length >= 24)) {
                            const match = this.test.buffer.match(/ICC;(\S+)/);
                            if (match) {
                                this.processingData = true;
                                const receivedValue = match[1].trim();
                                const expectedSN = this.currentTestingSN;
                            
                                // æ¸…é™¤ ICCID è¶…æ—¶
                                if (this.stepTimeouts['WAITING_FOR_ICCID']) {
                                    clearTimeout(this.stepTimeouts['WAITING_FOR_ICCID']);
                                    delete this.stepTimeouts['WAITING_FOR_ICCID'];
                                }
                            
                                if (receivedValue.toLowerCase() === 'error') {
                                    this.log(`âŒ æ”¶åˆ° ICC ERROR`);
                                    this.addOrUpdateTestResult({ sn: expectedSN, iccid: '-', iccidFailed: true });
                                } else {
                                    this.log(`âœ… æ”¶åˆ° ICC: ${receivedValue}`);
                                    this.addOrUpdateTestResult({ sn: expectedSN, iccid: receivedValue });
                                }
                            
                                // ICCID å®Œæˆåï¼Œæ˜¾ç¤ºä¸²å£é€šä¿¡ç»“æœå¹¶ç»§ç»­åç»­æµ‹è¯•
                                this.log(`âœ… ä¸²å£é€šä¿¡æµ‹è¯•: æ­£å¸¸`);
                                this.addOrUpdateTestResult({ sn: expectedSN, serial: true });
                                this.startLedAndComponentTests(expectedSN);
                                this.test.buffer = '';
                                this.processingData = false;
                            }
                        }
                    }
                } catch (e) {
                    this.log(`âŒ å¤„ç†ä¸²å£æ•°æ®æ—¶å‡ºé”™: ${e.message}`);
                    this.finishTest({ sn: this.currentTestingSN, serial: false, web: false });
                    this.processingData = false;
                }
            }, (e) => {
                if (this.testing) { 
                    this.log(`âŒ æµ‹è¯•ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`); 
                    this.finishTest({ sn: this.currentTestingSN, serial: false, web: false }); 
                }
            });
            
            // ä¸º DSN æ­¥éª¤è®¾ç½®è¶…æ—¶
            this.setStepTimeout('WAITING_FOR_DSN', () => {
                this.handleStepTimeout('WAITING_FOR_DSN', this.currentTestingSN, () => {
                    // DSN é‡è¯•é€»è¾‘
                    this.log(`ğŸ”„ DSNå“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•... (ç¬¬ ${this.stepRetryCount['WAITING_FOR_DSN']} æ¬¡)`);
                    this.clearSerialBuffer('test'); // æ¸…ç©ºæµ‹è¯•ä¸²å£ç¼“å†²åŒº
                    const command = `ccmd DSN;${this.currentTestingSN}\r\n`;
                    this.test.writer.write(new TextEncoder().encode(command));
                    this.log(`ğŸ“¤ é‡æ–°å‘é€æŒ‡ä»¤: ${command.trim()}`);
                    
                    // é‡æ–°è®¾ç½®è¶…æ—¶
                    this.setStepTimeout('WAITING_FOR_DSN', () => {
                        this.log(`â° DSNå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œæµ‹è¯•å¤±è´¥`);
                        this.finishTest({ sn: this.currentTestingSN, serial: false, web: false });
                    }, config.timeouts.dsn);
                }, () => {
                    // æœ€ç»ˆå¤±è´¥
                    this.log(`â° DSNå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œæµ‹è¯•å¤±è´¥`);
                    this.finishTest({ sn: this.currentTestingSN, serial: false, web: false });
                });
            }, config.timeouts.dsn);
        },
        
        // è®¾ç½®æ­¥éª¤è¶…æ—¶
        setStepTimeout(step, callback, timeout) {
            if (this.stepTimeouts[step]) {
                clearTimeout(this.stepTimeouts[step]);
            }
            this.stepTimeouts[step] = setTimeout(callback, timeout);
        },
        
        // å¤„ç†æ­¥éª¤è¶…æ—¶å’Œé‡è¯•
        handleStepTimeout(step, sn, retryCallback, finalFailCallback) {
            if (!this.stepRetryCount[step]) {
                this.stepRetryCount[step] = 0;
            }
            
            this.stepRetryCount[step]++;
            
            if (this.stepRetryCount[step] <= 1) {
                // ç¬¬ä¸€æ¬¡è¶…æ—¶ï¼Œè¿›è¡Œé‡è¯•
                retryCallback();
            } else {
                // ç¬¬äºŒæ¬¡è¶…æ—¶ï¼Œæœ€ç»ˆå¤±è´¥
                finalFailCallback();
            }
        },
        
        // æ¸…ç©ºä¸²å£æ¥æ”¶ç¼“å†²åŒº
        clearSerialBuffer(type = 'test') {
            const manager = this[type];
            if (manager && manager.buffer) {
                manager.buffer = '';
                this.log(`ğŸ§¹ å·²æ¸…ç©º${type === 'status' ? 'çŠ¶æ€ç›‘æ§' : 'æµ‹è¯•'}ä¸²å£æ¥æ”¶ç¼“å†²åŒº`);
            }
        },
        
        // è·å–æœ€æ–°çš„Color_Rå€¼
        getCurrentColorR() {
            if (this.currentDeviceStatus && this.currentDeviceStatus.color_r) {
                this.currentColorR = parseFloat(this.currentDeviceStatus.color_r) || 0;
                this.log(`ğŸ” è·å–æœ€æ–°Color_Rå€¼: ${this.currentColorR}`);
            } else {
                this.log(`âš ï¸ æ— æ³•è·å–Color_Rå€¼ï¼Œä½¿ç”¨ä¸Šæ¬¡å€¼: ${this.currentColorR}`);
            }
            return this.currentColorR;
        },
        
        // å‘é€ AT+RST å‘½ä»¤å¹¶ç­‰å¾… 20 ç§’
        async sendRstAndWait(sn) {
            try {
                this.log('ğŸ“¤ å‘é€ AT+RST å‘½ä»¤è¿›è¡Œè®¾å¤‡é‡ç½®...');
                this.clearSerialBuffer('status'); // æ¸…ç©ºçŠ¶æ€ç›‘æ§ä¸²å£ç¼“å†²åŒº
                await this.status.writer.write(new TextEncoder().encode('AT+RST\r\n'));
                
                this.currentTestStep = 'WAITING_FOR_RST';
                this.log(`â³ ç­‰å¾… 20 ç§’è®¾å¤‡é‡ç½®å®Œæˆ...`);
                
                // è®¾ç½® 20 ç§’å®šæ—¶å™¨
                setTimeout(() => {
                    this.log('âœ… è®¾å¤‡é‡ç½®å®Œæˆï¼Œå¼€å§‹ç½‘ç»œè¿æ¥æµ‹è¯•');
                    this.startWebTest(sn);
                }, config.timeouts.rst);
                
            } catch (error) {
                this.log(`âŒ å‘é€ AT+RST å‘½ä»¤å¤±è´¥: ${error.message}`);
                this.finishTest({ sn, serial: false, web: false });
            }
        },
        
        // å¼€å§‹ LED å’Œç”µå­å…ƒä»¶æµ‹è¯•åºåˆ—
        async startLedAndComponentTests(sn) {
            this.currentTestStep = 'COMPONENT_TESTS';
            this.log('ğŸ” ä¸²å£é€šä¿¡å®Œæˆï¼Œå¼€å§‹ç”µå­å…ƒä»¶æ£€æµ‹...');
            
            // æ£€æµ‹ç”µå­å…ƒä»¶å‚æ•°
            const validation = this.validateDeviceParameters(this.currentDeviceStatus);
            this.addOrUpdateTestResult({ 
                sn, 
                vout: validation.vout, 
                iout: validation.iout, 
                ai0: validation.ai0, 
                ai1: validation.ai1, 
                ai2: validation.ai2 
            });
            
            // å¼€å§‹LEDæµ‹è¯•
            this.startLedTests(sn);
        },
        
        // å¼€å§‹ LED æµ‹è¯•åºåˆ—
        async startLedTests(sn) {
            this.currentTestStep = 'LED_TESTS';
            this.log('ğŸ” å¼€å§‹ LED æŒ‡ç¤ºç¯æµ‹è¯•...');
            
            // æ­¥éª¤1: å‘é€ ccmd LED;6;0 å¹¶ç­‰å¾… 20ms
            await this.sendLedCommand('ccmd LED;6;0\r\n', 20);
            
            // ç”µæºæŒ‡ç¤ºç¯æµ‹è¯•ï¼ˆæ£€æŸ¥ Color_R > 26ï¼‰
            setTimeout(() => this.testPowerLight(sn), 1000);
        },
        
        // å‘é€ LED å‘½ä»¤
        async sendLedCommand(command, delay) {
            try {
                this.log(`ğŸ“¤ å‘é€å‘½ä»¤: ${command.trim()}`);
                await this.test.writer.write(new TextEncoder().encode(command));
                if (delay > 0) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            } catch (error) {
                this.log(`âŒ å‘é€ LED å‘½ä»¤å¤±è´¥: ${error.message}`);
            }
        },
        
        // æµ‹è¯•ç”µæºæŒ‡ç¤ºç¯
        async testPowerLight(sn) {
            this.log('ğŸ’¡ æµ‹è¯•ç”µæºæŒ‡ç¤ºç¯...');
            const colorR = this.getCurrentColorR(); // è·å–æœ€æ–°å€¼
            const powerLightPass = colorR > 26;
            
            this.log(`ğŸ“Š å½“å‰ Color_R å€¼: ${colorR}, ç”µæºæŒ‡ç¤ºç¯: ${powerLightPass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            this.addOrUpdateTestResult({ sn, powerLight: powerLightPass ? 'æ­£å¸¸' : 'å¼‚å¸¸' });
            
            // ç­‰å¾… 20ms ç„¶åæµ‹è¯• 485 æŒ‡ç¤ºç¯
            setTimeout(() => this.test485Light(sn), 1000);
        },
        
        // æµ‹è¯• 485 æŒ‡ç¤ºç¯
        async test485Light(sn) {
            this.log('ğŸ’¡ æµ‹è¯• 485 æŒ‡ç¤ºç¯...');
            
            // å‘é€ ccmd LED;3;1
            await this.sendLedCommand('ccmd LED;3;1\r\n', 20);
            
            // ç­‰å¾…ä¸€ä¸‹è®©çŠ¶æ€æ›´æ–°ï¼Œç„¶åè·å–æœ€æ–°Color_Rå€¼
            setTimeout(() => {
                const colorR = this.getCurrentColorR(); // è·å–æœ€æ–°å€¼
                const rs485LightPass = (colorR / 2) > 26;
                
                this.log(`ğŸ“Š å½“å‰ Color_R å€¼: ${colorR}, Color_R/2 = ${colorR/2}, 485æŒ‡ç¤ºç¯: ${rs485LightPass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
                this.addOrUpdateTestResult({ sn, rs485Light: rs485LightPass ? 'æ­£å¸¸' : 'å¼‚å¸¸' });
                
                // ç­‰å¾… 20ms ç„¶åæµ‹è¯•ç½‘ç»œä¿¡å·æŒ‡ç¤ºç¯
                setTimeout(() => this.testNetworkLight(sn), 20);
            }, 1000); // ç»™LEDå‘½ä»¤ä¸€äº›æ—¶é—´ç”Ÿæ•ˆ
        },
        
        // æµ‹è¯•ç½‘ç»œä¿¡å·æŒ‡ç¤ºç¯
        async testNetworkLight(sn) {
            this.log('ğŸ’¡ æµ‹è¯•ç½‘ç»œä¿¡å·æŒ‡ç¤ºç¯...');
            
            // å‘é€ ccmd LED;4;1
            await this.sendLedCommand('ccmd LED;4;1\r\n', 20);
            
            // ç­‰å¾…ä¸€ä¸‹è®©çŠ¶æ€æ›´æ–°ï¼Œç„¶åè·å–æœ€æ–°Color_Rå€¼
            setTimeout(() => {
                const colorR = this.getCurrentColorR(); // è·å–æœ€æ–°å€¼
                const networkLightPass = (colorR / 3) > 26;
                
                this.log(`ğŸ“Š å½“å‰ Color_R å€¼: ${colorR}, Color_R/3 = ${(colorR/3).toFixed(2)}, ç½‘ç»œä¿¡å·æŒ‡ç¤ºç¯: ${networkLightPass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
                this.addOrUpdateTestResult({ sn, networkLight: networkLightPass ? 'æ­£å¸¸' : 'å¼‚å¸¸' });
                
                // LED æµ‹è¯•å®Œæˆï¼Œå‘é€ AT+RST
                setTimeout(() => this.sendRstAndWait(sn), 20);
            }, 1000); // ç»™LEDå‘½ä»¤ä¸€äº›æ—¶é—´ç”Ÿæ•ˆ
        },
        
        // å¼€å§‹ IMEI å’Œ ICCID æµ‹è¯•
        async startImeiIccidTests(sn) {
            this.log('ğŸ“‹ å¼€å§‹è·å– IMEI å’Œ ICCID...');
            this.currentTestStep = 'WAITING_FOR_IMEI';
            
            // å‘é€ IMEI æŸ¥è¯¢å‘½ä»¤
            try {
                this.clearSerialBuffer('test'); // æ¸…ç©ºæµ‹è¯•ä¸²å£ç¼“å†²åŒº
                await this.test.writer.write(new TextEncoder().encode('ccmd IME\r\n'));
                this.log('ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ccmd IME');
                
                // è®¾ç½® IMEI è¶…æ—¶
                this.setStepTimeout('WAITING_FOR_IMEI', () => {
                    this.handleStepTimeout('WAITING_FOR_IMEI', sn, () => {
                        // IMEI é‡è¯•é€»è¾‘
                        this.log(`ğŸ”„ IMEIå“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•... (ç¬¬ ${this.stepRetryCount['WAITING_FOR_IMEI']} æ¬¡)`);
                        this.clearSerialBuffer('test'); // æ¸…ç©ºæµ‹è¯•ä¸²å£ç¼“å†²åŒº
                        const command = 'ccmd IME\r\n';
                        this.test.writer.write(new TextEncoder().encode(command));
                        this.log(`ğŸ“¤ é‡æ–°å‘é€æŒ‡ä»¤: ${command.trim()}`);
                        
                        // é‡æ–°è®¾ç½®è¶…æ—¶
                        this.setStepTimeout('WAITING_FOR_IMEI', () => {
                            this.log(`â° IMEIå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œè·³è¿‡åˆ° ICCID`);
                            this.addOrUpdateTestResult({ sn, imei: '-', imeiFailed: true });
                            this.startIccidTest(sn);
                        }, config.timeouts.imei);
                    }, () => {
                        // æœ€ç»ˆå¤±è´¥
                        this.log(`â° IMEIå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œè·³è¿‡åˆ° ICCID`);
                        this.addOrUpdateTestResult({ sn, imei: '-', imeiFailed: true });
                        this.startIccidTest(sn);
                    });
                }, config.timeouts.imei);
                
            } catch (error) {
                this.log(`âŒ å‘é€ IMEI æŸ¥è¯¢å‘½ä»¤å¤±è´¥: ${error.message}`);
                this.startIccidTest(sn);
            }
        },
        
        // å¼€å§‹ ICCID æµ‹è¯•
        async startIccidTest(sn) {
            this.log('ğŸ“‹ å¼€å§‹è·å– ICCID...');
            this.currentTestStep = 'WAITING_FOR_ICCID';
            
            try {
                this.clearSerialBuffer('test'); // æ¸…ç©ºæµ‹è¯•ä¸²å£ç¼“å†²åŒº
                await this.test.writer.write(new TextEncoder().encode('ccmd ICC\r\n'));
                this.log('ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ccmd ICC');
                
                // è®¾ç½® ICCID è¶…æ—¶
                this.setStepTimeout('WAITING_FOR_ICCID', () => {
                    this.handleStepTimeout('WAITING_FOR_ICCID', sn, () => {
                        // ICCID é‡è¯•é€»è¾‘
                        this.log(`ğŸ”„ ICCIDå“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•... (ç¬¬ ${this.stepRetryCount['WAITING_FOR_ICCID']} æ¬¡)`);
                        this.clearSerialBuffer('test'); // æ¸…ç©ºæµ‹è¯•ä¸²å£ç¼“å†²åŒº
                        const command = 'ccmd ICC\r\n';
                        this.test.writer.write(new TextEncoder().encode(command));
                        this.log(`ğŸ“¤ é‡æ–°å‘é€æŒ‡ä»¤: ${command.trim()}`);
                        
                        // é‡æ–°è®¾ç½®è¶…æ—¶
                        this.setStepTimeout('WAITING_FOR_ICCID', () => {
                            this.log(`â° ICCIDå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œç»§ç»­åç»­æµ‹è¯•`);
                            this.addOrUpdateTestResult({ sn, iccid: '-', iccidFailed: true });
                            this.startLedAndComponentTests(sn);
                        }, config.timeouts.iccid);
                    }, () => {
                        // æœ€ç»ˆå¤±è´¥
                        this.log(`â° ICCIDå“åº”æœ€ç»ˆè¶…æ—¶ï¼Œç»§ç»­åç»­æµ‹è¯•`);
                        this.addOrUpdateTestResult({ sn, iccid: '-', iccidFailed: true });
                        this.startLedAndComponentTests(sn);
                    });
                }, config.timeouts.iccid);
                
            } catch (error) {
                this.log(`âŒ å‘é€ ICCID æŸ¥è¯¢å‘½ä»¤å¤±è´¥: ${error.message}`);
                this.startLedAndComponentTests(sn);
            }
        },
        
        // å¼€å§‹ç½‘ç»œæµ‹è¯•
        async startWebTest(sn) {
            this.log('ğŸ”— å¼€å§‹ç½‘ç»œè¿æ¥æµ‹è¯•...');
            this.updateUI('testMsg', 'ğŸ”— æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...');
            const webResult = await this.testWebConnection(sn);
            
            // è·å–å½“å‰è®°å½•å¹¶å®Œæˆæµ‹è¯•
            const currentRecord = this.records.find(r => r.sn === sn);
            this.finishTest({ 
                ...currentRecord, 
                sn, 
                serial: true, // æ‰€æœ‰ä¸²å£æµ‹è¯•éƒ½å·²å®Œæˆ
                web: webResult 
            });
        },


        // æ‰§è¡Œç½‘ç»œè¿æ¥æµ‹è¯•
        async testWebConnection(sn) {
            const testUrl = await generateTestUrl(sn);
            if (!testUrl) { this.log('âŒ URL ç”Ÿæˆå¤±è´¥'); return false; }
            this.log(`ğŸŒ æµ‹è¯•ç½‘å€: ${testUrl}`);
            const fetchData = async (url, timeout) => { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), timeout); try { const response = await fetch(url, { signal: controller.signal, mode: 'cors', cache: 'no-cache' }); return response.ok; } finally { clearTimeout(timeoutId); } };
            try { 
                if (await fetchData(testUrl, config.timeouts.fetch)) { 
                    this.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ'); 
                    return true; 
                } 
            } catch (e) { 
                this.log(`âŒ ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}`); 
            }
            return false;
        },

        // ç»“æŸå½“å‰æµ‹è¯•ï¼Œå¹¶æ›´æ–°æœ€ç»ˆç»“æœ
        async finishTest(result) {
            if (!this.testing) return;
            // æ¸…é™¤æ‰€æœ‰æ­¥éª¤è¶…æ—¶å’Œé‡è¯•è®¡æ•°å™¨
            Object.values(this.stepTimeouts).forEach(timeout => clearTimeout(timeout));
            this.stepTimeouts = {};
            this.stepRetryCount = {};
            this.currentTestStep = 'DONE'; // æ ‡è®°çŠ¶æ€æœºç»“æŸï¼Œé˜²æ­¢è¶…æ—¶åä»å¤„ç†ä¸²å£æ¶ˆæ¯

            const finalResult = { sn: result.sn || this.currentTestingSN || ui.scanInput.value, imei: result.imei || '-', iccid: result.iccid || '-', serial: result.serial, web: result.web, status: result.serial && result.web ? 'æ­£å¸¸' : 'ä¸é€šè¿‡' };
            this.addOrUpdateTestResult(finalResult);

            this.log(`ğŸ“Š æµ‹è¯•å®Œæˆ: ${finalResult.status}`);
            this.updateUI('testMsg', `âœ… æµ‹è¯•å®Œæˆ: ${finalResult.status}`, finalResult.status === 'æ­£å¸¸' ? 'success' : 'error');
            
            // è‡ªåŠ¨ä¸ŠæŠ¥åŠŸèƒ½
            if (config.autoReport) {
                setTimeout(() => this.reportResults(), 1000); // å»¶è¿Ÿ1ç§’è‡ªåŠ¨ä¸ŠæŠ¥æ‰€æœ‰ç»“æœ
            }
            // ä¸å†è‡ªåŠ¨æ–­å¼€æµ‹è¯•ä¸²å£ï¼Œç”±ç”¨æˆ·æ‰‹åŠ¨æ§åˆ¶
            this.testing = false;
            this.updateButtons();
            ui.scanInput.value = '';
            ui.scanInput.focus();
        },

        // å‘è¡¨æ ¼ä¸­æ–°å¢æˆ–æ›´æ–°ä¸€æ¡æµ‹è¯•è®°å½•çš„UIæ˜¾ç¤º
        addOrUpdateTestResult(partialResult) {
            const passFail = (val) => val === true ? 'pass' : (val === false ? 'fail' : 'testing');
            const getTextAndClass = (val) => {
                if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
                if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
                if (val === 'pending') return { text: 'å¾…æµ‹è¯•', className: '' };
                return { text: 'æµ‹è¯•ä¸­...', className: 'testing' };
            };
            const getStringStatusClass = (val) => {
                if (val === 'æ­£å¸¸' || val === 'æ­£å¸¸') return 'pass';
                if (val === 'å¼‚å¸¸' || val === 'ä¸é€šè¿‡') return 'fail';
                if (val === '-' || val === 'å¾…æµ‹è¯•') return '';
                return 'testing';
            };
            let record = this.records.find(r => r.sn === partialResult.sn);

            if (!record) {
                record = { 
                    sn: partialResult.sn, timestamp: Date.now(), 
                    imei: '-', iccid: '-', 
                    vout: 'pending', iout: 'pending', ai0: 'pending', ai1: 'pending', ai2: 'pending',
                    networkLight: '-', rs485Light: '-', powerLight: '-',
                    serial: 'pending', web: 'pending', status: 'pending', 
                    row: ui.resultBody.insertRow(0), snMismatch: false, snMatch: false, reported: false 
                };
                this.records.unshift(record);
                for (let i = 0; i < 16; i++) record.row.insertCell(); // 16åˆ—ï¼šæ—¶é—´ã€SNã€IMEIã€ICCIDã€5ä¸ªç”µå‹ç”µæµã€3ä¸ªæŒ‡ç¤ºç¯ã€ä¸²å£ã€ç½‘é¡µã€ç»“æœã€ä¸ŠæŠ¥
            } else {
                // å¦‚æœæ˜¯é‡å¤æµ‹è¯•ç›¸åŒçš„SNï¼Œé‡ç½®çŠ¶æ€ä½†ä¿ç•™è¡Œ
                if (partialResult.sn && !partialResult.hasOwnProperty('imei') && !partialResult.hasOwnProperty('iccid') && 
                    !partialResult.hasOwnProperty('web') && partialResult.hasOwnProperty('snMatch')) {
                    // è¿™æ˜¯ä¸€ä¸ªæ–°çš„æµ‹è¯•å¼€å§‹ï¼Œé‡ç½®ç›¸å…³çŠ¶æ€
                    record.timestamp = Date.now();
                    record.snMismatch = false;
                    record.snMatch = false;
                    record.serial = 'pending';
                    record.web = 'pending';
                    record.status = 'pending';
                    record.reported = false;
                    record.imei = '-';
                    record.iccid = '-';
                    record.imeiFailed = false;
                    record.iccidFailed = false;
                    record.networkLight = '-';
                    record.rs485Light = '-';
                    record.powerLight = '-';
                    record.vout = 'pending';
                    record.iout = 'pending';
                    record.ai0 = 'pending';
                    record.ai1 = 'pending';
                    record.ai2 = 'pending';
                }
            }

            Object.assign(record, partialResult);
            const { row, timestamp, sn, imei, iccid, vout, iout, ai0, ai1, ai2, networkLight, rs485Light, powerLight, serial, web, status } = record;
            if (!row) return;

            // å¡«å……è¡¨æ ¼å•å…ƒæ ¼ - æŒ‰æ–°æµ‹è¯•é¡ºåºï¼šæ—¶é—´ã€SNã€IMEIã€ICCIDã€ä¸²å£é€šä¿¡ã€å·¥ä½œç”µå‹ã€å·¥ä½œç”µæµã€DCDCä¾›ç”µã€WIFI/4Gä¾›ç”µã€MCUä¾›ç”µã€ç”µæºæŒ‡ç¤ºç¯ã€485æŒ‡ç¤ºç¯ã€ç½‘ç»œä¿¡å·æŒ‡ç¤ºç¯ã€ç½‘é¡µè®¿é—®ã€æµ‹è¯•ç»“æœã€ä¸ŠæŠ¥çŠ¶æ€
            let cellIndex = 0;
            
            // 0. æ—¶é—´
            row.cells[cellIndex].textContent = new Date(timestamp).toLocaleString();
            cellIndex++;
            
            // 1. SN
            row.cells[cellIndex].textContent = sn;
            row.cells[cellIndex].className = record.snMismatch ? 'fail' : (record.snMatch ? 'pass' : '');
            cellIndex++;
            
            // 2-3. IMEIå’ŒICCID
            const imeiText = imei === '-' ? 'å¾…æµ‹è¯•' : imei;
            row.cells[cellIndex].textContent = imeiText;
            row.cells[cellIndex].className = imei !== '-' ? 'pass' : (record.imeiFailed ? 'fail' : '');
            cellIndex++;
            
            const iccidText = iccid === '-' ? 'å¾…æµ‹è¯•' : iccid;
            row.cells[cellIndex].textContent = iccidText;
            row.cells[cellIndex].className = iccid !== '-' ? 'pass' : (record.iccidFailed ? 'fail' : '');
            cellIndex++;
            
            // 4. ä¸²å£é€šä¿¡ (DSNæµ‹è¯•)
            const serialStatus = getTextAndClass(serial);
            row.cells[cellIndex].textContent = serialStatus.text;
            row.cells[cellIndex].className = serialStatus.className;
            cellIndex++;
            
            // 5-9. ç”µå‹ç”µæµæ£€æµ‹ç»“æœ
            const voutStatus = getTextAndClass(vout);
            row.cells[cellIndex].textContent = voutStatus.text;
            row.cells[cellIndex].className = voutStatus.className;
            cellIndex++;
            
            const ioutStatus = getTextAndClass(iout);
            row.cells[cellIndex].textContent = ioutStatus.text;
            row.cells[cellIndex].className = ioutStatus.className;
            cellIndex++;
            
            const ai0Status = getTextAndClass(ai0);
            row.cells[cellIndex].textContent = ai0Status.text;
            row.cells[cellIndex].className = ai0Status.className;
            cellIndex++;
            
            const ai1Status = getTextAndClass(ai1);
            row.cells[cellIndex].textContent = ai1Status.text;
            row.cells[cellIndex].className = ai1Status.className;
            cellIndex++;
            
            const ai2Status = getTextAndClass(ai2);
            row.cells[cellIndex].textContent = ai2Status.text;
            row.cells[cellIndex].className = ai2Status.className;
            cellIndex++;
            
            // 10-12. æŒ‡ç¤ºç¯çŠ¶æ€ (æŒ‰æµ‹è¯•é¡ºåºï¼šç”µæºã€485ã€ç½‘ç»œ)
            const powerLightText = powerLight === '-' ? 'å¾…æµ‹è¯•' : powerLight;
            row.cells[cellIndex].textContent = powerLightText;
            row.cells[cellIndex].className = getStringStatusClass(powerLightText);
            cellIndex++;
            
            const rs485LightText = rs485Light === '-' ? 'å¾…æµ‹è¯•' : rs485Light;
            row.cells[cellIndex].textContent = rs485LightText;
            row.cells[cellIndex].className = getStringStatusClass(rs485LightText);
            cellIndex++;
            
            const networkLightText = networkLight === '-' ? 'å¾…æµ‹è¯•' : networkLight;
            row.cells[cellIndex].textContent = networkLightText;
            row.cells[cellIndex].className = getStringStatusClass(networkLightText);
            cellIndex++;
            
            // 13. ç½‘é¡µè®¿é—®æµ‹è¯•
            const webStatus = getTextAndClass(web);
            row.cells[cellIndex].textContent = webStatus.text;
            row.cells[cellIndex].className = webStatus.className;
            cellIndex++;
            
            // 14. æœ€ç»ˆæµ‹è¯•ç»“æœ
            if (status !== 'pending') {
                row.cells[cellIndex].textContent = status;
                row.cells[cellIndex].className = passFail(status === 'æ­£å¸¸');
            } else {
                row.cells[cellIndex].textContent = 'æµ‹è¯•ä¸­...';
                row.cells[cellIndex].className = 'testing';
            }
            cellIndex++;
            
            // 15. ä¸ŠæŠ¥çŠ¶æ€
            if (record.reported) {
                row.cells[cellIndex].textContent = 'å·²ä¸ŠæŠ¥';
                row.cells[cellIndex].className = 'pass';
            } else if (status !== 'pending') {
                row.cells[cellIndex].textContent = 'å¾…ä¸ŠæŠ¥';
                row.cells[cellIndex].className = 'testing';
            } else {
                row.cells[cellIndex].textContent = 'å¾…æµ‹è¯•';
                row.cells[cellIndex].className = '';
            }
        },

        // ä¸ŠæŠ¥æµ‹è¯•ç»“æœåˆ°æœåŠ¡å™¨
        async reportResults() {
            if (this.records.length === 0) {
                    this.log('âš ï¸ æ²¡æœ‰æµ‹è¯•ç»“æœå¯ä¸ŠæŠ¥');
                return;
            }

            if (this.reporting) {
                return;
            }

            this.reporting = true;
            this.updateButtons();
            this.log('ğŸ“® ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...');

            try {
                const reportData = {
                    deviceId: 'DGS-100', // å¯ä»¥ä»é…ç½®ä¸­è·å–
                    results: this.records.map(record => ({
                        sn: record.sn,
                        imei: record.imei,
                        iccid: record.iccid,
                        serialTest: record.serial,
                        webTest: record.web,
                        overallStatus: record.status
                    }))
                };

                const response = await fetch(config.urls.report, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'User-Agent': 'DGS-100-Tester/1.0'
                    },
                    body: JSON.stringify(reportData),
                    signal: AbortSignal.timeout(config.timeouts.report)
                });

                if (response.ok) {
                    const responseData = await response.json().catch(() => ({}));
                    this.log(`âœ… ä¸ŠæŠ¥æˆåŠŸï¼Œå“åº”: ${response.status}`);
                    
                    // æ›´æ–°è®°å½•çŠ¶æ€ä¸ºå·²ä¸ŠæŠ¥
                    this.records.forEach(record => {
                        record.reported = true;
                        this.addOrUpdateTestResult(record); // åˆ·æ–°UIæ˜¾ç¤º
                    });
                } else {
                    throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status} - ${response.statusText}`);
                }
            } catch (error) {
                let errorMsg = 'ä¸ŠæŠ¥å¤±è´¥';
                if (error.name === 'TimeoutError') {
                    errorMsg = 'ä¸ŠæŠ¥è¶…æ—¶';
                } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMsg = 'ç½‘ç»œè¿æ¥å¤±è´¥';
                }
                
                this.log(`âŒ ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
            } finally {
                this.reporting = false;
                this.updateButtons();
            }
        },
        
        // å°†æ‰€æœ‰æµ‹è¯•è®°å½•ä¿å­˜ä¸ºCSVæ–‡ä»¶
        saveRecords() {
            if (this.records.length === 0) { alert('æ²¡æœ‰æµ‹è¯•è®°å½•å¯ä¾›ä¿å­˜ã€‚'); return; }
            const header = ['æ—¶é—´', 'SN', 'IMEI', 'ICCID', 'ä¸²å£é€šä¿¡', 'å·¥ä½œç”µå‹', 'å·¥ä½œç”µæµ', 'DCDC', 'ç½‘ç»œä¾›ç”µ', 'MCUä¾›ç”µ', 'ç”µæºç¯', 'ä¸²å£ç¯', 'ç½‘ç»œç¯', 'ç½‘é¡µè®¿é—®', 'æµ‹è¯•ç»“æœ'];
            const formatResult = (val) => {
                if (val === true) return 'æ­£å¸¸';
                if (val === false) return 'å¼‚å¸¸';
                if (val === 'pending') return 'å¾…æµ‹è¯•';
                if (val === '-') return 'å¾…æµ‹è¯•';
                return val || 'å¾…æµ‹è¯•';
            };
            const rows = this.records.map(r => [
                new Date(r.timestamp).toLocaleString('zh-CN'), 
                r.sn, 
                formatResult(r.imei),
                formatResult(r.iccid),
                formatResult(r.serial),
                formatResult(r.vout), 
                formatResult(r.iout), 
                formatResult(r.ai0), 
                formatResult(r.ai1), 
                formatResult(r.ai2), 
                formatResult(r.powerLight),
                formatResult(r.rs485Light),
                formatResult(r.networkLight),
                formatResult(r.web), 
                r.status || 'æµ‹è¯•ä¸­'
            ]);
            const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
            const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `æ•°æ®æ£’æµ‹è¯•è®°å½•_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        },

        // è®¾ç½®æ‰€æœ‰UIå…ƒç´ çš„äº‹ä»¶ç›‘å¬å™¨
        setupEventListeners() {
            ui.selectStatusBtn.addEventListener('click', () => this.selectPort('status'));
            ui.toggleStatusBtn.addEventListener('click', () => this.toggleConnection('status'));
            ui.selectTestBtn.addEventListener('click', () => this.selectPort('test'));
            ui.toggleTestBtn.addEventListener('click', () => this.toggleConnection('test'));
            ui.saveRecordsBtn.addEventListener('click', () => this.saveRecords());
            ui.scanInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const value = ui.scanInput.value.trim();
                    if (value && !this.testing) { this.startTest(value); } else if (this.testing) { this.log('âš ï¸ æµ‹è¯•è¿›è¡Œä¸­ï¼Œè¯·å‹¿é‡å¤æ‰«ç '); }
                }
            });
            ui.scanInput.addEventListener('blur', () => { if (!this.testing) { setTimeout(() => ui.scanInput.focus(), 100); } });
        },

        // åº”ç”¨ç¨‹åºåˆå§‹åŒ–å…¥å£
        async init() {
            try {
                await DgwCrypto.init();
            } catch (e) {
                alert('urlç”Ÿæˆåˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚è¯·åˆ·æ–°é¡µé¢æˆ–æ›´æ¢æµè§ˆå™¨é‡è¯•ã€‚');
                this.log('âŒ urlç”Ÿæˆæ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
                ui.scanInput.disabled = true;
                ui.selectTestBtn.disabled = true;
                return;
            }
            this.setupEventListeners();
            const savedStatusPort = await this.loadPortSelection('status');
            if (savedStatusPort) { this.status.port = savedStatusPort; this.updateUI('statusMsg', 'âœ… çŠ¶æ€ä¸²å£å·²åŠ è½½'); }
            const savedTestPort = await this.loadPortSelection('test');
            if (savedTestPort) { this.test.port = savedTestPort; this.updateUI('testMsg', 'âœ… æµ‹è¯•ä¸²å£å·²åŠ è½½'); }
            this.updateButtons();
            ui.scanInput.focus();
            this.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
        }
    };

    if ('serial' in navigator) {
        app.init();
    } else {
        alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
        document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>';
    }
</script>
</body>
</html>
