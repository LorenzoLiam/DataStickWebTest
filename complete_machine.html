<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 æ•´æœºæµ‹è¯• (4Gç‰ˆ)</title>
    <style>
        :root {
            --color-primary: #007bff;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-light: #f8f9fa;
            --color-dark: #343a40;
            --border-radius: 8px;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
        }
        body { font-family: system-ui, -apple-system, Roboto, sans-serif; padding: 5px 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: var(--border-radius); padding: 15px; margin: 10px 0; background: #fff; box-shadow: var(--shadow-sm); }
        .panel-blue { border-color: var(--color-primary); background: #f0f8ff; }
        .panel-green { border-color: var(--color-success); background: #f0fff0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background: #fff; border-radius: var(--border-radius); overflow: hidden; box-shadow: var(--shadow-sm); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background: var(--color-light); color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: var(--color-success); }
        .fail { background: #f8d7da; color: var(--color-danger); }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 150px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .table-container { max-height: 520px; overflow-y: auto; }
        .test-result-display {
            margin: 0; padding: 10px; border-radius: var(--border-radius); text-align: center; font-size: 30px; font-weight: bold; box-shadow: 0 3px 6px rgba(0,0,0,0.1); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            transition: background 0.3s ease, color 0.3s ease;
        }
        .test-result-display.pass { background: linear-gradient(135deg, #28a745, #20c997); color: white; border: 2px solid #1e7e34; }
        .test-result-display.fail { background: linear-gradient(135deg, #dc3545, #ff6b6b); color: white; border: 2px solid #bd2130; }
        .test-result-display.waiting { background: linear-gradient(135deg, #007bff, #3da9fc); color: white; border: 2px solid #0056b3; }
        .test-result-display.default { background: #f8f9fa; color: #6c757d; border: 2px solid #dee2e6; }
        .sim-label { font-size: 18px; display: flex; align-items: center; cursor: pointer; margin-left: auto; white-space: nowrap; }
        .sim-label input { transform: scale(1.5); margin-right: 5px; }
    </style>
</head>
<body>
<!-- ä¸»æ§ç•Œé¢ -->
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
    <h1 style="margin: 5px 0;">æ•´æœºæµ‹è¯• (4Gç‰ˆ)</h1>
    <div style="display: flex; align-items: center; gap: 10px;">
        <button class="btn" id="switchVerisonBtn" style="background: #28a745; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°WIFIç‰ˆ</button>
        <button class="btn" id="switchInterfaceBtn" style="background: #007bff; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<!-- è®¾å¤‡è¿æ¥é¢æ¿ -->
<div class="panel">
    <div class="grid">
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Aï¼ˆSERIAL-Aï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput1" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput1" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice1Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice1Btn">è¿æ¥</button>
                <div id="device1Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox1" checked> å·²æ’å¡</label>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Bï¼ˆSERIAL-Bï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput2" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput2" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice2Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice2Btn">è¿æ¥</button>
                <div id="device2Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox2" checked> å·²æ’å¡</label>
            </div>
        </div>
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Cï¼ˆSERIAL-Cï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput3" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput3" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice3Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice3Btn">è¿æ¥</button>
                <div id="device3Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox3" checked> å·²æ’å¡</label>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Dï¼ˆSERIAL-Dï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput4" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice4Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice4Btn">è¿æ¥</button>
                <div id="device4Msg"></div>
                <label class="sim-label"><input type="checkbox" id="simCardCheckbox4" checked> å·²æ’å¡</label>
            </div>
        </div>
    </div>
</div>

<!-- çŠ¶æ€æ˜¾ç¤º -->
 <div class="panel">
    <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin: 15px 0;">
        
        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-1" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Aæœªè¿æ¥</div>
            <div id="testResultDisplay-3" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Cæœªè¿æ¥</div>
        </div>

        <img id="deviceImage4" src="image.png" alt="è®¾å¤‡å›¾ç‰‡" style="width: 50%; border-radius: 8px; box-shadow: var(--shadow-sm);"> 

        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-2" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Bæœªè¿æ¥</div>
            <div id="testResultDisplay-4" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Dæœªè¿æ¥</div>
        </div>

    </div>
</div>
<!-- æµ‹è¯•ç»“æœè¡¨æ ¼ -->
<div class="panel">
    <div class="table-container">
        <table>
            <thead><tr><th>è®¾å¤‡å·</th><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
            <tbody id="wholeMachineResultBody"></tbody>
        </table>
    </div>
</div>

<!-- æ—¥å¿— -->
<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
    (function() {
        'use strict';
        const CONFIG = {
            AES: { KEY_STRING: "me%ov2Ied|eicegh", IV_STRING: "me%ov2Ied|eicegh" },
            URLS: { TEST: "http://gw.3wlink.cn:22011/?dgwkey=", REPORT: "https://daantest.free.beeceptor.com" },
            BAUD_RATE: 115200,
            TIMEOUTS: { COMMAND: 5000, RESPONSE: 2000, FETCH: 5000, REPORT: 10000, TEST_URL_WAIT: 10000 },
            AUTO_REPORT: true, DEVICE_COUNT: 4, RETRY_COUNT: 2, LOG_LIMIT: 100
        };

        const sleep = ms => new Promise(r => setTimeout(r, ms));
        const UI = {
            logBox: document.getElementById('logBox'),
            resultBody: document.getElementById('wholeMachineResultBody'),
            testResultDisplays: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => document.getElementById(`testResultDisplay-${i + 1}`)),
            devicePanels: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => ({
                selectBtn: document.getElementById(`selectDevice${i + 1}Btn`),
                connectBtn: document.getElementById(`connectDevice${i + 1}Btn`),
                msg: document.getElementById(`device${i + 1}Msg`),
                snInput: document.getElementById(`snInput${i + 1}`),
                simCheckbox: document.getElementById(`simCardCheckbox${i + 1}`)
            }))
        };

        const DgwCrypto = {
            _key: null, _iv: null,
            async init() {
                if (this._key) return;
                try {
                    const keyBytes = new TextEncoder().encode(CONFIG.AES.KEY_STRING);
                    this._iv = new TextEncoder().encode(CONFIG.AES.IV_STRING);
                    this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
                } catch (error) {
                    console.error("AES_CBCå¯†é’¥å¯¼å…¥å¤±è´¥:", error);
                    throw error;
                }
            },
            async encrypt(plainText) {
                if (!this._key) await this.init();
                try {
                    const textBytes = new TextEncoder().encode(plainText);
                    const blockSize = 16;
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    const paddedData = new Uint8Array(textBytes.length + (paddingNeeded === blockSize ? 0 : paddingNeeded));
                    paddedData.set(textBytes);
                    const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                    const truncated = new Uint8Array(encrypted).slice(0, paddedData.length);
                    return btoa(String.fromCharCode(...truncated)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                } catch (error) {
                    console.error('åŠ å¯†å¤±è´¥:', error);
                    return null;
                }
            }
        };

        class SerialManager {
            constructor(id) { this.id = id; this.port = null; this.reader = null; this.writer = null;
                this.connected = false; this.readLoopActive = false; }
            async select() { try { this.port = await navigator.serial.requestPort(); return true; } catch { return false; } }
            async connect() {
                if (!this.port) return false;
                try {
                    await this.port.open({ baudRate: CONFIG.BAUD_RATE });
                    this.writer = this.port.writable?.getWriter();
                    this.connected = true;
                    return true;
                } catch (e) { console.error(`è®¾å¤‡ ${this.id} è¿æ¥å¤±è´¥:`, e); return false; }
            }
            async disconnect() {
                await this.stopReadLoop();
                if (this.writer) { try { await this.writer.close(); } catch {} this.writer = null; }
                if (this.port?.readable) { try { await this.port.readable.cancel(); } catch {} }
                if (this.port) { try { await this.port.close(); } catch {} }
                this.connected = false;
            }
            async readLoop(onData) {
                if (!this.port?.readable || !this.connected) return;
                this.readLoopActive = true;
                try {
                    while (this.connected && this.readLoopActive) {
                        this.reader = this.port.readable.getReader();
                        const { value, done } = await this.reader.read();
                        this.reader.releaseLock();
                        this.reader = null;
                        if (done) break;
                        if (onData) onData(new TextDecoder().decode(value));
                    }
                } catch (e) {} finally { this.readLoopActive = false; }
            }
            async stopReadLoop() {
                this.readLoopActive = false;
                if (this.reader) try { await this.reader.cancel(); } catch {}
            }
            async send(data) {
                if (!this.writer) return;
                await this.writer.write(typeof data === 'string' ? new TextEncoder().encode(data) : data);
            }
            async enterFactory() { await this.send(new Uint8Array(8).fill(0xf8)); await sleep(50); }
        }

        class UIManager {
            constructor() { this.logMessages = []; this.deviceRows = new Map(); }
            initDeviceRows() {
                for (let i = 1; i <= CONFIG.DEVICE_COUNT; i++) {
                    const row = UI.resultBody.insertRow();
                    row.innerHTML = `<td>è®¾å¤‡${String.fromCharCode(64 + i)}</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>`;
                    this.deviceRows.set(i, row);
                }
            }
            log(msg) {
                this.logMessages.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
                if (this.logMessages.length > CONFIG.LOG_LIMIT) this.logMessages.shift();
                UI.logBox.textContent = this.logMessages.join('\n');
                UI.logBox.scrollTop = UI.logBox.scrollHeight;
            }
            updateDeviceMessage(id, text, type = 'info') {
                const el = UI.devicePanels[id - 1].msg;
                if (el) { el.textContent = text; el.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black'; }
            }
            updateButtons(devices) {
                devices.forEach((d, i) => {
                    const p = UI.devicePanels[i];
                    p.connectBtn.textContent = d.serial.connected ? 'æ–­å¼€' : 'è¿æ¥';
                    p.connectBtn.disabled = !d.serial.connected && !d.serial.port;
                    p.selectBtn.disabled = d.inProgress;
                    p.snInput.disabled = !d.serial.connected || d.inProgress;
                    p.snInput.placeholder = d.serial.connected ? 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...' : 'è¯·è¿æ¥è®¾å¤‡...';
                });
            }
            addOrUpdateTestResult(r) {
                const row = this.deviceRows.get(r.deviceId);
                if (!row) return;
                const setCell = (idx, text, cls) => { row.cells[idx].textContent = text; row.cells[idx].className = cls; };
                
                if (r.errorReason === 'SNä¸åŒ¹é…') {
                    setCell(1, r.timestamp, ''); setCell(2, r.sn || 'æœªçŸ¥', 'fail'); setCell(7, 'SNä¸åŒ¹é…', 'fail');
                    for(let k=3; k<7; k++) setCell(k, '-', '');
                    return;
                }
                setCell(1, r.timestamp, '');
                setCell(2, r.sn || 'å¼‚å¸¸', r.sn ? 'pass' : 'fail');
                setCell(3, r.imei || 'å¼‚å¸¸', r.imei ? 'pass' : 'fail');
                setCell(4, r.iccid || (r.isSim ? 'å¼‚å¸¸' : 'æœªæ’å¡'), (r.iccid && r.iccid!=='æœªæ’å¡') ? 'pass' : 'fail');
                
                const statusMap = { true: {t:'æ­£å¸¸',c:'pass'}, false: {t:'å¼‚å¸¸',c:'fail'}, pending: {t:'æ­£åœ¨æµ‹è¯•...',c:'testing'} };
                setCell(5, (statusMap[r.serial] || {t:'å¾…æµ‹è¯•',c:''}).t, (statusMap[r.serial] || {t:'',c:''}).c);
                
                const webSt = r.web === 'æœªæ’å¡' ? {t:'æœªæ’å¡',c:'fail'} : (statusMap[r.web] || {t:'å¾…æµ‹è¯•',c:''});
                setCell(6, webSt.t, webSt.c);

                const st = statusMap[r.status] || {t:'å¾…æµ‹è¯•',c:''};
                setCell(7, st.t, st.c);

                let rep = {t:'å¾…ä¸ŠæŠ¥', c:'testing'};
                if (r.skipReport || (r.status === false && !r.sn)) rep = {t:'æœªä¸ŠæŠ¥', c:'fail'};
                else if (r.reported) rep = {t:'å·²ä¸ŠæŠ¥', c:'pass'};
                else if (r.reportFailed) rep = {t:'æœªä¸ŠæŠ¥', c:'fail'};
                else if (r.status !== 'pending' && !CONFIG.AUTO_REPORT) rep = {t:'æœªä¸ŠæŠ¥', c: r.status===false?'fail':''};
                setCell(8, rep.t, rep.c);
            }
            clearTestResult(id) {
                const row = this.deviceRows.get(id);
                if (row) for(let i=1; i<9; i++) { row.cells[i].textContent = ''; row.cells[i].className = ''; }
            }
            showTestResult(id, state, msg = null) {
                const d = UI.testResultDisplays[id-1];
                if (!d) return;
                const m = {
                    waiting: [`â³ è®¾å¤‡${String.fromCharCode(64+id)}æµ‹è¯•ä¸­...`, 'waiting'],
                    pass: [`âœ… è®¾å¤‡${String.fromCharCode(64+id)}-é€šè¿‡`, 'pass'],
                    fail: [`âŒ è®¾å¤‡${String.fromCharCode(64+id)}-ä¸é€šè¿‡`, 'fail'],
                    'no-device': [`âŒ è®¾å¤‡${String.fromCharCode(64+id)}-æœªæ’å…¥`, 'fail'],
                    connected: [`ç«¯å£${String.fromCharCode(64+id)}å·²è¿æ¥`, 'default'],
                    disconnected: [`ç«¯å£${String.fromCharCode(64+id)}æœªè¿æ¥`, 'default']
                };
                const [t, c] = m[state] || m.disconnected;
                d.textContent = msg || t; d.className = `test-result-display ${c}`;
            }
        }

        class App {
            constructor(ui) { this.uiManager = ui;
                this.devices = Array.from({length:CONFIG.DEVICE_COUNT}, (_,i)=>({id:i+1, serial:new SerialManager(i+1), inProgress:false, record:null}));
                this.testRunner = new TestRunner(this.uiManager); }
            async init() {
                try { await DgwCrypto.init(); } catch { return alert('åŠ å¯†æ¨¡å—å¤±è´¥'), this.uiManager.log('âŒ åŠ å¯†å¤±è´¥'); }
                this.uiManager.initDeviceRows();
                this.setupEvents();
                await this.loadPorts();
                this.uiManager.updateButtons(this.devices);
                this.uiManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
            }
            setupEvents() {
                this.devices.forEach(d => {
                    const p = UI.devicePanels[d.id-1];
                    p.selectBtn.onclick = () => this.selectPort(d.id);
                    p.connectBtn.onclick = () => this.toggleConn(d.id);
                    p.snInput.addEventListener('keydown', e => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.startTest(d.id);
                        }
                    });
                });
                document.getElementById('switchInterfaceBtn').onclick = () => location.href = `index.html?v=${Date.now()}`;
                document.getElementById('switchVerisonBtn').onclick = () => location.href = `complete_machine_wifi.html?v=${Date.now()}`;
            }
            async startTest(id) {
                const d = this.devices[id-1], sn = UI.devicePanels[id-1].snInput.value.trim();
                const isSim = UI.devicePanels[id-1].simCheckbox.checked;
                if (d.inProgress || !d.serial.connected) return;
                if (sn.length !== 20) return this.uiManager.updateDeviceMessage(id, 'âŒ SNé”™è¯¯', 'error');
                this.uiManager.updateDeviceMessage(id, 'âœ… å·²è¿æ¥', 'success');
                this.testRunner.run(d, this, sn, isSim);
            }
            async loadPorts() {
                const ports = await navigator.serial.getPorts();
                this.devices.forEach(d => {
                    const idx = localStorage.getItem(`serialPort_device_${d.id}`);
                    if (idx && ports[idx]) { d.serial.port = ports[idx]; this.uiManager.updateDeviceMessage(d.id, 'âœ… ä¸²å£å·²åŠ è½½'); }
                });
            }
            async selectPort(id) {
                const d = this.devices[id-1];
                if (await d.serial.select()) {
                    this.uiManager.updateDeviceMessage(id, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
                    const ports = await navigator.serial.getPorts();
                    const idx = ports.indexOf(d.serial.port);
                    if (idx > -1) localStorage.setItem(`serialPort_device_${id}`, idx);
                }
                this.uiManager.updateButtons(this.devices);
            }
            async toggleConn(id) {
                const d = this.devices[id-1];
                if (d.serial.connected) {
                    if (d.inProgress) { this.testRunner.cancel(d); this.uiManager.log(`ğŸ›‘ è®¾å¤‡ ${d.id}: ç”¨æˆ·æ‰‹åŠ¨æ–­å¼€ï¼Œæµ‹è¯•å·²ä¸­æ–­`); }
                    await d.serial.disconnect();
                    this.uiManager.updateDeviceMessage(id, 'â„¹ï¸ å·²æ–­å¼€');
                    UI.devicePanels[d.id-1].snInput.value = '';
                    d.record = null; this.uiManager.showTestResult(id, 'disconnected'); this.uiManager.clearTestResult(id);
                } else {
                    this.uiManager.updateDeviceMessage(id, 'âŒ› è¿æ¥ä¸­...');
                    if (await d.serial.connect()) {
                        this.uiManager.updateDeviceMessage(id, 'âœ… å·²è¿æ¥', 'success');
                        this.uiManager.showTestResult(id, 'connected');
                    } else this.uiManager.updateDeviceMessage(id, 'âŒ è¿æ¥å¤±è´¥', 'error');
                }
                this.uiManager.updateButtons(this.devices);
            }
        }

        class TestRunner {
            constructor(ui) { this.uiManager = ui; }
            cancel(d) {
                d.inProgress = false;
                if (d.record) this.uiManager.clearTestResult(d.id);
                d.record = null;
            }
            async run(d, app, sn, isSim) {
                this.uiManager.clearTestResult(d.id);
                d.record = null; d.inProgress = true; d.enteredSn = sn; d.isSim = isSim;
                this.uiManager.showTestResult(d.id, 'waiting');
                this.uiManager.updateButtons(app.devices);

                await sleep(CONFIG.TIMEOUTS.COMMAND);
                if (!d.inProgress) return;

                // Step 1: Info (DSN, ICC, IME)
                this.uiManager.log(`è®¾å¤‡ ${d.id}: è·å–è®¾å¤‡ä¿¡æ¯...`);
                let buf = '', gotInfo = false;
                d.serial.readLoop(t => { 
                    if (!gotInfo) { 
                        buf += t; 
                        if (buf.includes('<1,DSN;') && buf.includes('<1,ICC;') && buf.includes('<1,IME;')) gotInfo = true; 
                    }
                });
                
                for(let i=0; i<=CONFIG.RETRY_COUNT && !gotInfo; i++) {
                    if (!d.inProgress) return;
                    if (i===0) await d.serial.enterFactory();
                    if (i>0) { this.uiManager.log(`è®¾å¤‡ ${d.id}: è·å–ä¿¡æ¯é‡è¯•...`); }
                    await d.serial.send('<1,DSN,ICC,IME>');
                    await sleep(CONFIG.TIMEOUTS.RESPONSE);
                }
                await d.serial.stopReadLoop();
                if (!d.inProgress) return;

                if (!gotInfo) return this.finish(d, {sn:null, serial:false, web:false, status:false}, app);

                const devSn = buf.match(/<1,DSN;([^>]+)>/)?.[1]?.trim();
                const iccid = buf.match(/<1,ICC;([^>]*)>/)?.[1]?.trim() || '';
                const imei = buf.match(/<1,IME;([^>]+)>/)?.[1]?.trim();

                if (devSn !== sn) return this.finish(d, {sn:devSn, serial:true, status:false, errorReason:'SNä¸åŒ¹é…', skipReport:true}, app);
                if (!devSn || !imei) return this.finish(d, {sn:null, serial:true, status:false, skipReport:true}, app);

                this.uiManager.log(`âœ… è®¾å¤‡ ${d.id}: SN:${devSn} IMEI:${imei} ICCID:${iccid}`);
                d.record = { deviceId:d.id, timestamp:new Date().toLocaleString(), sn:devSn, imei, iccid, isSim, serial:true, web:'pending', status:'pending' };
                this.uiManager.addOrUpdateTestResult(d.record);

                // SIM & Web Check
                if (isSim) {
                    if (!iccid) {
                        this.uiManager.log(`âŒ è®¾å¤‡ ${d.id}: æœªè¯»åˆ°ICCID`);
                        return this.finish(d, {web:false, status:false}, app);
                    }
                    this.uiManager.log(`ğŸ”— è®¾å¤‡ ${d.id}: æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...`);
                    const url = await this._genUrl(d.record.sn);
                    let web = false;
                    await sleep(CONFIG.TIMEOUTS.TEST_URL_WAIT); 
                    
                    if (url) {
                        this.uiManager.log(`ğŸŒ è®¾å¤‡ ${d.id}: æµ‹è¯•ç½‘å€: ${url}`);
                        for(let i=0; i<=CONFIG.RETRY_COUNT && !web; i++) {
                            if (!d.inProgress) return;
                            try {
                                const res = await fetch(`https://cors.lorens.qzz.io/?url=${encodeURIComponent(url)}`, {signal:AbortSignal.timeout(CONFIG.TIMEOUTS.FETCH), mode:'cors', cache:'no-cache'});
                                if (res.ok) { this.uiManager.log(`âœ… è®¾å¤‡ ${d.id}: ç½‘ç»œè®¿é—®æˆåŠŸ`); web = true; }
                                else throw 1;
                            } catch {
                                 this.uiManager.log(`âŒ è®¾å¤‡ ${d.id}: ç½‘ç»œè®¿é—®å¤±è´¥`);
                                 if(i<CONFIG.RETRY_COUNT) await sleep(1000); 
                            }
                        }
                    }
                    if (!d.inProgress) return;
                    this.finish(d, {web, status:web}, app);
                } else {
                    this.uiManager.log(`â„¹ï¸ è®¾å¤‡ ${d.id}: è·³è¿‡ç½‘ç»œæµ‹è¯• (æœªæ’å¡)`);
                    this.finish(d, {web:'æœªæ’å¡', iccid:'æœªæ’å¡', status:true}, app);
                }
            }
            async finish(d, res, app) {
                d.inProgress = false;
                const base = { deviceId: d.id, timestamp: new Date().toLocaleString(), sn:null, imei:null, iccid:null, serial:false, web:false, status:false };
                d.record = { ...base, ...d.record, ...res };
                this.uiManager.addOrUpdateTestResult(d.record);
                
                const ok = d.record.status === true;
                const noDev = !d.record.sn;
                this.uiManager.showTestResult(d.id, ok ? 'pass' : (noDev ? 'no-device' : 'fail'), res.errorReason);
                this.uiManager.updateButtons(app.devices);
                this.uiManager.log(`ğŸ“Š è®¾å¤‡ ${d.id}: æµ‹è¯•å®Œæˆ - ${ok?'é€šè¿‡':'å¤±è´¥'}`);
                
                if (CONFIG.AUTO_REPORT && !d.record.skipReport) await this.report(d.record);
                try { await d.serial.enterFactory(); } catch {} 
                UI.devicePanels[d.id-1].snInput.value = '';
            }
            async report(r) {
                if (!r.sn) return;
                this.uiManager.log(`ğŸ“® è®¾å¤‡ ${r.sn}: æ­£åœ¨ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...`);
                try {
                    const res = await fetch(CONFIG.URLS.REPORT, {
                        method: 'POST', headers: {'Content-Type':'application/json', 'User-Agent': 'DGS-100-Tester/1.0'},
                        body: JSON.stringify({ deviceId:'DGS-100', results:[{sn:r.sn, imei:r.imei, iccid:r.iccid==='æœªæ’å¡'?'fail':(r.iccid||'fail'), serialTest:r.serial?'pass':'fail', webTest:r.web===true?'pass':'fail', overallStatus:r.status?'pass':'fail'}] }),
                        signal: AbortSignal.timeout(CONFIG.TIMEOUTS.REPORT)
                    });
                    if (res.ok) { r.reported = true; this.uiManager.log(`âœ… è®¾å¤‡ ${r.sn}: ä¸ŠæŠ¥æˆåŠŸ`); } else throw 1; 
                } catch (e) { r.reportFailed = true; this.uiManager.log(`âŒ è®¾å¤‡ ${r.sn}: ç»“æœä¸ŠæŠ¥å¤±è´¥: ${e.message||''}`); } 
                this.uiManager.addOrUpdateTestResult(r);
            }
            async _genUrl(sn) { const e = await DgwCrypto.encrypt("DAAN"+sn); return e ? `${CONFIG.URLS.TEST}${e}` : null; }
        }

        if ('serial' in navigator) new App(new UIManager()).init();
        else alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚');
    })();
</script>
</body>
</html>