<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 å•æ¿æµ‹è¯• (WiFiç‰ˆ)</title>
    <style>
        body { font-family: system-ui, -apple-system, Roboto, sans-serif; padding: 5px 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .status-reporting { color: #ffc107; }
        .status-report-success { color: #28a745; }
        .status-report-failed { color: #dc3545; }
        .flex { display: flex; gap: 15px; flex-wrap: wrap; }
        .flex > div { flex: 1; min-width: 280px; }
        .status-item { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .status-item span:first-child { color: #555; }
        .status-value { font-weight: 600; }
        .status-ready, .status-on { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 15px 0; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background: #f8f9fa; color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: #28a745; }
        .fail { background: #f8d7da; color: #dc3545; }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 150px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        #testResultDisplay { margin: 15px 0; padding: 20px; border-radius: 8px; text-align: center; font-size: 30px; font-weight: bold; box-shadow: 0 3px 6px rgba(0,0,0,0.1); display: none;}
        #testResultDisplay.pass { background: linear-gradient(135deg, #28a745, #20c997); color: white; border: 2px solid #1e7e34; } 
        #testResultDisplay.fail { background: linear-gradient(135deg, #dc3545, #ff6b6b); color: white; border: 2px solid #bd2130; }
        #testResultDisplay.waiting { background: linear-gradient(135deg, #007bff, #3da9fc); color: white; border: 2px solid #0056b3; display: block; }
        input[type="text"] { width: 180px; padding: 6px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px; }
        #scanInput {flex-grow: 1; max-width: 340px; padding: 15px; font-size: 1.9em; border: 2px solid #ccc; border-radius: 4px; transition: border-color 0.2s, box-shadow 0.2s;}
        #scanInput:focus { border-color: #007bff; box-shadow: 0 0 8px rgba(0, 123, 255, 0.3); outline: none; }
        #snLabel { font-size: 3em; font-weight: 800; }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
    <h1 style="margin: 5px 0;">å•æ¿æµ‹è¯• (WiFiç‰ˆ)</h1>
    <div style="display: flex; align-items: center; gap: 10px;">
        <button class="btn" id="switchVerisonBtn" style="background: #007bff; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°4Gç‰ˆ</button>
        <button class="btn" id="switchInterfaceBtn" style="background: #28a745; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°æ•´æœºæµ‹è¯•</button>
    </div>
</div>

<div class="panel">
    <div class="flex">
        <div class="panel panel-green">
            <h2>é…ç½®æµ‹è¯•æ¶ï¼ˆSERIAL-Dï¼‰</h2>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="selectStatusBtn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="toggleStatusBtn">è¿æ¥</button>
                <button class="btn" id="calBtn">é‡‡æ ·æ ¡å‡†</button>
                <div id="statusMsg"></div>
            </div>
        </div>
        <div class="panel panel-blue" style="flex: 0.85; min-width: 250px;">
            <h2>é…ç½®æ•°æ®æ£’ï¼ˆSERIAL-Aï¼‰</h2>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="selectTestBtn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="toggleTestBtn">è¿æ¥</button>
                
                <div id="testMsg"></div>
            </div>
        </div>
        <div class="panel panel-green" style="flex: 1.15;">
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <label for="scanInput" id="snLabel">SN:</label>
                    <input type="text" id="scanInput" placeholder="è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...">
                    <div id="snMsg"></div>
                </div>
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <button class="btn" id="scanWifiBtn">æ‰«æWiFi</button>
                    <select id="wifiList" style="padding: 6px; width: 160px; border: 1px solid #ddd; border-radius: 3px; height: 32px;">
                        <option value="">è¯·æ‰«æWiFi...</option>
                    </select>
                    <input type="text" id="wifiPass" placeholder="WiFiå¯†ç " style="width: 120px; padding: 6px; border: 1px solid #ddd; border-radius: 3px;">
                    <button class="btn" id="connectWifiBtn">è¿æ¥WiFi</button>
                    <div id="wifiMsg"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="testResultDisplay">ç­‰å¾…æµ‹è¯•...</div>

<div class="panel">
    <table>
        <thead>
            <tr><th>æ—¶é—´</th><th>SN</th><th>WIFI</th><th>ä¸²å£é€šä¿¡</th><th>å·¥ä½œç”µå‹</th><th>å·¥ä½œç”µæµ</th><th>DCDC</th><th>ç½‘ç»œä¾›ç”µ</th><th>MCUä¾›ç”µ</th><th>ç”µæºç¯</th><th>ä¸²å£ç¯</th><th>ç½‘ç»œç¯</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr>
        </thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
const config = {
    aes: { keyString: "me%ov2Ied|eicegh", ivString: "me%ov2Ied|eicegh" },
    urls: { test: "http://gw.3wlink.cn:22011/?dgwkey=", report: "https://daantest.free.beeceptor.com" },
    baudRates: { status: 115200, test: 10000000 },
    timeouts: { dsn: 3000, rst: 15000, led: 2000, fetch: 5000, report: 10000 },
    sampling: { count: 4, interval: 500 },
    autoReport: true,
    maxRetries: 3
};

const ui = {
    selectStatusBtn: document.getElementById('selectStatusBtn'),
    toggleStatusBtn: document.getElementById('toggleStatusBtn'),
    calBtn: document.getElementById('calBtn'),
    statusMsg: document.getElementById('statusMsg'),
    selectTestBtn: document.getElementById('selectTestBtn'),
    toggleTestBtn: document.getElementById('toggleTestBtn'),
    scanInput: document.getElementById('scanInput'),
    testMsg: document.getElementById('testMsg'),
    snMsg: document.getElementById('snMsg'),
    resultBody: document.getElementById('resultBody'),
    logBox: document.getElementById('logBox'),
    testResultDisplay: document.getElementById('testResultDisplay'),
    wifiList: document.getElementById('wifiList'),
    wifiPass: document.getElementById('wifiPass'),
    scanWifiBtn: document.getElementById('scanWifiBtn'),
    connectWifiBtn: document.getElementById('connectWifiBtn'),
    snMsg: document.getElementById('snMsg'),
    wifiMsg: document.getElementById('wifiMsg')
};

const DgwCrypto = {
    _key: null, _iv: null,
    async init() {
        if (this._key) return;
        try {
            const keyBytes = new TextEncoder().encode(config.aes.keyString);
            this._iv = new TextEncoder().encode(config.aes.ivString);
            this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
        } catch (error) {
            console.error(":", error);
            throw error;
        }
    },
    async encrypt(plainText) {
        if (!this._key) { await this.init(); }
        try {
            const textBytes = new TextEncoder().encode(plainText);
            const blockSize = 16;
            let paddedData;
            if (textBytes.length % blockSize === 0) {
                paddedData = new Uint8Array(textBytes);
            } else {
                const paddingNeeded = blockSize - (textBytes.length % blockSize);
                paddedData = new Uint8Array(textBytes.length + paddingNeeded);
                paddedData.set(textBytes);
            }
            const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
            const encryptedArray = new Uint8Array(encrypted);
            const truncated = encryptedArray.slice(0, paddedData.length);
            const base64 = btoa(String.fromCharCode(...truncated));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        } catch (error) {
            console.error('åŠ å¯†å¤±è´¥:', error);
            return null;
        }
    }
};

const encoder = new TextEncoder();
const decoder = new TextDecoder();

const STATUS_MAP = { true: {t:'æ­£å¸¸',c:'pass'}, false: {t:'å¼‚å¸¸',c:'fail'}, '-': {t:'-',c:''}, 'pending': {t:'å¾…æµ‹è¯•',c:''} };
const COMP_TESTS = [
    { k: 'vout', n: 'å·¥ä½œç”µå‹', l: 4.8, h: 5.1, u: 'V' },
    { k: 'iout', n: 'å·¥ä½œç”µæµ', l: 50, h: 200, u: 'mA' },
    { k: 'ai0', n: 'DCDCä¾›ç”µ', l: 3100, h: 3500, u: 'mV' },
    { k: 'ai1', n: 'ç½‘ç»œä¾›ç”µ', l: 3100, h: 3500, u: 'mV' },
    { k: 'ai2', n: 'MCUä¾›ç”µ', l: 3100, h: 3500, u: 'mV' }
];
const LED_TESTS = [
    { c: 'ccmd LED;6;0\r\n', k: 'powerLight', n: 'ç”µæºæŒ‡ç¤ºç¯', th: 20, d: 1 },
    { c: 'ccmd LED;3;1\r\n', k: 'rs485Light', n: '485æŒ‡ç¤ºç¯', th: 20, d: 2 },
    { c: 'ccmd LED;4;1\r\n', k: 'networkLight', n: 'ç½‘ç»œæŒ‡ç¤ºç¯', th: 20, d: 3 }
];

class SerialManager {
    constructor(type) {
        this.type = type; this.port = null; this.reader = null; this.writer = null;
        this.connected = false; this.reading = false; this.buffer = '';
    }
    async select() {
        return navigator.serial.requestPort().then(p => { this.port = p; return true; }).catch(() => false);
    }
    async connect(baudRate) {
        if (!this.port) return false;
        try {
            await this.port.open({ baudRate });
            if (baudRate >= 1000000) await new Promise(r => setTimeout(r, 500));
            this.writer = this.port.writable?.getWriter();
            this.connected = true;
            return true;
        } catch (e) { console.error(`${this.type} connect fail:`, e); return false; }
    }
    async disconnect() {
        await this.stopRead();
        if (this.writer) { try { await this.writer.close(); } catch {} this.writer = null; }
        if (this.port) { try { await this.port.close(); } catch {} }
        this.connected = false; this.buffer = '';
    }
    async write(data, chunkDelay = 0) {
        if (!this.writer) return false;
        try {
            const enc = typeof data === 'string' ? encoder.encode(data) : data;
            if (chunkDelay > 0) {
                for (let i = 0; i < enc.length; i += 16) {
                    await this.writer.write(enc.slice(i, i + 16));
                    await new Promise(r => setTimeout(r, chunkDelay));
                }
            } else await this.writer.write(enc);
            return true;
        } catch (e) { console.error('Write error:', e); return false; }
    }
    async readLoop(onData, onError) {
        if (!this.port?.readable || !this.connected) return;
        this.reading = true;
        this.reader = this.port.readable.getReader();
        try {
            while (this.reading) {
                const { value, done } = await this.reader.read();
                if (done) break;
                if (onData) onData(decoder.decode(value));
            }
        } catch (e) { if (this.reading && onError) onError(e); }
        finally { if (this.reader) { this.reader.releaseLock(); this.reader = null; } this.reading = false; }
    }
    async stopRead() {
        this.reading = false;
        try { await this.reader?.cancel(); } catch {}
    }
}

const UIManager = {
    init(appState) { this.state = appState; },
    log(msg) {
        ui.logBox.textContent += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
        ui.logBox.scrollTop = ui.logBox.scrollHeight;
    },
    clearLog() { ui.logBox.textContent = 'æµ‹è¯•æ—¥å¿—...'; },
    update(id, text, type = 'info') {
        const el = ui[id];
        if (el) {
            el.textContent = text;
            el.style.color = type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : '#333';
        }
    },
    updateButtons(app) {
        const st = app.serial.status, ts = app.serial.test;
        const d = this.state.device;
        ui.toggleStatusBtn.textContent = st.connected ? 'æ–­å¼€' : 'è¿æ¥';
        ui.toggleStatusBtn.disabled = !st.port && !st.connected;
        ui.toggleTestBtn.textContent = ts.connected ? 'æ–­å¼€' : 'è¿æ¥';
        ui.toggleTestBtn.disabled = !ts.port && !ts.connected;
        ui.selectTestBtn.disabled = this.state.test.inProgress;
        
        if (st.connected && !d.calibrated) {
            ui.scanInput.disabled = true; ui.scanInput.placeholder = 'è¯·è¿›è¡Œé‡‡æ ·æ ¡å‡†';
        } else {
            const ready = d.ready && ts.connected && app.state.wifiConnected;
            ui.scanInput.disabled = this.state.test.inProgress || !ready;
            ui.scanInput.placeholder = !ts.connected ? 'è¯·é…ç½®æ•°æ®æ£’...' : !app.state.wifiConnected ? 'è¯·è¿æ¥WiFi...' : !d.ready ? 'æœªå°±ç»ªï¼Œè¯·é…ç½®æµ‹è¯•æ¶...' : 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...';
        }
        ui.scanWifiBtn.disabled = !ts.connected || this.state.test.inProgress || !d.ready;
        ui.connectWifiBtn.disabled = !ts.connected || this.state.test.inProgress || !d.ready;
    },
    addOrUpdateTestResult(record) {
        if (!record.row) return;
        const getS = v => STATUS_MAP[v] || STATUS_MAP.pending;
        const cols = [
            { text: new Date(record.timestamp).toLocaleString() },
            { text: record.sn, className: record.snMismatch ? 'fail' : record.snMatch ? 'pass' : '' },
            getS(record.wifi), getS(record.serial), getS(record.vout), getS(record.iout), getS(record.ai0), getS(record.ai1),
            getS(record.ai2), getS(record.powerLight), getS(record.rs485Light), getS(record.networkLight), getS(record.web),
            record.status === 'pending' ? { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' } : getS(record.status),
            record.reportFailed ? { text: 'æœªä¸ŠæŠ¥', className: 'fail' } : record.reported ? { text: 'å·²ä¸ŠæŠ¥', className: 'pass' } : { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' }
        ];
        cols.forEach((d, i) => {
            const c = record.row.cells[i];
            if (c) { c.textContent = d.t || d.text; c.className = d.c || d.className || ''; }
        });
    },
    showTestResult(passed) {
        const d = ui.testResultDisplay;
        d.style.display = 'block';
        d.className = passed === 'waiting' ? 'waiting' : passed ? 'pass' : 'fail';
        d.textContent = passed === 'waiting' ? 'â³ æ­£åœ¨æµ‹è¯•...' : passed ? 'âœ… é€šè¿‡' : 'âŒ ä¸é€šè¿‡';
    }
};

const RecordManager = {
    init(records, uiManager) { this.records = records; this.uiManager = uiManager; },
    createOrUpdate(res) {
        let r = res.isNewTest ? null : this.records.find(x => x.sn === res.sn);
        if (res.isNewTest) {
            ui.resultBody.innerHTML = '';
            this.records.length = 0;
            r = { sn: res.sn, row: ui.resultBody.insertRow(0), timestamp: Date.now(), status: 'pending', reported: false };
            this.records.push(r);
            for(let i=0; i<15; i++) r.row.insertCell(); 
            ['wifi','serial','vout','iout','ai0','ai1','ai2','powerLight','rs485Light','networkLight','web'].forEach(k => r[k] = 'pending');
        }
        if (!r) return null;
        Object.assign(r, res);
        this.uiManager.addOrUpdateTestResult(r);
        return r;
    },
    async report(failItem) {
        if (!this.records.length) return this.uiManager.log('âš ï¸ æ— ç»“æœå¯ä¸ŠæŠ¥');
        this.uiManager.log('ğŸ“® ä¸ŠæŠ¥ç»“æœ...');
        try {
            const list = this.records.filter(r => r.status !== 'pending' && !r.reported);
            const data = {
                deviceId: 'DGS-100',
                results: list.map(r => {
                    const p = { sn: r.sn }; 
                    if (failItem.length) p.failureItems = failItem[0];
                    else {
                        p.serialTest = r.serial === true ? 'pass' : 'fail';
                        p.webTest = r.web === true ? 'pass' : 'fail';
                        p.overallStatus = r.status === true ? 'pass' : 'fail';
                    }
                    return p;
                })
            };
            const resp = await fetch(config.urls.report, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                body: JSON.stringify(data),
                signal: AbortSignal.timeout(config.timeouts.report)
            });
            if (!resp.ok) throw new Error(`${resp.status}`);
            this.uiManager.log(`âœ… ä¸ŠæŠ¥æˆåŠŸ`);
            list.forEach(r => this.createOrUpdate({ sn: r.sn, reported: true, reportFailed: false }));
        } catch (e) {
            this.uiManager.log(`âŒ ä¸ŠæŠ¥å¤±è´¥: ${e.message}`);
            this.records.filter(r => r.status !== 'pending' && !r.reported).forEach(r => this.createOrUpdate({ sn: r.sn, reportFailed: true }));
        }
    }
};

const WifiController = {
    scannedNetworks: [],
    async scan(app) {
        const sm = app.serial.test;
        if (!sm.connected) return UIManager.update('wifiMsg', 'è¯·è¿æ¥æ•°æ®æ£’ä¸²å£', 'error');
        if (app.state.test.inProgress) return UIManager.update('wifiMsg', 'æµ‹è¯•è¿›è¡Œä¸­ï¼Œè¯·ç¨å', 'error');
        if (!app.state.device.ready) return UIManager.update('wifiMsg', 'è®¾å¤‡æœªå°±ç»ª', 'error');

        UIManager.update('wifiMsg', 'æ­£åœ¨æ‰«æ...', 'info');
        ui.wifiList.innerHTML = '<option value="">æ‰«æä¸­...</option>';
        this.scannedNetworks = [];
        
        await sm.stopRead();
        sm.buffer = ''; 
        const ssidRx = /ssid\s*=\s*(.*?)\s+rssi/;
        const bssidRx = /bssid\s*=\s*([0-9A-Fa-f]+)/;

        sm.readLoop(text => {
            sm.buffer += text;
            const lines = sm.buffer.split(/[\n]+/);
            if (lines.length > 1) {
                sm.buffer = lines.pop(); 
                for (const l of lines.map(x=>x.trim()).filter(x=>x)) {
                    const m = l.match(ssidRx); 
                    const b = l.match(bssidRx); 
                    if (m && b && !this.scannedNetworks.find(n => n.ssid === m[1].trim())) {
                        this.scannedNetworks.push({ ssid: m[1].trim(), bssid: b[1].trim() });
                    }
                    if (l.includes('æ‰«æç»“æŸ')) {
                         sm.stopRead();
                         this.updateSelect();
                         UIManager.update('wifiMsg', 'æ‰«æå®Œæˆ', 'success');
                         sm.buffer = ''; 
                    }
                }
            }
        }, e => UIManager.log(`WiFi Scan Error: ${e}`));
        await sm.write('ccmd SCN\r\n');
    },
    
    updateSelect() {
         ui.wifiList.innerHTML = '';
         if (this.scannedNetworks.length === 0) {
             ui.wifiList.innerHTML = '<option value="">æœªæ‰¾åˆ°WiFi</option>';
         }
         this.scannedNetworks.forEach(n => {
             const opt = document.createElement('option');
             opt.value = n.ssid; opt.textContent = n.ssid; opt.dataset.bssid = n.bssid;
             ui.wifiList.appendChild(opt);
         });
    },
    
    checkStatus(buf, cfgStr) {
        if (buf.includes('[I] WiFiè¿æ¥æˆåŠŸ')) return 'success';
        if (buf.includes('[W] WiFi å¯†ç é”™è¯¯')) return 'password_error';
        if (buf.includes('[I] wifiè¿æ¥å¤±è´¥')) return 'failed';
        if (cfgStr && buf.split(/\r?\n/).some(line => line.includes(cfgStr) && !line.includes('ccmd'))) return 'success';
        return null;
    },

    async connect(app) {
        const sm = app.serial.test;
        if (app.state.test.inProgress) return UIManager.update('wifiMsg', 'æµ‹è¯•è¿›è¡Œä¸­ï¼Œè¯·ç¨å', 'error');
        if (!app.state.device.ready) return UIManager.update('wifiMsg', 'è®¾å¤‡æœªå°±ç»ª', 'error');
        
        const ssid = ui.wifiList.value;
        const pass = ui.wifiPass.value;
        const bssid = ui.wifiList.options[ui.wifiList.selectedIndex]?.dataset.bssid;
        
        if (!ssid || !bssid) return UIManager.update('wifiMsg', 'è¯·é€‰æ‹©WiFi', 'error');
        if (!sm.connected) return UIManager.update('wifiMsg', 'è¯·è¿æ¥æ•°æ®æ£’ä¸²å£', 'error');
        
        UIManager.update('wifiMsg', 'æ­£åœ¨è¿æ¥...', 'info');
        await sm.stopRead();
        
        const configStr = `WFI;${ssid};${pass};${bssid};1`;
        const cmd = `ccmd ${configStr}\r\n`;
        UIManager.log(`ğŸ“¤ å‘é€ WiFiè¿æ¥å‘½ä»¤: ${cmd.trim()}`); 
        
        sm.buffer = '';
        sm.readLoop(text => {
             sm.buffer += text;
             const status = this.checkStatus(sm.buffer, configStr);
             if (status) {
                 const msgs = { success: 'âœ… WiFiå·²è¿æ¥', password_error: 'âŒ WiFiå¯†ç é”™è¯¯', failed: 'âŒ WiFiè¿æ¥å¤±è´¥' };
                 UIManager.update('wifiMsg', msgs[status], status === 'success' ? 'success' : 'error');
                 UIManager.log(msgs[status]);
                 sm.stopRead();
                 if (status === 'success') {
                     app.state.wifiConnected = true;
                     UIManager.updateButtons(app);
                     setTimeout(() => ui.scanInput.focus(), 100);
                 }
             }
        }, e => UIManager.log(`WiFi Connect Error: ${e}`));
        
        await sm.write(cmd, 50);
    }
};

const app = {
    state: { 
        reporting: false, 
        test: { inProgress: false, currentSN: '', currentStep: '', stepTimeouts: {}, stepRetryCount: {}, skipWebTest: false, hasFailure: false, failureItems: [] }, 
        device: { ready: false, status: null, colorR: 0, calibrated: false },
        wifiConnected: false
    },
    serial: { status: new SerialManager('status'), test: new SerialManager('test') },
    records: [],
    async init() {
        UIManager.init(this.state);
        RecordManager.init(this.records, UIManager);
        try { await DgwCrypto.init(); } catch { return alert('åŠ å¯†åˆå§‹åŒ–å¤±è´¥'), UIManager.log('âŒ Encrypt Fail'); }
        this.setupEvents();
        await this.loadPorts();
        UIManager.updateButtons(this);
        UIManager.log('åˆå§‹åŒ–å®Œæˆï¼Œè¯·è¿æ¥ä¸²å£ã€‚');
    },
    setupEvents() {
        const bind = (el, fn) => el && el.addEventListener('click', fn);
        bind(ui.selectStatusBtn, () => this.selectPort('status'));
        bind(ui.toggleStatusBtn, () => this.toggleConn('status'));
        bind(ui.selectTestBtn, () => this.selectPort('test'));
        bind(ui.toggleTestBtn, () => this.toggleConn('test'));
        bind(ui.calBtn, () => this.runCalibration());
        bind(ui.scanWifiBtn, () => WifiController.scan(this));
        bind(ui.connectWifiBtn, () => WifiController.connect(this));
        document.getElementById('switchInterfaceBtn').addEventListener('click', () => window.location.href = `complete_machine_wifi.html?v=${Date.now()}`);
        document.getElementById('switchVerisonBtn').addEventListener('click', () => window.location.href = `index.html?v=${Date.now()}`);

        ui.scanInput.addEventListener('keypress', e => {
            if (e.key !== 'Enter') return;
            e.preventDefault();
            const v = ui.scanInput.value.trim();
            if (this.state.test.inProgress) return UIManager.log('âš ï¸ æµ‹è¯•è¿›è¡Œä¸­');
            if (!v || v.length !== 20) return UIManager.update('snMsg', 'âŒ SNé”™è¯¯', 'error');
            UIManager.update('testMsg', 'âœ… è®¾å¤‡å·²å°±ç»ª', 'info');
            TestRunner.startTest(v, this);
        });
        ui.scanInput.addEventListener('blur', () => !this.state.test.inProgress && !ui.scanInput.disabled && setTimeout(() => ui.scanInput.focus(), 100));
    },
    async loadPorts() {
        const ports = await navigator.serial.getPorts().catch(()=>[]);
        ['status', 'test'].forEach(t => {
            const idx = localStorage.getItem(`serialPort_${t}`);
            if (idx !== null && ports[idx]) { 
                this.serial[t].port = ports[idx]; 
                UIManager.update(`${t}Msg`, 'âœ… ä¸²å£å·²åŠ è½½'); 
            }
        });
    },
    async selectPort(type) {
        if (await this.serial[type].select()) {
            UIManager.update(`${type}Msg`, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
            const ports = await navigator.serial.getPorts();
            localStorage.setItem(`serialPort_${type}`, ports.indexOf(this.serial[type].port));
        }
        UIManager.updateButtons(this);
    },
    async toggleConn(type) {
        const m = this.serial[type];
        if (m.connected) {
            await m.disconnect();
            UIManager.update(`${type}Msg`, 'â„¹ï¸ å·²æ–­å¼€');
            if (type === 'status') this.state.device.ready = false;
            if (type === 'test') this.state.wifiConnected = false;
        } else {
            UIManager.update(`${type}Msg`, 'âŒ› è¿æ¥ä¸­...');
            if (await m.connect(config.baudRates[type])) {
                UIManager.update(`${type}Msg`, 'âœ… å·²è¿æ¥', 'success');
                if (type === 'status') {
                    this.state.device.calibrated = false;
                    TestRunner.startStatusLoop(this);
                }
                if (this.state.device.ready) setTimeout(() => ui.scanInput.focus(), 100);
            } else UIManager.update(`${type}Msg`, 'âŒ è¿æ¥å¤±è´¥', 'error');
        }
        UIManager.updateButtons(this);
    },
    async runCalibration() {
        if (!this.serial.status.connected) return UIManager.update('statusMsg', 'è¯·å…ˆè¿æ¥ä¸²å£', 'error');
        if (this.state.device.ready) return UIManager.update('statusMsg', 'æµ‹è¯•æ¶åˆä¸Šä¸è®¸æ ¡å‡†', 'error');

        UIManager.update('statusMsg', 'æ­£åœ¨æ ¡å‡†...', 'info');
        for (let i = 0; i < 3; i++) {
            try {
                await this.serial.status.write('AT+CAL\r\n');
                await new Promise(r => setTimeout(r, 50));
                const s = this.state.device.status;
                if (s && [s.ai0, s.ai1, s.ai2].every(v => Math.abs(parseFloat(v)||0) <= 10)) {
                    UIManager.update('statusMsg', 'âœ… æ ¡å‡†æˆåŠŸ', 'success');
                    this.state.device.calibrated = true;
                    UIManager.updateButtons(this);
                    if (this.state.device.ready) setTimeout(() => ui.scanInput.focus(), 100);
                    return;
                }
                if (i < 2) await new Promise(r => setTimeout(r, 1000));
            } catch(e) { console.error(e); }
        }
        UIManager.update('statusMsg', 'æ ¡å‡†å¤±è´¥è¯·é‡è¯•', 'error');
        this.state.device.calibrated = false;
        UIManager.updateButtons(this);
    }
};

const TestRunner = {
    hwKeys: ['wifi', 'vout', 'iout', 'ai0', 'ai1', 'ai2', 'powerLight', 'rs485Light', 'networkLight'],
    async startTest(sn, app) {
        const st = app.state.test;
        if (!app.serial.test.port || st.inProgress || !sn || !app.state.device.ready) return;
        Object.assign(st, { inProgress: true, stepRetryCount: {}, skipWebTest: false, hasFailure: false, failureItems: [] });
        UIManager.updateButtons(app);
        UIManager.clearLog();
        UIManager.log(`ğŸš€ å¼€å§‹æµ‹è¯• SN: ${sn}`);
        UIManager.showTestResult('waiting');
        RecordManager.createOrUpdate({ sn, isNewTest: true });
        
        if (!app.serial.test.connected) return this.finishTest({ sn, serial: false }, app);
        st.currentStep = 'WAITING_FOR_DSN';
        await this.startReadLoop(sn, app);
        app.serial.test.buffer = '';
        
        if(await app.serial.test.write(`ccmd DSN;${sn}\r\n`)) UIManager.log(`ğŸ“¤ å·²å‘é€ DSN`);
        else this.finishTest({ sn, serial: false }, app);
    },
    async startReadLoop(sn, app) {
        await app.serial.test.stopRead();
        app.state.test.currentSN = sn;
        const handlers = {
            'WAITING_FOR_DSN': b => this.handleDsnResponse(b, sn, app),
            'WAITING_FOR_WIFI': b => this.handleWifiResponse(b, sn, app)
        };
        app.serial.test.readLoop(async txt => {
            app.serial.test.buffer += txt;
            const h = handlers[app.state.test.currentStep];
            if (h && /[\n]/.test(app.serial.test.buffer)) await h(app.serial.test.buffer);
        }, () => app.state.test.inProgress && this.finishTest({ sn, serial: false }, app));
        
        this.setStepTimeout('WAITING_FOR_DSN', () => this.retryOrFail('WAITING_FOR_DSN', sn, app, 
            () => app.serial.test.write(`ccmd DSN;${sn}\r\n`), 'ä¸²å£é€šä¿¡'), config.timeouts.dsn, app);
    },
    async retryOrFail(step, sn, app, retryFn, failItem) {
        const st = app.state.test;
        st.stepRetryCount[step] = (st.stepRetryCount[step] || 0) + 1;
        if (st.stepRetryCount[step] <= config.maxRetries) {
            UIManager.log(`ğŸ”„ ${step}é‡è¯• (${st.stepRetryCount[step]}/${config.maxRetries})...`);
            if(await retryFn() !== false) { 
                this.setStepTimeout(step, () => this.retryOrFail(step, sn, app, retryFn, failItem), config.timeouts[step.replace('WAITING_FOR_', '').toLowerCase()] || 3000, app);
            }
        } else {
            if (typeof failItem === 'function') await failItem();
            else {
                st.hasFailure = true;
                st.failureItems.push(failItem);
                this.skipRemainingTests(sn, app);
            }
        }
    },
    checkMatch(buffer, regex, step, app) {
        const m = buffer.match(regex);
        if (m) this.clearStepTimeout(step, app);
        return m ? m[1].trim() : null;
    },
    async handleDsnResponse(buf, sn, app) {
        const val = this.checkMatch(buf, /DSN;(\S+?)[\n]/, 'WAITING_FOR_DSN', app);
        if (!val) return;
        if (val === sn) {
            UIManager.log(`âœ… DSNåŒ¹é…`);
            RecordManager.createOrUpdate({ sn, snMatch: true });
            this.startWifiTest(sn, app);
        } else {
            UIManager.log(`âŒ SNä¸åŒ¹é…: ${val}`);
            this.retryOrFail('WAITING_FOR_DSN', sn, app, () => {
                app.serial.test.buffer = '';
                return app.serial.test.write(`ccmd DSN;${sn}\r\n`);
            }, () => {
                RecordManager.createOrUpdate({ sn, snMismatch: true });
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push('SNä¸åŒ¹é…');
                this.skipRemainingTests(sn, app);
            });
        }
        app.serial.test.buffer = '';
    },
    async startWifiTest(sn, app) {
        app.state.test.currentStep = 'WAITING_FOR_WIFI';
        const ssid = ui.wifiList.value;
        const pass = ui.wifiPass.value;
        const bssid = ui.wifiList.options[ui.wifiList.selectedIndex]?.dataset.bssid || '';
        
        const cmd = `ccmd WFI;${ssid};${pass};${bssid};1\r\n`;
        UIManager.log(`ğŸ“¤ å‘é€ WiFiéªŒè¯...`);
        
        this.setStepTimeout('WAITING_FOR_WIFI', () => this.retryOrFail('WAITING_FOR_WIFI', sn, app, 
            () => app.serial.test.write(cmd, 50), async () => {
                RecordManager.createOrUpdate({ sn, wifi: false });
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push('WiFiè¿æ¥');
                this.skipRemainingTests(sn, app);
            }), 10000, app);
            
        await app.serial.test.write(cmd, 50);
    },
    async handleWifiResponse(buf, sn, app) {
        UIManager.log(`ğŸ” å‘é€è¿æ¥ä¿¡æ¯ ${buf.trim()}`); 
        const ssid = ui.wifiList.value;
        const pass = ui.wifiPass.value;
        const bssid = ui.wifiList.options[ui.wifiList.selectedIndex]?.dataset.bssid || '';
        const configStr = `WFI;${ssid};${pass};${bssid};1`;
        
        const status = WifiController.checkStatus(buf, configStr);

        if (status === 'success') {
            this.clearStepTimeout('WAITING_FOR_WIFI', app);
            UIManager.log(`âœ… WiFiè¿æ¥éªŒè¯æˆåŠŸ`);
            RecordManager.createOrUpdate({ sn, wifi: true });
            app.serial.test.buffer = ''; 
            this.completeSerialTest(sn, app);
        } else if (status === 'password_error' || status === 'failed') {
            this.clearStepTimeout('WAITING_FOR_WIFI', app);
            const msg = status === 'password_error' ? 'å¯†ç é”™è¯¯' : 'è¿æ¥å¤±è´¥';
            UIManager.log(`âŒ WiFiè¿æ¥éªŒè¯å¤±è´¥: ${msg}`);
            RecordManager.createOrUpdate({ sn, wifi: false });
            app.state.test.hasFailure = true;
            app.state.test.failureItems.push('WiFiè¿æ¥');
            this.skipRemainingTests(sn, app);
        }
    },
    async completeSerialTest(sn, app) {
        UIManager.log(`âœ… ä¸²å£é€šä¿¡æ­£å¸¸`);
        RecordManager.createOrUpdate({ sn, serial: true });
        app.state.test.skipWebTest = false; 
        await this.startComponentAndLedTests(sn, app);
    },
    async startComponentAndLedTests(sn, app) {
        if (app.state.test.hasFailure) return this.skipRemainingTests(sn, app);
        app.state.test.currentStep = 'COMPONENT_TESTS';
        for (const t of COMP_TESTS) {
            const v = await this.getAvg(() => parseFloat(app.state.device.status?.[t.k]) || 0);
            const p = v >= t.l && v < t.h;
            UIManager.log(`ğŸ“Š ${t.n}: ${v.toFixed(3)}${t.u} [${p?'æ­£å¸¸':'å¼‚å¸¸'}]`);
            RecordManager.createOrUpdate({ sn, [t.k]: p });
            if (!p) {
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push(t.n);
                return this.skipRemainingTests(sn, app);
            }
        }
        await this.startLedTests(sn, app);
    },
    async startLedTests(sn, app) {
        if (app.state.test.hasFailure) return this.skipRemainingTests(sn, app);
        
        UIManager.log('ğŸ”„ å¼€å¯TCS...');
        while (true) {
            await app.serial.status.write('AT+TCS=ON\r\n');
            await new Promise(r => setTimeout(r, 200));
            if (app.state.device.status?.tcs === 'ON') break;
        }
        UIManager.log('âœ… TCSå·²å¼€å¯');

        await app.serial.test.write('ccmd LED;2;0\r\n');
        app.state.test.currentStep = 'LED_TESTS';
        const getR = () => this.getAvg(() => parseFloat(app.state.device.status?.color_r) || app.state.device.colorR || 0);
        
        for (const t of LED_TESTS) {
            let p = false, r = 0, retries = 0;
            do {
                await app.serial.test.write(t.c);
                await new Promise(res => setTimeout(res, 500));
                r = await getR();
                p = (r / t.d) > t.th;
                UIManager.log(`ğŸ“Š ${t.n} Color_R:${r.toFixed(3)} [${p?'æ­£å¸¸':'å¼‚å¸¸'}]${retries>0?` (é‡è¯• ${retries})`:''}`);
                if(!p) retries++;
            } while (!p && retries <= config.maxRetries);

            RecordManager.createOrUpdate({ sn, [t.k]: p });
            if (!p) {
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push(t.n);
                return this.skipRemainingTests(sn, app);
            }
        }
        await this.sendRstAndWait(sn, app);
    },
    async sendRstAndWait(sn, app) {
        if(await app.serial.status.write('AT+RST\r\n')) {
            UIManager.log('ğŸ“¤ å‘é€ AT+RST...');
            app.serial.status.buffer = '';
            app.state.test.currentStep = 'WAITING_FOR_RST';
            await new Promise(res => setTimeout(res, config.timeouts.rst));
            UIManager.log('âœ… é‡ç½®å®Œæˆ');
            await this.startWebTest(sn, app);
        } else {
            app.state.test.hasFailure = true;
            app.state.test.failureItems.push('è®¾å¤‡é‡ç½®');
            await this.skipRemainingTests(sn, app);
        }
    },
    async startWebTest(sn, app) {
        const enc = await DgwCrypto.encrypt("DAAN" + sn);
        const url = enc ? `${config.urls.test}${enc}` : null;
        let webRes = false;
        if (url) {
            UIManager.log(`ğŸŒ æµ‹è¯•ç½‘å€: ${url}`);
            try {
                const ctl = new AbortController();
                const tid = setTimeout(() => ctl.abort(), config.timeouts.fetch);
                const res = await fetch(`https://cors.lorens.qzz.io/?url=${encodeURIComponent(url)}`, { signal: ctl.signal, mode: 'cors', cache: 'no-cache' });
                clearTimeout(tid);
                if (res.ok) { UIManager.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ'); webRes = true; }
                else { app.state.test.hasFailure = true; app.state.test.failureItems.push('ç½‘é¡µè®¿é—®'); }
            } catch (e) {
                UIManager.log(`âŒ ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}`);
                app.state.test.hasFailure = true; app.state.test.failureItems.push('ç½‘é¡µè®¿é—®');
            }
        } else {
            app.state.test.hasFailure = true; app.state.test.failureItems.push('ç½‘é¡µè®¿é—®');
        }
        const r = app.records.find(x => x.sn === sn);
        await this.finishTest({ ...r, sn, web: webRes }, app);
    },
    async skipRemainingTests(sn, app) {
        UIManager.log('âš ï¸ å¼‚å¸¸è·³è¿‡åç»­æµ‹è¯•');
        const r = app.records.find(x => x.sn === sn);
        const skipObj = { serial: r?.serial==='pending'?'-':r?.serial, web: r?.web==='pending'?'-':r?.web };
        this.hwKeys.forEach(k => skipObj[k] = r?.[k]==='pending' ? '-' : r?.[k]);
        await this.finishTest({ ...r, sn, ...skipObj }, app);
    },
    async finishTest(res, app) {
        if (!app.state.test.inProgress) return;
        await app.serial.test.stopRead();
        Object.assign(app.state.test, { inProgress: false, stepTimeouts: {}, stepRetryCount: {}, skipWebTest: false, currentStep: 'DONE' });
        Object.values(app.state.test.stepTimeouts).forEach(clearTimeout);

        const hwPass = [res.serial, ...this.hwKeys.map(k => res[k])].every(x => x === true || x === '-');
        const final = res.web === 'æœªæ’å¡' ? hwPass : (res.web === '-' ? false : hwPass && res.web);
        
        RecordManager.createOrUpdate({ ...res, status: final, isNewTest: false });
        UIManager.log(`ğŸ“Š æµ‹è¯•å®Œæˆ: ${final ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
        UIManager.showTestResult(final);
        
        if (config.autoReport) {
            app.state.reporting = true;
            UIManager.updateButtons(app);
            await RecordManager.report(app.state.test.failureItems);
            app.state.reporting = false;
        }
        Object.assign(app.state.test, { hasFailure: false, failureItems: [] });
        UIManager.updateButtons(app);
        ui.scanInput.value = ''; ui.scanInput.focus();
    },
    startStatusLoop(app) {
        app.serial.status.readLoop(txt => {
            app.serial.status.buffer += txt;
            if (app.serial.status.buffer.includes('Color_C=')) {
                this.parseStatus(app.serial.status.buffer.trim(), app);
                app.serial.status.buffer = '';
            }
        }, e => { UIManager.log(`âŒ çŠ¶æ€ä¸²å£é”™è¯¯: ${e.message}`); app.toggleConn('status'); });
    },
    parseStatus(data, app) {
        const p = {};
        data.split(/\r?\n/).forEach(l => {
            const m = l.match(/^(\w+)[=:]\s*(.+)/);
            if (m) p[m[1].toLowerCase()] = m[2].trim();
        });
        if (p.color_r) app.state.device.colorR = parseFloat(p.color_r) || 0;
        const prev = app.state.device.status?.state;
        app.state.device.status = p;
        if (prev !== p.state) {
            app.state.device.ready = p.state === 'Ready';
            UIManager.update('statusMsg', app.state.device.ready ? 'âœ… è®¾å¤‡å·²å°±ç»ª' : 'â„¹ï¸ è®¾å¤‡æœªå°±ç»ª', app.state.device.ready ? 'success' : 'info');
            if (app.state.device.ready && app.state.device.calibrated) { setTimeout(() => ui.scanInput.focus(), 100); UIManager.log('âœ… è®¾å¤‡å·²å°±ç»ª'); }
        }
        UIManager.updateButtons(app);
    },
    async getAvg(fn) {
        const s = [];
        for (let i = 0; i < config.sampling.count; i++) {
            s.push(await fn());
            if (i < config.sampling.count - 1) await new Promise(r => setTimeout(r, config.sampling.interval));
        }
        s.sort((a, b) => a - b);
        const valid = s.length <= 2 ? s : s.slice(1, -1);
        const avg = valid.reduce((a, b) => a + b, 0) / valid.length;
        UIManager.log(`ğŸ“Š é‡‡æ ·: [${s.join(', ')}] -> å¹³å‡: ${avg.toFixed(3)}`);
        return avg;
    },
    setStepTimeout(step, cb, time, app) {
        this.clearStepTimeout(step, app);
        app.state.test.stepTimeouts[step] = setTimeout(cb, time);
    },
    clearStepTimeout(step, app) {
        if (app.state.test.stepTimeouts[step]) clearTimeout(app.state.test.stepTimeouts[step]);
    }
};

if ('serial' in navigator) app.init();
else { alert('é”™è¯¯ï¼šä¸æ”¯æŒ Web Serial API'); document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>'; }
</script>
</body>
</html>