<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ•°æ®æ£’æµ‹è¯•</title>
    <style>
        body { font-family: Arial; padding: 20px; }
        .btn { margin: 5px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 3px; cursor: pointer; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .panel { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin: 10px 0; }
        .panel-green { border-color: #28a745; background: #f8fff8; }
        .panel-blue { border-color: #007bff; background: #f8f9ff; }
        .flex { display: flex; gap: 20px; }
        .flex > div { flex: 1; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .status-item { display: flex; justify-content: space-between; margin: 5px 0; }
        .status-value { color: #007bff; font-weight: bold; }
        .status-ready { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-on { color: #28a745; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .pass { background: #d4edda; color: green; }
        .fail { background: #f8d7da; color: red; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ccc; height: 160px; overflow-y: auto; background: #f9f9f9; font-family: monospace; white-space: pre-wrap; }
        #deviceStatus { margin: 10px 0; }
        .color-preview { width: 100%; height: 30px; border: 1px solid #ddd; margin: 5px 0; }
        .hidden { display: none; }
    </style>
</head>
<body>
<h1>æ•°æ®æ£’æµ‹è¯•</h1>

<div class="flex">
    <div class="panel panel-green">
        <h3>è®¾å¤‡çŠ¶æ€ç›‘æ§</h3>
        <button class="btn" onclick="app.selectPort('status')">é€‰æ‹©çŠ¶æ€ä¸²å£</button>
        <button class="btn" id="connectStatus" onclick="app.connect('status')">è¿æ¥</button>
        <button class="btn" id="disconnectStatus" onclick="app.disconnect('status')">æ–­å¼€</button>
        <div id="statusMsg"></div>
    </div>

    <div class="panel panel-blue">
        <h3>æµ‹è¯•åŠŸèƒ½</h3>
        <div style="margin: 10px 0; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
            <button class="btn" onclick="app.selectPort('test')">é€‰æ‹©æµ‹è¯•ä¸²å£</button>
            <div style="display: flex; align-items: center;">
                <label>SN:</label>
                <input type="text" id="scanInput" placeholder="è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ..." style="width: 200px; padding: 8px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px;" />
            </div>
            <button class="btn" onclick="app.saveRecords()">ä¿å­˜è®°å½•</button>
        </div>
        <div id="testMsg"></div>
    </div>
</div>

<div id="deviceStatus" class="panel hidden">
    <h3>è®¾å¤‡çŠ¶æ€ä¿¡æ¯</h3>
    <div class="grid" id="statusGrid"></div>
</div>

<div class="panel">
    <table>
        <thead><tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th></tr></thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
class SerialManager {
    constructor(type) {
        this.type = type;
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.connected = false;
        this.buffer = '';
    }

    async select() {
        try {
            this.port = await navigator.serial.requestPort();
            return true;
        } catch { return false; }
    }

    async connect(baudRate) {
        if (!this.port) return false;
        try {
            await this.port.open({ baudRate });
            this.reader = this.port.readable.getReader();
            if (this.type === 'test') this.writer = this.port.writable.getWriter();
            this.connected = true;
            return true;
        } catch (e) {
            console.error(`${this.type}è¿æ¥å¤±è´¥:`, e);
            return false;
        }
    }

    async disconnect() {
        this.connected = false;
        this.buffer = '';
        if (this.reader) {
            try { await this.reader.cancel(); } catch {}
            this.reader.releaseLock();
            this.reader = null;
        }
        if (this.writer) {
            this.writer.releaseLock();
            this.writer = null;
        }
        if (this.port) {
            try { await this.port.close(); } catch {}
        }
    }
}

const app = {
    status: new SerialManager('status'),
    test: new SerialManager('test'),
    testing: false,
    records: [],

    log(msg) {
        document.getElementById('logBox').textContent += `\n${msg}`;
        document.getElementById('logBox').scrollTop = document.getElementById('logBox').scrollHeight;
    },

    statusLog(msg) {
        console.log(`[çŠ¶æ€] ${msg}`);
    },

    updateUI(id, text) {
        document.getElementById(id).textContent = text;
    },

    async selectPort(type) {
        const port = this[type];
        const success = await port.select();
        this.updateUI(`${type}Msg`, success ? 'âœ… ä¸²å£å·²é€‰æ‹©' : 'âŒ é€‰æ‹©å¤±è´¥');
        this.updateButtons();
    },

    async connect(type) {
        const port = this[type];
        if (!port.port || port.connected) return;
        
        const baudRate = type === 'status' ? 115200 : 10000000;
        this.updateUI(`${type}Msg`, 'âŒ› è¿æ¥ä¸­...');
        
        const success = await port.connect(baudRate);
        if (success) {
            this.updateUI(`${type}Msg`, 'âœ… å·²è¿æ¥');
            if (type === 'status') this.statusLoop();
        } else {
            this.updateUI(`${type}Msg`, 'âŒ è¿æ¥å¤±è´¥');
        }
        this.updateButtons();
    },

    async disconnect(type) {
        const port = this[type];
        await port.disconnect();
        this.updateUI(`${type}Msg`, 'â„¹ï¸ å·²æ–­å¼€');
        this.updateButtons();
    },

    updateButtons() {
        document.getElementById('connectStatus').disabled = !this.status.port || this.status.connected;
        document.getElementById('disconnectStatus').disabled = !this.status.connected;
    },

    async statusLoop() {
        if (!this.status.connected) return;
        try {
            const { value, done } = await this.status.reader.read();
            if (done || !value) return;
            
            const text = new TextDecoder().decode(value);
            this.status.buffer += text;
            
            if (this.status.buffer.includes('Color_C=')) {
                this.parseStatus(this.status.buffer.trim());
                this.status.buffer = '';
            }
            
            if (this.status.connected) this.statusLoop();
        } catch (e) {
            this.statusLog('è¯»å–é”™è¯¯: ' + e);
            await this.disconnect('status');
        }
    },

    parseStatus(data) {
        this.statusLog('è§£ææ•°æ®: ' + data);
        const lines = data.split(/\r?\n/);
        const parsed = {};
        
        lines.forEach(line => {
            const colonMatch = line.match(/^(\w+):(.+)/);
            const equalMatch = line.match(/^(\w+)=(.+)/);
            
            if (colonMatch) parsed[colonMatch[1].toLowerCase()] = colonMatch[2];
            else if (equalMatch) parsed[equalMatch[1].toLowerCase()] = equalMatch[2];
        });

        this.displayStatus(parsed);
    },

    displayStatus(data) {
        const container = document.getElementById('deviceStatus');
        const grid = document.getElementById('statusGrid');
        container.classList.remove('hidden');
        
        const groups = {
            'ç³»ç»ŸçŠ¶æ€': [
                { key: 'state', label: 'çŠ¶æ€', desc: data.state === 'Ready' ? 'å°±ç»ª' : 'ç­‰å¾…' },
                { key: 'swd', label: 'SWDçƒ§å½•', desc: data.swd === 'ON' ? 'å¼€å¯' : 'å…³é—­' }
            ],
            'ç”µæºä¿¡æ¯': [
                { key: 'vout', label: 'å·¥ä½œç”µå‹' },
                { key: 'iout', label: 'å·¥ä½œç”µæµ' },
                { key: 'pout', label: 'å·¥ä½œåŠŸè€—' }
            ],
            'æ¨¡æ‹Ÿè¾“å…¥': [
                { key: 'ai0', label: 'DCDCè¾“å‡º' },
                { key: 'ai1', label: 'WIFI/4Gä¾›ç”µ' },
                { key: 'ai2', label: 'MCUä¾›ç”µ' }
            ],
            'é¢œè‰²ä¼ æ„Ÿå™¨': [
                { key: 'tcs', label: 'TCSçŠ¶æ€', desc: data.tcs === 'ON' ? 'å¼€å¯' : 'å…³é—­' },
                { key: 'color_r', label: 'çº¢è‰²å€¼' },
                { key: 'color_g', label: 'ç»¿è‰²å€¼' },
                { key: 'color_b', label: 'è“è‰²å€¼' },
                { key: 'color_c', label: 'å‚è€ƒå€¼' }
            ]
        };

        grid.innerHTML = Object.entries(groups).map(([title, items]) => `
            <div class="panel">
                <h4>${title}</h4>
                ${items.map(item => {
                    const value = data[item.key] || '-';
                    const cls = item.key === 'state' ? (data.state === 'Ready' ? 'status-ready' : 'status-wait') :
                              item.key === 'swd' || item.key === 'tcs' ? (data[item.key] === 'ON' ? 'status-on' : 'status-off') : '';
                    return `<div class="status-item">
                        <span>${item.label}:</span>
                        <span class="status-value ${cls}">${value} ${item.desc || ''}</span>
                    </div>`;
                }).join('')}
                ${title === 'é¢œè‰²ä¼ æ„Ÿå™¨' && data.color_r && data.color_g && data.color_b ? 
                    `<div class="color-preview" style="background:rgb(${data.color_r},${data.color_g},${data.color_b})"></div>` : ''}
            </div>
        `).join('');
    },

    async startTest() {
        if (!this.test.port || this.testing) return;
        this.testing = true;
        this.updateButtons();
        this.updateUI('testMsg', 'â³ æ­£åœ¨æµ‹è¯•...');
        
        try {
            const baudRate = 10000000;
            await this.test.connect(baudRate);
            this.log('ğŸ“¤ å·²å‘é€æµ‹è¯•æŒ‡ä»¤: 0101020001783C');
            
            // å‘é€æµ‹è¯•æŒ‡ä»¤ (hex: 0101020001783C)
            const hexCommand = [0x01, 0x01, 0x02, 0x00, 0x01, 0x78, 0x3C];
            await this.test.writer.write(new Uint8Array(hexCommand));
            
            // å¼€å§‹è¯»å–å“åº”
            this.testReadLoop();
            
            // è®¾ç½®è¶…æ—¶
            setTimeout(async () => {
                if (this.testing) {
                    this.log('â° æµ‹è¯•è¶…æ—¶');
                    await this.finishTest({ sn: null, imei: null, iccid: null, serial: false, web: false });
                }
            }, 10000);
            
        } catch (e) {
            this.log('âŒ æµ‹è¯•è¿æ¥å¤±è´¥: ' + e);
            await this.finishTest({ sn: null, imei: null, iccid: null, serial: false, web: false });
        }
    },

    async testReadLoop() {
        if (!this.testing || !this.test.connected) return;
        
        try {
            const { value, done } = await this.test.reader.read();
            if (done || !value) {
                if (this.testing) this.testReadLoop();
                return;
            }
            
            this.test.buffer += new TextDecoder().decode(value);
            this.log('ğŸ“¥ æ”¶åˆ°æ•°æ®: ' + [...value].map(b => b.toString(16).padStart(2, '0')).join(''));
            
            // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
            if (this.test.buffer.length >= 8 || this.test.buffer.includes('\n')) {
                this.log('ğŸ”„ å¼€å§‹è§£ææ•°æ®...');
                const result = this.parseTestData(this.test.buffer);
                
                if (result) {
                    this.log('âœ… æ•°æ®è§£æå®Œæˆ');
                    // æµ‹è¯•ç½‘ç»œè¿æ¥
                    this.updateUI('testMsg', 'ğŸ”— æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...');
                    const webResult = await this.testWebConnection();
                    result.web = webResult;
                    
                    await this.finishTest(result);
                } else {
                    // ç»§ç»­è¯»å–
                    if (this.testing) this.testReadLoop();
                }
            } else {
                // ç»§ç»­è¯»å–
                if (this.testing) this.testReadLoop();
            }
            
        } catch (e) {
            this.log('âŒ æ•°æ®è¯»å–å¼‚å¸¸: ' + e);
            await this.finishTest({ sn: null, imei: null, iccid: null, serial: false, web: false });
        }
    },

    parseTestData(buffer) {
        this.log('ğŸ“ è§£ææ•°æ®: ' + JSON.stringify(buffer));
        
        try {
            // å°è¯•JSONè§£æ
            const jsonData = JSON.parse(buffer);
            return {
                sn: jsonData.sn || jsonData.SN || null,
                imei: jsonData.imei || jsonData.IMEI || null,
                iccid: jsonData.sim || jsonData.SIM || jsonData.iccid || jsonData.ICCID || null,
                serial: true
            };
        } catch {
            // åå…­è¿›åˆ¶è§£æ
            const hexStr = [...new Uint8Array(buffer.split('').map(c => c.charCodeAt(0)))]
                .map(b => b.toString(16).padStart(2, '0')).join('');
            
            if (hexStr.length >= 16) {
                const sn = hexStr.slice(0, 8).toUpperCase();
                const imei = hexStr.slice(8, 16);
                const iccid = hexStr.slice(16, 32);
                
                this.log(`ğŸ“¦ åå…­è¿›åˆ¶è§£æ: SN=${sn}, IMEI=${imei}, SIM=${iccid}`);
                
                return {
                    sn: sn || null,
                    imei: imei || null,
                    iccid: iccid || null,
                    serial: !!(sn || imei || iccid)
                };
            }
        }
        
        return null;
    },

    async testWebConnection() {
        const testUrl = 'http://gw.3wlink.cn:22011/main?dgwkey=ZBsQU5uQoNWdK9x6xG58-o6tQmBaKYN0v9e3R0X37rY';
        this.log('ğŸŒ æµ‹è¯•ç½‘å€: ' + testUrl);
        
        try {
            // ç›´æ¥è®¿é—®
            const response = await fetch(testUrl, { 
                method: 'GET', 
                mode: 'cors', 
                cache: 'no-cache',
                timeout: 5000
            });
            
            if (response.ok) {
                this.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ');
                return true;
            }
        } catch (e) {
            this.log('âŒ ç½‘ç»œè®¿é—®å¤±è´¥: ' + e.message);
        }
        
        // å°è¯•ä»£ç†
        const proxies = [
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/',
            'https://corsproxy.io/?'
        ];
        
        for (let proxy of proxies) {
            try {
                this.log('ğŸ”„ å°è¯•ä»£ç†: ' + proxy.split('/')[2]);
                const response = await fetch(proxy + encodeURIComponent(testUrl), {
                    timeout: 3000
                });
                
                if (response.ok) {
                    this.log('âœ… ä»£ç†è®¿é—®æˆåŠŸ');
                    return true;
                }
            } catch (e) {
                this.log('âŒ ä»£ç†å¤±è´¥: ' + e.message);
            }
        }
        
        this.log('âŒ æ‰€æœ‰ç½‘ç»œæµ‹è¯•å¤±è´¥');
        return false;
    },

    async finishTest(result) {
        this.testing = false;
        result.status = (result.serial && result.web) ? 'é€šè¿‡' : 'ä¸é€šè¿‡';
        result.timestamp = Date.now();
        
        this.addTestResult(result);
        this.log(`ğŸ“Š æµ‹è¯•å®Œæˆ: ${result.status}`);
        this.updateUI('testMsg', `âœ… æµ‹è¯•å®Œæˆ: ${result.status}`);
        
        await this.test.disconnect();
        this.updateButtons();
    },

    addTestResult(result) {
        this.records.push(result);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${new Date(result.timestamp).toLocaleString()}</td>
            <td>${result.sn || '-'}</td>
            <td>${result.imei || '-'}</td>
            <td>${result.iccid || '-'}</td>
            <td class="${result.serial ? 'pass' : 'fail'}">${result.serial ? 'æ­£å¸¸' : 'å¼‚å¸¸'}</td>
            <td class="${result.web ? 'pass' : 'fail'}">${result.web ? 'æ­£å¸¸' : 'å¼‚å¸¸'}</td>
            <td class="${result.status === 'é€šè¿‡' ? 'pass' : 'fail'}">${result.status}</td>
        `;
        document.getElementById('resultBody').insertBefore(row, document.getElementById('resultBody').firstChild);
    },

    saveRecords() {
        if (!this.records.length) return alert('æ²¡æœ‰æµ‹è¯•è®°å½•');
        
        const csv = [
            ['æ—¶é—´', 'SN', 'IMEI', 'ICCID', 'ä¸²å£é€šä¿¡', 'ç½‘é¡µè®¿é—®', 'æµ‹è¯•ç»“æœ'],
            ...this.records.map(r => [
                new Date(r.timestamp).toLocaleString(),
                r.sn || '-', r.imei || '-', r.iccid || '-',
                r.serial ? 'æ­£å¸¸' : 'å¼‚å¸¸',
                r.web ? 'æ­£å¸¸' : 'å¼‚å¸¸',
                r.status
            ])
        ].map(row => row.join(',')).join('\n');
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'test_records.csv';
        a.click();
        URL.revokeObjectURL(url);
    },

    setupScanInput() {
        const scanInput = document.getElementById('scanInput');
        let isNewScan = true; // æ ‡è®°æ˜¯å¦æ˜¯æ–°çš„æ‰«ç 
        
        // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†
        scanInput.focus();
        
        // å¤„ç†è¾“å…¥äº‹ä»¶ - æ–°è¾“å…¥æ—¶æ¸…ç©ºä¹‹å‰çš„å€¼
        scanInput.addEventListener('input', (e) => {
            if (isNewScan) {
                // å¦‚æœæ˜¯æ–°çš„æ‰«ç ï¼Œæ¸…ç©ºä¹‹å‰çš„å€¼ï¼Œåªä¿ç•™å½“å‰è¾“å…¥çš„å­—ç¬¦
                const currentChar = e.data; // å½“å‰è¾“å…¥çš„å­—ç¬¦
                if (currentChar) {
                    scanInput.value = currentChar;
                }
                isNewScan = false;
            }
        });
        
        // å¤„ç†å›è½¦é”®ï¼ˆæ‰«ç æªé€šå¸¸ä¼šè‡ªåŠ¨æ·»åŠ å›è½¦ï¼‰
        scanInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const value = e.target.value;
                if (value) {
                    this.log(`ğŸ” æ‰«ç å®Œæˆ: ${value}`);
                    this.updateUI('testMsg', `âœ… æ‰«ç ç»“æœ: ${value}`);
                    this.processScanResult(value);
                    isNewScan = true; // æ ‡è®°ä¸‹æ¬¡è¾“å…¥ä¸ºæ–°æ‰«ç 
                }
            }
        });
        
        // å¤±ç„¦åé‡æ–°èšç„¦ï¼ˆç¡®ä¿æ‰«ç æªå§‹ç»ˆå¯ç”¨ï¼‰
        scanInput.addEventListener('blur', () => {
            setTimeout(() => scanInput.focus(), 100);
        });
    },

    processScanResult(scanData) {
        // æ¸…ç©ºæ—¥å¿—çª—å£
        document.getElementById('logBox').textContent = 'æµ‹è¯•æ—¥å¿—...';
        
        // å¤„ç†æ‰«ç ç»“æœ
        this.log(`ğŸ“‹ å¤„ç†æ‰«ç æ•°æ®: ${scanData}`);
        
        // è‡ªåŠ¨å¼€å§‹æµ‹è¯•æµç¨‹
        this.startTest();
        
        // ä¿æŒè¾“å…¥æ¡†èšç„¦ï¼Œä¸æ¸…ç©ºå€¼ï¼ˆè®©ç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰«ç ç»“æœï¼‰
        setTimeout(() => {
            document.getElementById('scanInput').focus();
        }, 100);
    },

    async init() {
        this.updateButtons();
        this.setupScanInput();
        
        // è‡ªåŠ¨æ£€æµ‹ä¸²å£
        const ports = await navigator.serial.getPorts();
        if (ports.length >= 1) {
            this.status.port = ports[0];
            this.updateUI('statusMsg', 'âœ… è‡ªåŠ¨é€‰æ‹©çŠ¶æ€ä¸²å£');
            if (ports.length >= 2) {
                this.test.port = ports[1];
                this.updateUI('testMsg', 'âœ… è‡ªåŠ¨é€‰æ‹©æµ‹è¯•ä¸²å£');
            }
            this.updateButtons();
        }
    }
};

// åˆå§‹åŒ–
if ('serial' in navigator) app.init();
else alert('æµè§ˆå™¨ä¸æ”¯æŒä¸²å£åŠŸèƒ½');
</script>
</body>
</html>
