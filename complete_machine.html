<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 æ•´æœºæµ‹è¯•</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background-color: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background-color: #fff; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background-color: #f8f9fa; color: #495057; font-weight: 600; }
        .pass { background-color: #d1f2d1; color: #28a745; }
        .fail { background-color: #f8d7da; color: #dc3545; }
        .testing { background-color: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 160px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .table-container { max-height: 520px; overflow-y: auto; }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1>æ•´æœºæµ‹è¯•</h1>
    <div style="display: flex; gap: 10px;">
        <button class="btn" id="saveRecordsBtn">ä¿å­˜è®°å½•</button>
        <button class="btn" id="switchInterfaceBtn" style="background-color: #28a745; color: white; font-weight: bold;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<div class="panel">
    <div class="grid">
        <div class="panel panel-green">
            <h4>è®¾å¤‡1</h4>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice1Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice1Btn">è¿æ¥</button>
                <div id="device1Msg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h4>è®¾å¤‡2</h4>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice2Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice2Btn">è¿æ¥</button>
                <div id="device2Msg"></div>
            </div>
        </div>
        <div class="panel panel-green">
            <h4>è®¾å¤‡3</h4>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice3Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice3Btn">è¿æ¥</button>
                <div id="device3Msg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h4>è®¾å¤‡4</h4>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice4Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice4Btn">è¿æ¥</button>
                <div id="device4Msg"></div>
            </div>
        </div>
    </div>
</div>

<div class="panel">
    <div class="table-container">
        <table>
            <thead><tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
            <tbody id="wholeMachineResultBody"></tbody>
        </table>
    </div>
</div>
<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
    // ==================================================================================
    // é…ç½® & UI å…ƒç´ 
    // ==================================================================================
    const config = { 
        aes: { keyString: "me%ov2Ied|eicegh", ivString: "me%ov2Ied|eicegh" }, 
        urls: {
            test: "http://gw.3wlink.cn:22011/?dgwkey=",
            report: "https://daantest.free.beeceptor.com" // ä¸ŠæŠ¥æœåŠ¡å™¨URL
        },
        baudRate: 115200,
        timeouts: {
            command: 15000, // 15sç­‰å¾…æ—¶é—´
            response: 5000,    // å“åº”è¶…æ—¶
            fetch: 5000,    // ç½‘ç»œè®¿é—®è¶…æ—¶
            report: 10000   // ä¸ŠæŠ¥è¶…æ—¶
        },
        autoReport: true // è‡ªåŠ¨ä¸ŠæŠ¥æ‰€æœ‰æµ‹è¯•ç»“æœ
    };

    const ui = {
        logBox: document.getElementById('logBox'),
        resultBody: document.getElementById('wholeMachineResultBody'),
        saveRecordsBtn: document.getElementById('saveRecordsBtn'),
        devicePanels: [
            {
                selectBtn: document.getElementById('selectDevice1Btn'),
                connectBtn: document.getElementById('connectDevice1Btn'),
                msg: document.getElementById('device1Msg'),
            },
            {
                selectBtn: document.getElementById('selectDevice2Btn'),
                connectBtn: document.getElementById('connectDevice2Btn'),
                msg: document.getElementById('device2Msg'),
            },
            {
                selectBtn: document.getElementById('selectDevice3Btn'),
                connectBtn: document.getElementById('connectDevice3Btn'),
                msg: document.getElementById('device3Msg'),
            },
            {
                selectBtn: document.getElementById('selectDevice4Btn'),
                connectBtn: document.getElementById('connectDevice4Btn'),
                msg: document.getElementById('device4Msg'),
            },
        ]
    };

    // ==================================================================================
    // æ¨¡å—: åŠ å¯†å·¥å…·
    // ==================================================================================
    const DgwCrypto = {
        _key: null, _iv: null,
        async init() {
            if (this._key) return;
            try {
                const keyBytes = new TextEncoder().encode(config.aes.keyString);
                this._iv = new TextEncoder().encode(config.aes.ivString);
                this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
            } catch (error) {
                console.error(":", error);
                throw error;
            }
        },
        async encrypt(plainText) {
            if (!this._key) { await this.init(); }
            try {
                const textBytes = new TextEncoder().encode(plainText);
                const blockSize = 16;
                let paddedData;
                if (textBytes.length % blockSize === 0) {
                    paddedData = new Uint8Array(textBytes);
                } else {
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    paddedData = new Uint8Array(textBytes.length + paddingNeeded);
                    paddedData.set(textBytes);
                }
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                const encryptedArray = new Uint8Array(encrypted);
                const truncated = encryptedArray.slice(0, paddedData.length);
                const base64 = btoa(String.fromCharCode(...truncated));
                return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            } catch (error) {
                console.error('åŠ å¯†å¤±è´¥:', error);
                return null;
            }
        }
    };

    // ==================================================================================
    // æ¨¡å—: ä¸²å£ç®¡ç†å™¨
    // ==================================================================================
    class SerialManager {
        constructor(id) {
            this.id = id;
            this.port = null;
            this.reader = null;
            this.writer = null;
            this.connected = false;
            this.buffer = '';
            this.readLoopActive = false;
        }
        async select() { try { this.port = await navigator.serial.requestPort(); return true; } catch { return false; } }
        async connect(baudRate) {
            if (!this.port) return false;
            try {
                await this.port.open({ baudRate });
                this.writer = this.port.writable?.getWriter();
                this.connected = true;
                return true;
            } catch (e) {
                console.error(`è®¾å¤‡ ${this.id} è¿æ¥å¤±è´¥:`, e);
                return false;
            }
        }
        async disconnect() {
            await this.stopReadLoop();
            if (this.writer) { try { await this.writer.close(); } catch { /*  å¿½ç•¥  */ } finally { this.writer = null; } } 
            if (this.port) { try { await this.port.close(); } catch { /*  å¿½ç•¥  */ } }
            this.connected = false;
            this.buffer = '';
        }
        async readLoop(onData, onError) {
            if (!this.port?.readable || !this.connected) return;
            this.readLoopActive = true;
            this.reader = this.port.readable.getReader();
            try {
                while (this.connected && this.readLoopActive) {
                    const { value, done } = await this.reader.read();
                    if (done) break;
                    if (onData) onData(new TextDecoder().decode(value));
                }
            } catch (e) {
                if (this.readLoopActive) { 
                    if (onError) onError(e);
                }
            } finally {
                if(this.reader) {
                    this.reader.releaseLock();
                    this.reader = null;
                }
            }
            this.readLoopActive = false;
        }
        async stopReadLoop() {
            if (this.readLoopActive) {
                this.readLoopActive = false;
                if (this.reader) {
                    try {
                        await this.reader.cancel();
                    } catch (e) { /* å¿½ç•¥ */ }
                }
            }
        }
    }

    // ==================================================================================
    // æ¨¡å—: UI ç®¡ç†å™¨
    // ==================================================================================
    const UIManager = {
        log(msg) {
            const timestamp = new Date().toLocaleTimeString();
            ui.logBox.textContent += `\n[${timestamp}] ${msg}`;
            ui.logBox.scrollTop = ui.logBox.scrollHeight;
        },

        update(id, text, type = 'info') {
            const el = ui.devicePanels[id - 1].msg;
            if (!el) return;
            el.textContent = text;
            el.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black';
        },

        updateButtons(app) {
            app.devices.forEach((device, i) => {
                const panel = ui.devicePanels[i];
                if (device.serial.connected) {
                    panel.connectBtn.textContent = 'æ–­å¼€';
                    // æµ‹è¯•è¿›è¡Œä¸­æ—¶ç¦ç”¨æ–­å¼€æŒ‰é’®
                    panel.connectBtn.disabled = device.inProgress;
                } else {
                    panel.connectBtn.textContent = 'è¿æ¥';
                    panel.connectBtn.disabled = !device.serial.port;
                }
                panel.selectBtn.disabled = device.inProgress;
            });
            
            // æ›´æ–°ä¿å­˜è®°å½•æŒ‰é’®çŠ¶æ€
            const hasRecords = app.devices.some(d => d.record);
            ui.saveRecordsBtn.disabled = !hasRecords;
        },
        
        addOrUpdateTestResult(record) {
            let row = document.getElementById(`row-${record.sn}`);
            if (!row) {
                row = ui.resultBody.insertRow(0);
                row.id = `row-${record.sn}`;
                for (let i = 0; i < 8; i++) row.insertCell();
            }

            const getStatusDisplay = (val) => {
                if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
                if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
                if (val === 'æœªæ’å¡') return { text: 'æœªæ’å¡', className: 'fail' };
                return { text: 'å¾…æµ‹è¯•', className: '' }; 
            };

            const updateCell = (cell, { text, className = '' }) => {
                cell.textContent = text;
                cell.className = className;
            };

            const columns = [
                { text: record.timestamp, className: '' },
                { text: record.sn, className: record.sn ? 'pass' : 'fail' },
                { text: record.imei, className: record.imei ? 'pass' : 'fail' },
                { text: record.iccid, className: record.iccid && record.iccid !== 'æœªæ’å¡' ? 'pass' : 'fail' },
                getStatusDisplay(record.serial),
                getStatusDisplay(record.web),
                (() => { // æµ‹è¯•ç»“æœæ˜¾ç¤º
                    if (record.status === 'pending') return { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' };
                    return getStatusDisplay(record.status);
                })(),
                (() => { // ä¸ŠæŠ¥çŠ¶æ€
                    if (record.reportFailed) return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    if (record.reported) return { text: 'å·²ä¸ŠæŠ¥', className: 'pass' };
                    return { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' };
                })()
            ];

            columns.forEach((col, i) => updateCell(row.cells[i], col));
        }
    };

    // ==================================================================================
    // æ¨¡å—: ä¸»åº”ç”¨
    // ==================================================================================
    const app = {
        devices: [],

        async init() {
            try {
                await DgwCrypto.init();
            } catch (e) {
                alert('URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚');
                UIManager.log('âŒ URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
                return;
            }

            for (let i = 1; i <= 4; i++) {
                this.devices.push({
                    id: i, 
                    serial: new SerialManager(i),
                    inProgress: false,
                    record: null
                });
            }

            this.setupEventListeners();
            await this.loadSavedPorts();
            UIManager.updateButtons(this);
            UIManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
        },

        setupEventListeners() {
            this.devices.forEach((device, i) => {
                const panel = ui.devicePanels[i];
                panel.selectBtn.addEventListener('click', () => this.selectPort(device.id));
                panel.connectBtn.addEventListener('click', () => this.toggleConnection(device.id));
            });
            ui.saveRecordsBtn.addEventListener('click', () => this.saveToCSV());

            // ç•Œé¢åˆ‡æ¢åŠŸèƒ½
            document.getElementById('switchInterfaceBtn').addEventListener('click', () => {
                window.location.href = 'single_board.html';
            });
        },

        saveToCSV() {
            const records = this.devices.map(d => d.record).filter(r => r);
            if (records.length === 0) {
                alert('æ²¡æœ‰æµ‹è¯•è®°å½•å¯ä¾›ä¿å­˜ã€‚');
                return;
            }

            const header = ['æ—¶é—´', 'SN', 'IMEI', 'ICCID', 'ä¸²å£é€šä¿¡', 'ç½‘é¡µè®¿é—®', 'æµ‹è¯•ç»“æœ', 'ä¸ŠæŠ¥çŠ¶æ€'];
            const formatResult = (val) => {
                if (val === true) return 'æ­£å¸¸';
                if (val === false) return 'å¼‚å¸¸';
                return val || 'å¾…æµ‹è¯•';
            };

            const rows = records.map(r => [r.timestamp, r.sn, r.imei, r.iccid, formatResult(r.serial), formatResult(r.web), formatResult(r.status),
                r.reported ? 'å·²ä¸ŠæŠ¥' : (r.reportFailed ? 'æœªä¸ŠæŠ¥' : 'å¾…ä¸ŠæŠ¥')
            ]);

            const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
            const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `æ•´æœºæµ‹è¯•è®°å½•_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        },

        async loadSavedPorts() {
            for (let i = 1; i <= 4; i++) {
                const load = async (id) => {
                    try {
                        const savedIndex = localStorage.getItem(`serialPort_device_${id}`);
                        if (savedIndex === null) return;
                        const allPorts = await navigator.serial.getPorts();
                        const port = allPorts[parseInt(savedIndex, 10)] || null;
                        if (port) {
                            this.devices[id - 1].serial.port = port;
                            UIManager.update(id, 'âœ… ä¸²å£å·²åŠ è½½');
                        }
                    } catch (e) {
                        console.error('æœªèƒ½åŠ è½½ç«¯å£é€‰æ‹©:', e);
                    }
                };
                await load(i);
            }
        },

        async selectPort(id) {
            const device = this.devices[id - 1];
            if (await device.serial.select()) {
                UIManager.update(id, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
                try {
                    const allPorts = await navigator.serial.getPorts();
                    const portIndex = allPorts.indexOf(device.serial.port);
                    if (portIndex > -1) {
                        localStorage.setItem(`serialPort_device_${id}`, portIndex.toString());
                        UIManager.log(`ğŸ’¾ å·²ä¿å­˜è®¾å¤‡ ${id} ä¸²å£é€‰æ‹©`);
                    }
                } catch (e) {
                    console.error('ä¿æŒé€‰æ‹©ç«¯å£å¤±è´¥:', e);
                }
            }
            UIManager.updateButtons(this);
        },

        async toggleConnection(id, forceDisconnect = false) {
            const device = this.devices[id - 1];
            if (forceDisconnect || device.serial.connected) {
                await device.serial.disconnect();
                UIManager.update(id, 'â„¹ï¸ æµ‹è¯•å®Œæˆï¼Œå·²æ–­å¼€');
            } else {
                UIManager.update(id, 'âŒ› è¿æ¥ä¸­...');
                if (await device.serial.connect(config.baudRate)) {
                    UIManager.update(id, 'âœ… å·²è¿æ¥', 'success');
                    TestRunner.startTest(device, this);
                } else {
                    UIManager.update(id, 'âŒ è¿æ¥å¤±è´¥', 'error');
                }
            }
            UIManager.updateButtons(this);
        },
    };

    // ==================================================================================
    // æ¨¡å—: æµ‹è¯•æ‰§è¡Œå™¨
    // ==================================================================================
    const TestRunner = {
        async startTest(device, app) {
            if (device.inProgress) return;

            device.inProgress = true;
            UIManager.updateButtons(app);
            UIManager.update(device.id, 'â³ ç­‰å¾…è®¾å¤‡å¯åŠ¨...');

            try {
                await new Promise(resolve => setTimeout(resolve, config.timeouts.command));
                UIManager.update(device.id, 'âœ… æ­£åœ¨åœ¨æµ‹è¯•...');
                // ç­‰å¾…ç»“æŸåï¼Œå¼€å§‹å‘é€æŒ‡ä»¤å¹¶ç›‘å¬å“åº”
                await this.listenAndSendCommand(device, app);

            } catch (e) {
                UIManager.log(`âŒ è®¾å¤‡ ${device.id}: æµ‹è¯•å¯åŠ¨å¤±è´¥: ${e.message}`);
                this.finishTest(device, { serial: false, web: false }, app);
            }
        },

        async listenAndSendCommand(device, app) {
            let responseReceived = false;
            let timeoutId = null;

            const sendAndRetry = async (isRetry = false) => {
                if (responseReceived) return;

                const textCommand = '<1,DSN,ICC,IME>'; // ç§»é™¤äº† \r\n
                if (isRetry) {
                    UIManager.log(`è®¾å¤‡ ${device.id}: å“åº”è¶…æ—¶ï¼Œé‡è¯•ä¸€æ¬¡...`);
                    await device.serial.writer.write(new TextEncoder().encode(textCommand));
                    UIManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²é‡å‘æŒ‡ä»¤: ${textCommand.trim()}`);
                    timeoutId = setTimeout(() => {
                        if (!responseReceived) {
                            UIManager.log(`âŒ è®¾å¤‡ ${device.id}: ç¬¬äºŒæ¬¡å“åº”è¶…æ—¶`);
                            this.finishTest(device, { serial: false, web: false }, app);
                        }
                    }, config.timeouts.response);
                } else {
                    // é¦–æ¬¡å‘é€
                    const hexCommand = new Uint8Array([0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8]);
                    await device.serial.writer.write(hexCommand);
                    UIManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²å‘é€HEXæ•°æ®: f8 f8 f8 f8 f8 f8 f8 f8`);
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await device.serial.writer.write(new TextEncoder().encode(textCommand));
                    UIManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ${textCommand.trim()}`);
                    // ä¸ºé¦–æ¬¡å‘é€è®¾ç½®è¶…æ—¶
                    timeoutId = setTimeout(() => sendAndRetry(true), config.timeouts.response);
                }
            };

            device.serial.buffer = '';
            device.serial.readLoop(async (textData) => {
                if (responseReceived) return;
                device.serial.buffer += textData;
                // æ”¹è¿›äº†å“åº”æ£€æµ‹é€»è¾‘
                if (device.serial.buffer.includes('<1,DSN;') && device.serial.buffer.includes('<1,ICC;') && device.serial.buffer.includes('<1,IME;')) {
                    responseReceived = true;
                    clearTimeout(timeoutId);
                    await this.handleResponse(device, device.serial.buffer, app);
                    device.serial.buffer = '';
                    await device.serial.stopReadLoop();
                }
            }, (e) => {
                if (device.inProgress) { 
                    UIManager.log(`âŒ è®¾å¤‡ ${device.id} ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                    this.finishTest(device, { serial: false, web: false }, app);
                }
            });

            // è§¦å‘é¦–æ¬¡å‘é€
            await sendAndRetry(false);
        },

        async handleResponse(device, buffer, app) {
            const dsnMatch = buffer.match(/<1,DSN;([^>]+)>/);
            const iccMatch = buffer.match(/<1,ICC;([^>]*)>/);
            const imeMatch = buffer.match(/<1,IME;([^>]+)>/);

            const sn = dsnMatch ? dsnMatch[1].trim() : null;
            const iccid = iccMatch ? iccMatch[1].trim() : '';
            const imei = imeMatch ? imeMatch[1].trim() : null;

            if (!sn || !imei) {
                UIManager.log(`âŒ è®¾å¤‡ ${device.id}: å“åº”æ ¼å¼ä¸æ­£ç¡®: ${buffer}`);
                this.finishTest(device, { sn: 'æœªçŸ¥', serial: false, web: false }, app);
                return;
            }
            
            device.record = { timestamp: new Date().toLocaleString(), sn, imei, iccid, serial: true, web: 'pending', status: 'pending' };
            UIManager.addOrUpdateTestResult(device.record);
            UIManager.log(`âœ… è®¾å¤‡ ${device.id}: æ”¶åˆ°SN: ${sn}, IMEI: ${imei}, ICCID: ${iccid || 'æ— '}`);

            if (!iccid) {
                UIManager.log(`âš ï¸ è®¾å¤‡ ${device.id}: æœªæ’å¡`);
                device.record.iccid = 'æœªæ’å¡';
                device.record.web = 'æœªæ’å¡';
                this.finishTest(device, { ...device.record, status: true }, app);
            } else {
                await this.startWebTest(device, app);
            }
        },

        async _generateTestUrl(sn) {
            const encrypted = await DgwCrypto.encrypt("DAAN" + sn);
            return encrypted ? `${config.urls.test}${encrypted}` : null;
        },

        async startWebTest(device, app) {
            UIManager.log(`ğŸ”— è®¾å¤‡ ${device.id}: æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...`);
            const testUrl = await this._generateTestUrl(device.record.sn);

            let webResult = false;
            if (testUrl) {
                UIManager.log(`ğŸŒ è®¾å¤‡ ${device.id}: æµ‹è¯•ç½‘å€: ${testUrl}`);
                
                // å°è¯•ä¸¤æ¬¡ç½‘ç»œè®¿é—®
                for (let attempt = 1; attempt <= 2; attempt++) {
                    try {
                        if (attempt === 2) {
                            UIManager.log(`ğŸ”„ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥ï¼Œé‡è¯•ç¬¬${attempt}æ¬¡...`);
                        }
                        
                        const proxiedUrl = `https://cors.lorenzoliam.workers.dev/?url=${encodeURIComponent(testUrl)}`;
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), config.timeouts.fetch);
                        const response = await fetch(proxiedUrl, { signal: controller.signal, mode: 'cors', cache: 'no-cache' });
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            UIManager.log(`âœ… è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®æˆåŠŸ${attempt === 2 ? ' (é‡è¯•æˆåŠŸ)' : ''}`);
                            webResult = true;
                            break; // æˆåŠŸåˆ™è·³å‡ºå¾ªç¯
                        } else {
                            UIManager.log(`âŒ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥ - ${response.status}${attempt === 1 ? ' (å‡†å¤‡é‡è¯•)' : ''}`);
                        }
                    } catch (e) {
                        UIManager.log(`âŒ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}${attempt === 1 ? ' (å‡†å¤‡é‡è¯•)' : ''}`);
                    }
                    
                    // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡å°è¯•å¤±è´¥ï¼Œç­‰å¾…ä¸€å°æ®µæ—¶é—´å†é‡è¯•
                    if (attempt === 1 && !webResult) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
            } else {
                UIManager.log(`âŒ è®¾å¤‡ ${device.id}: URL ç”Ÿæˆå¤±è´¥`);
            }
            this.finishTest(device, { ...device.record, web: webResult, status: webResult }, app);
        },

        async finishTest(device, result, app) {
            device.inProgress = false;
            Object.assign(device.record, result);
            UIManager.addOrUpdateTestResult(device.record);
            UIManager.updateButtons(app);
            UIManager.log(`ğŸ“Š è®¾å¤‡ ${device.id}: æµ‹è¯•å®Œæˆ - ${result.status ? 'é€šè¿‡' : 'å¤±è´¥'}`);

            if (config.autoReport) {
                await this.reportResult(device.record);
            }

            try {
                if (device.serial.writer) {
                    UIManager.log(`è®¾å¤‡ ${device.id}: å‘é€æœ€ç»ˆæŒ‡ä»¤å¹¶å‡†å¤‡æ–­å¼€...`);
                    const hexCommand = new Uint8Array([0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8]);
                    await device.serial.writer.write(hexCommand);
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            } catch (e) {
                UIManager.log(`è®¾å¤‡ ${device.id}: å‘é€æœ€ç»ˆæŒ‡ä»¤å¤±è´¥: ${e.message}`);
            } finally {
                await app.toggleConnection(device.id, true);
            }
        },

        async reportResult(record) {
            UIManager.log(`ğŸ“® è®¾å¤‡ ${record.sn}: ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...`);
            try {
                const reportData = { deviceId: 'DGS-100', results: [{ sn: record.sn, imei: record.imei, iccid: record.iccid, serialTest: record.serial, webTest: record.web, overallStatus: record.status }] };
                
                const response = await fetch(config.urls.report, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                    body: JSON.stringify(reportData),
                    signal: AbortSignal.timeout(config.timeouts.report)
                });

                if (response.ok) {
                    UIManager.log(`âœ… è®¾å¤‡ ${record.sn}: ä¸ŠæŠ¥æˆåŠŸ`);
                    record.reported = true;
                } else {
                    throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status}`);
                }
            } catch (error) {
                UIManager.log(`âŒ è®¾å¤‡ ${record.sn}: ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
                record.reportFailed = true;
            }
            UIManager.addOrUpdateTestResult(record);
        }
    };

    // ==================================================================================
    // åº”ç”¨å¯åŠ¨
    // ==================================================================================
    if ('serial' in navigator) {
        app.init();
    } else {
        alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
        document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>';
    }
</script>
</body>
</html>
