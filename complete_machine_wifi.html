<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 æ•´æœºæµ‹è¯• (WiFiç‰ˆ)</title>
    <style>
        :root {
            --color-primary: #007bff;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-light: #f8f9fa;
            --color-dark: #343a40;
            --border-radius: 8px;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
        }
        body { font-family: system-ui, -apple-system, Roboto, sans-serif; padding: 5px 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: var(--border-radius); padding: 15px; margin: 10px 0; background: #fff; box-shadow: var(--shadow-sm); }
        .panel-blue { border-color: var(--color-primary); background: #f0f8ff; }
        .panel-green { border-color: var(--color-success); background: #f0fff0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background: #fff; border-radius: var(--border-radius); overflow: hidden; box-shadow: var(--shadow-sm); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background: var(--color-light); color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: var(--color-success); }
        .fail { background: #f8d7da; color: var(--color-danger); }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 150px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .table-container { max-height: 520px; overflow-y: auto; }
        .test-result-display {
            margin: 0; padding: 10px; border-radius: var(--border-radius); text-align: center; font-size: 30px; font-weight: bold; box-shadow: 0 3px 6px rgba(0,0,0,0.1); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            transition: background 0.3s ease, color 0.3s ease;
        }
        .test-result-display.pass { background: linear-gradient(135deg, #28a745, #20c997); color: white; border: 2px solid #1e7e34; }
        .test-result-display.fail { background: linear-gradient(135deg, #dc3545, #ff6b6b); color: white; border: 2px solid #bd2130; }
        .test-result-display.waiting { background: linear-gradient(135deg, #007bff, #3da9fc); color: white; border: 2px solid #0056b3; }
        .test-result-display.default { background: #f8f9fa; color: #6c757d; border: 2px solid #dee2e6; }
    </style>
</head>
<body>
<!-- ä¸»æ§ç•Œé¢ -->
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
    <h1 style="margin: 5px 0;">æ•´æœºæµ‹è¯• (WiFiç‰ˆ)</h1>
    <div style="display: flex; align-items: center; gap: 5px;">
        <button class="btn" id="scanWifiBtn">æ‰«æWiFi</button>
        <select id="wifiList" style="padding: 6px; width: 200px; border: 1px solid #ddd; border-radius: 4px; height: 36px;">
            <option value="">è¯·å…ˆæ‰«æ...</option>
        </select>
        <input type="text" id="wifiPass" placeholder="WiFiå¯†ç " style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 120px;">
        <button class="btn" id="connectWifiBtn">è¿æ¥WiFi</button>
        <div style="width: 1px; height: 24px; background: #ccc; margin: 0 10px;"></div>
        <button class="btn" id="switchVerisonBtn" style="background: #007bff; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°4Gç‰ˆ</button>
        <button class="btn" id="switchInterfaceBtn" style="background: #28a745; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<!-- è®¾å¤‡è¿æ¥é¢æ¿ -->
<div class="panel">
    <div class="grid">
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Aï¼ˆSERIAL-Aï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput1" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput1" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice1Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice1Btn">è¿æ¥</button>
                <div id="device1Msg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Bï¼ˆSERIAL-Bï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput2" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput2" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice2Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice2Btn">è¿æ¥</button>
                <div id="device2Msg"></div>
            </div>
        </div>
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Cï¼ˆSERIAL-Cï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput3" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput3" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice3Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice3Btn">è¿æ¥</button>
                <div id="device3Msg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Dï¼ˆSERIAL-Dï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput4" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice4Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice4Btn">è¿æ¥</button>
                <div id="device4Msg"></div>
            </div>
        </div>
    </div>
</div>

<!-- çŠ¶æ€æ˜¾ç¤º -->
 <div class="panel">
    <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin: 15px 0;">
        
        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-1" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Aæœªè¿æ¥</div>
            <div id="testResultDisplay-3" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Cæœªè¿æ¥</div>
        </div>

        <img id="deviceImage4" src="image.png" alt="è®¾å¤‡å›¾ç‰‡" style="width: 50%; border-radius: 8px; box-shadow: var(--shadow-sm);"> 

        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-2" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Bæœªè¿æ¥</div>
            <div id="testResultDisplay-4" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Dæœªè¿æ¥</div>
        </div>

    </div>
</div>
<!-- æµ‹è¯•ç»“æœè¡¨æ ¼ -->
<div class="panel">
    <div class="table-container">
        <table>
            <thead><tr><th>è®¾å¤‡å·</th><th>æ—¶é—´</th><th>SN</th><th>WIFI</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
            <tbody id="wholeMachineResultBody"></tbody>
        </table>
    </div>
</div>

<!-- æ—¥å¿— -->
<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
    (function() {
        'use strict';
        const CONFIG = {
            AES: { KEY_STRING: "me%ov2Ied|eicegh", IV_STRING: "me%ov2Ied|eicegh" },
            URLS: { TEST: "http://gw.3wlink.cn:22011/?dgwkey=", REPORT: "https://daantest.free.beeceptor.com" },
            BAUD_RATE: 115200,
            TIMEOUTS: { COMMAND: 2000, RESPONSE: 2000, WIFI_CONNECT: 5000, WIFI_CHECK: 3000, FETCH: 5000, REPORT: 10000 },
            AUTO_REPORT: true, DEVICE_COUNT: 4, RETRY_COUNT: 2, LOG_LIMIT: 100
        };

        const sleep = ms => new Promise(r => setTimeout(r, ms));
        const UI = {
            logBox: document.getElementById('logBox'),
            resultBody: document.getElementById('wholeMachineResultBody'),
            testResultDisplays: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => document.getElementById(`testResultDisplay-${i + 1}`)),
            devicePanels: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => ({
                selectBtn: document.getElementById(`selectDevice${i + 1}Btn`),
                connectBtn: document.getElementById(`connectDevice${i + 1}Btn`),
                msg: document.getElementById(`device${i + 1}Msg`),
                snInput: document.getElementById(`snInput${i + 1}`)
            })),
            wifi: {
                list: document.getElementById('wifiList'),
                pass: document.getElementById('wifiPass'),
                scanBtn: document.getElementById('scanWifiBtn'),
                connectBtn: document.getElementById('connectWifiBtn'),
                msg: document.getElementById('wifiMsg')
            }
        };

        const DgwCrypto = {
            _key: null, _iv: null,
            async init() {
                if (this._key) return;
                try {
                    const keyBytes = new TextEncoder().encode(CONFIG.AES.KEY_STRING);
                    this._iv = new TextEncoder().encode(CONFIG.AES.IV_STRING);
                    this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
                } catch (error) {
                    console.error("AES_CBCå¯†é’¥å¯¼å…¥å¤±è´¥:", error);
                    throw error;
                }
            },
            async encrypt(plainText) {
                if (!this._key) await this.init();
                try {
                    const textBytes = new TextEncoder().encode(plainText);
                    const blockSize = 16;
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    const paddedData = new Uint8Array(textBytes.length + (paddingNeeded === blockSize ? 0 : paddingNeeded));
                    paddedData.set(textBytes);
                    const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                    const truncated = new Uint8Array(encrypted).slice(0, paddedData.length);
                    return btoa(String.fromCharCode(...truncated)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                } catch (error) {
                    console.error('åŠ å¯†å¤±è´¥:', error);
                    return null;
                }
            }
        };

        class SerialManager {
            constructor(id) {
                this.id = id;
                this.port = null; this.reader = null; this.writer = null;
                this.connected = false; this.readLoopActive = false;
            }
            async select() { try { this.port = await navigator.serial.requestPort(); return true; } catch { return false; } }
            async connect() {
                if (!this.port) return false;
                try {
                    await this.port.open({ baudRate: CONFIG.BAUD_RATE });
                    this.writer = this.port.writable?.getWriter();
                    this.connected = true;
                    return true;
                } catch (e) { console.error(`è®¾å¤‡ ${this.id} è¿æ¥å¤±è´¥:`, e); return false; }
            }
            async disconnect() {
                await this.stopReadLoop();
                if (this.writer) { try { await this.writer.close(); } catch {} this.writer = null; }
                if (this.port?.readable) { try { await this.port.readable.cancel(); } catch {} }
                if (this.port) { try { await this.port.close(); } catch {} }
                this.connected = false;
            }
            async readLoop(onData) {
                if (!this.port?.readable || !this.connected) return;
                this.readLoopActive = true;
                try {
                    while (this.connected && this.readLoopActive) {
                        this.reader = this.port.readable.getReader();
                        const { value, done } = await this.reader.read();
                        this.reader.releaseLock();
                        this.reader = null;
                        if (done) break;
                        if (onData) onData(new TextDecoder().decode(value));
                    }
                } catch (e) {} finally { this.readLoopActive = false; }
            }
            async stopReadLoop() {
                this.readLoopActive = false;
                if (this.reader) try { await this.reader.cancel(); } catch {}
            }
            async send(data) {
                if (!this.writer) return;
                await this.writer.write(typeof data === 'string' ? new TextEncoder().encode(data) : data);
            }
            async enterFactory() { await this.send(new Uint8Array(8).fill(0xf8)); await sleep(50); }
            async exitFactory() { await this.enterFactory(); }
        }

        class WifiController {
            constructor(app) { this.app = app; this.scannedNetworks = []; this.isScanning = false; }
            async scan() {
                const connected = this.app.devices.filter(d => d.serial.connected);
                if (!connected.length) return alert('è¯·è‡³å°‘è¿æ¥ä¸€ä¸ªè®¾å¤‡è¿›è¡ŒWiFiæ‰«æ');
                
                this.app.uiManager.log('å¼€å§‹æ‰«æWiFi (æ‰€æœ‰è®¾å¤‡)...');
                connected.forEach(d => this.app.uiManager.updateDeviceMessage(d.id, 'æ­£åœ¨æ‰«æ...', 'info'));
                
                UI.wifi.list.innerHTML = '<option value="">æ‰«æä¸­...</option>';
                this.scannedNetworks = []; this.isScanning = true;
                this.app.uiManager.updateButtons(this.app.devices, true);

                connected.map(async (d) => {
                    await d.serial.stopReadLoop();
                    let buf = '';
                    d.serial.readLoop((text) => {
                        if (!this.isScanning) return;
                        buf += text;
                        const lines = buf.split(/[\n]+/);
                        if (lines.length > 1) {
                            buf = lines.pop();
                            lines.map(x=>x.trim()).forEach(l => {
                                const m = l.match(/ssid\s*=\s*(.*?)\s+rssi/);
                                const b = l.match(/bssid\s*=\s*([0-9A-Fa-f]+)/);
                                if (m && b && !this.scannedNetworks.find(n => n.ssid === m[1].trim())) {
                                    this.scannedNetworks.push({ ssid: m[1].trim(), bssid: b[1].trim() });
                                }
                            });
                        }
                    });
                    await d.serial.enterFactory();
                    await d.serial.send('<1,SCN>');
                });

                await sleep(3000);
                this.isScanning = false;
                for (const d of connected) {
                    await d.serial.stopReadLoop();
                    await d.serial.exitFactory();
                    this.app.uiManager.updateDeviceMessage(d.id, 'âœ… å·²è¿æ¥', 'success');
                }
                this.updateSelect();
                this.app.uiManager.log(`æ‰«æç»“æŸï¼Œæ‰¾åˆ° ${this.scannedNetworks.length} ä¸ªç½‘ç»œ`);
            }
            updateSelect() {
                UI.wifi.list.innerHTML = this.scannedNetworks.length ? '' : '<option value="">æœªæ‰¾åˆ°WiFi</option>';
                this.scannedNetworks.forEach(n => {
                    const opt = document.createElement('option');
                    opt.value = n.ssid; opt.textContent = n.ssid; opt.dataset.bssid = n.bssid;
                    UI.wifi.list.appendChild(opt);
                });
                this.app.uiManager.updateButtons(this.app.devices, false);
            }
            async connectAll() {
                const { value: ssid } = UI.wifi.list;
                const bssid = UI.wifi.list.options[UI.wifi.list.selectedIndex]?.dataset.bssid;
                const { value: pass } = UI.wifi.pass;
                if (!ssid || !bssid) return alert('è¯·å…ˆæ‰«æå¹¶é€‰æ‹©WiFi');
                
                const connected = this.app.devices.filter(d => d.serial.connected);
                if (!connected.length) return alert('æ²¡æœ‰å·²è¿æ¥çš„è®¾å¤‡');

                this.app.uiManager.log('å¼€å§‹è¿æ¥WiFi (å¹¶å‘æ‰§è¡Œ)...');
                
                const tasks = connected.map(async (d) => {
                    try {
                        this.app.uiManager.updateDeviceMessage(d.id, 'æ­£åœ¨è¿æ¥...', 'info');
                        await d.serial.stopReadLoop();
                        await d.serial.enterFactory();
                        
                        d.serial.readLoop(() => {});
                        await d.serial.send(`<1,WFI;${ssid};${pass};${bssid};1>`);
                        await sleep(CONFIG.TIMEOUTS.WIFI_CONNECT);
                        
                        let status = 0, buf = '';
                        await d.serial.stopReadLoop();
                        d.serial.readLoop(t => { 
                            buf += t;
                            if (buf.match(/<1,EVT5;(\d+);/)) status = parseInt(RegExp.$1); 
                        });
                        await d.serial.send('<1,EVT5>');
                        await sleep(CONFIG.TIMEOUTS.WIFI_CHECK);
                        
                        await d.serial.stopReadLoop();
                        if (status === 2) {
                            this.app.uiManager.updateDeviceMessage(d.id, 'WiFiå·²è¿æ¥', 'success');
                            this.app.uiManager.setWifiReady(true);
                        } else {
                            this.app.uiManager.updateDeviceMessage(d.id, status === 1 ? 'WiFiæ­£åœ¨è¿æ¥...' : 'WiFiè¿æ¥å¤±è´¥', 'error');
                        }
                        await d.serial.exitFactory();
                    } catch (e) {
                        this.app.uiManager.updateDeviceMessage(d.id, 'è¿æ¥å¼‚å¸¸', 'error');
                    }
                });

                await Promise.all(tasks);
                this.app.uiManager.log('æ‰€æœ‰è®¾å¤‡è¿æ¥ä»»åŠ¡å¤„ç†å®Œæ¯•');
                this.app.uiManager.updateButtons(this.app.devices);
            }
        }

        class UIManager {
            constructor() { this.logMessages = []; this.deviceRows = new Map(); this.isWifiReady = false; }
            setWifiReady(ready) { this.isWifiReady = ready; }
            initDeviceRows() {
                for (let i = 1; i <= CONFIG.DEVICE_COUNT; i++) {
                    const row = UI.resultBody.insertRow();
                    row.innerHTML = `<td>è®¾å¤‡${String.fromCharCode(64 + i)}</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>`;
                    this.deviceRows.set(i, row);
                }
            }
            log(msg) {
                this.logMessages.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
                if (this.logMessages.length > CONFIG.LOG_LIMIT) this.logMessages.shift();
                UI.logBox.textContent = this.logMessages.join('\n');
                UI.logBox.scrollTop = UI.logBox.scrollHeight;
            }
            updateDeviceMessage(id, text, type = 'info') {
                const el = UI.devicePanels[id - 1].msg;
                if (el) { el.textContent = text; el.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black'; }
            }
            updateButtons(devices, isScanning = false) {
                const anyConnected = devices.some(d => d.serial.connected);
                UI.wifi.scanBtn.disabled = !anyConnected || isScanning;
                UI.wifi.connectBtn.disabled = !anyConnected || !UI.wifi.list.value || isScanning;
                devices.forEach((d, i) => {
                    const p = UI.devicePanels[i];
                    p.connectBtn.textContent = d.serial.connected ? 'æ–­å¼€' : 'è¿æ¥';
                    p.connectBtn.disabled = !d.serial.connected && !d.serial.port;
                    p.selectBtn.disabled = d.inProgress;
                    p.snInput.disabled = !d.serial.connected || d.inProgress || !this.isWifiReady;
                    p.snInput.placeholder = d.serial.connected ? 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...' : 'è¯·è¿æ¥è®¾å¤‡...';
                });
            }
            addOrUpdateTestResult(r) {
                const row = this.deviceRows.get(r.deviceId);
                if (!row) return;
                const setCell = (idx, text, cls) => { row.cells[idx].textContent = text; row.cells[idx].className = cls; };
                
                if (r.errorReason === 'SNä¸åŒ¹é…') {
                    setCell(1, r.timestamp, ''); setCell(2, r.sn || 'æœªçŸ¥', 'fail'); setCell(6, 'SNä¸åŒ¹é…', 'fail');
                    for(let k=3; k<6; k++) setCell(k, '-', '');
                    return;
                }
                setCell(1, r.timestamp, '');
                setCell(2, r.sn || 'å¼‚å¸¸', r.sn ? 'pass' : 'fail');
                setCell(3, r.wifi === true ? 'æ­£å¸¸' : r.wifi === false ? 'å¼‚å¸¸' : 'å¾…æµ‹è¯•', r.wifi === true ? 'pass' : r.wifi === false ? 'fail' : '');
                setCell(4, r.serial === true ? 'æ­£å¸¸' : r.serial === false ? 'å¼‚å¸¸' : 'å¾…æµ‹è¯•', r.serial === true ? 'pass' : r.serial === false ? 'fail' : '');
                setCell(5, r.web === true ? 'æ­£å¸¸' : r.web === false ? 'å¼‚å¸¸' : 'å¾…æµ‹è¯•', r.web === true ? 'pass' : r.web === false ? 'fail' : '');
                
                const statusMap = { true: {t:'æ­£å¸¸',c:'pass'}, false: {t:'å¼‚å¸¸',c:'fail'}, pending: {t:'æ­£åœ¨æµ‹è¯•...',c:'testing'} };
                const st = statusMap[r.status] || {t:'å¾…æµ‹è¯•',c:''};
                setCell(6, st.t, st.c);

                let rep = {t:'å¾…ä¸ŠæŠ¥', c:'testing'};
                if (r.skipReport || (r.status === false && !r.sn)) rep = {t:'æœªä¸ŠæŠ¥', c:'fail'};
                else if (r.reported) rep = {t:'å·²ä¸ŠæŠ¥', c:'pass'};
                else if (r.reportFailed) rep = {t:'æœªä¸ŠæŠ¥', c:'fail'};
                else if (r.status !== 'pending' && !CONFIG.AUTO_REPORT) rep = {t:'æœªä¸ŠæŠ¥', c: r.status===false?'fail':''};
                setCell(7, rep.t, rep.c);
            }
            clearTestResult(id) {
                const row = this.deviceRows.get(id);
                if (row) for(let i=1; i<8; i++) { row.cells[i].textContent = ''; row.cells[i].className = ''; }
            }
            showTestResult(id, state, msg = null) {
                const d = UI.testResultDisplays[id-1];
                if (!d) return;
                const m = {
                    waiting: [`â³ è®¾å¤‡${String.fromCharCode(64+id)}æµ‹è¯•ä¸­...`, 'waiting'],
                    pass: [`âœ… è®¾å¤‡${String.fromCharCode(64+id)}-é€šè¿‡`, 'pass'],
                    fail: [`âŒ è®¾å¤‡${String.fromCharCode(64+id)}-ä¸é€šè¿‡`, 'fail'],
                    'no-device': [`âŒ è®¾å¤‡${String.fromCharCode(64+id)}-æœªæ’å…¥`, 'fail'],
                    connected: [`ç«¯å£${String.fromCharCode(64+id)}å·²è¿æ¥`, 'default'],
                    disconnected: [`ç«¯å£${String.fromCharCode(64+id)}æœªè¿æ¥`, 'default']
                };
                const [t, c] = m[state] || m.disconnected;
                d.textContent = msg || t; d.className = `test-result-display ${c}`;
            }
        }

        class App {
            constructor(ui) {
                this.uiManager = ui;
                this.devices = Array.from({length:CONFIG.DEVICE_COUNT}, (_,i)=>({id:i+1, serial:new SerialManager(i+1), inProgress:false, record:null}));
                this.wifiController = new WifiController(this);
                this.testRunner = new TestRunner(this.uiManager);
            }
            async init() {
                try { await DgwCrypto.init(); } catch { return alert('åŠ å¯†æ¨¡å—å¤±è´¥'), this.uiManager.log('âŒ åŠ å¯†å¤±è´¥'); }
                this.uiManager.initDeviceRows();
                this.setupEvents();
                await this.loadPorts();
                this.uiManager.updateButtons(this.devices);
                this.uiManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
            }
            setupEvents() {
                this.devices.forEach(d => {
                    const p = UI.devicePanels[d.id-1];
                    p.selectBtn.onclick = () => this.selectPort(d.id);
                    p.connectBtn.onclick = () => this.toggleConn(d.id);
                    p.snInput.addEventListener('keydown', e => {   
                        if (e.key === 'Enter') {                   
                            e.preventDefault();                    
                            this.startTest(d.id);                  
                        }                                          
                    });                                            
                });
                UI.wifi.scanBtn.onclick = () => this.wifiController.scan();
                UI.wifi.connectBtn.onclick = () => this.wifiController.connectAll();
                UI.wifi.list.onchange = UI.wifi.pass.oninput = () => this.uiManager.updateButtons(this.devices, this.wifiController.isScanning);
                document.getElementById('switchInterfaceBtn').onclick = () => location.href = `wifi_tool.html?v=${Date.now()}`;
                document.getElementById('switchVerisonBtn').onclick = () => location.href = `complete_machine.html?v=${Date.now()}`;
            }
            async startTest(id) {
                const d = this.devices[id-1], sn = UI.devicePanels[id-1].snInput.value.trim();
                if (d.inProgress || !d.serial.connected) return;
                if (sn.length !== 20) return this.uiManager.updateDeviceMessage(id, 'âŒ SNé”™è¯¯', 'error');
                this.uiManager.updateDeviceMessage(id, 'âœ… å·²è¿æ¥', 'success');
                this.testRunner.run(d, this, sn);
            }
            async loadPorts() {
                const ports = await navigator.serial.getPorts();
                this.devices.forEach(d => {
                    const idx = localStorage.getItem(`serialPort_device_${d.id}`);
                    if (idx && ports[idx]) { d.serial.port = ports[idx]; this.uiManager.updateDeviceMessage(d.id, 'âœ… ä¸²å£å·²åŠ è½½'); }
                });
            }
            async selectPort(id) {
                const d = this.devices[id-1];
                if (await d.serial.select()) {
                    this.uiManager.updateDeviceMessage(id, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
                    const ports = await navigator.serial.getPorts();
                    const idx = ports.indexOf(d.serial.port);
                    if (idx > -1) localStorage.setItem(`serialPort_device_${id}`, idx);
                }
                this.uiManager.updateButtons(this.devices);
            }
            async toggleConn(id) {
                const d = this.devices[id-1];
                if (d.serial.connected) {
                    if (d.inProgress) { this.testRunner.cancel(d); this.uiManager.log(`ğŸ›‘ è®¾å¤‡ ${d.id}: ç”¨æˆ·æ‰‹åŠ¨æ–­å¼€ï¼Œæµ‹è¯•å·²ä¸­æ–­`); }
                    await d.serial.disconnect();
                    this.uiManager.updateDeviceMessage(id, 'â„¹ï¸ å·²æ–­å¼€');
                    UI.devicePanels[d.id-1].snInput.value = '';
                    d.record = null; this.uiManager.showTestResult(id, 'disconnected'); this.uiManager.clearTestResult(id);
                } else {
                    this.uiManager.updateDeviceMessage(id, 'âŒ› è¿æ¥ä¸­...');
                    if (await d.serial.connect()) {
                        this.uiManager.updateDeviceMessage(id, 'âœ… å·²è¿æ¥', 'success');
                        this.uiManager.showTestResult(id, 'connected');
                    } else this.uiManager.updateDeviceMessage(id, 'âŒ è¿æ¥å¤±è´¥', 'error');
                }
                this.uiManager.updateButtons(this.devices);
            }
        }

        class TestRunner {
            constructor(ui) { this.uiManager = ui; }
            cancel(d) {
                d.inProgress = false;
                if (d.record) this.uiManager.clearTestResult(d.id);
                d.record = null;
            }
            async run(d, app, sn) {
                const { value: ssid } = UI.wifi.list, bssid = UI.wifi.list.options[UI.wifi.list.selectedIndex]?.dataset.bssid;
                if (!ssid || !bssid) return this.uiManager.showTestResult(d.id, 'fail', 'WiFiæœªé…ç½®');

                this.uiManager.clearTestResult(d.id);
                d.record = null; d.inProgress = true; d.enteredSn = sn;
                this.uiManager.showTestResult(d.id, 'waiting');
                this.uiManager.updateButtons(app.devices);

                await sleep(CONFIG.TIMEOUTS.COMMAND);
                if (!d.inProgress) return;

                // Step 1: SN
                this.uiManager.log(`è®¾å¤‡ ${d.id}: è·å–è®¾å¤‡ä¿¡æ¯...`);
                let buf = '', gotInfo = false;
                d.serial.readLoop(t => { if (!gotInfo) { buf += t; if (buf.includes('<1,DSN;')) gotInfo = true; }});
                
                for(let i=0; i<=CONFIG.RETRY_COUNT && !gotInfo; i++) {
                    if (!d.inProgress) return;
                    if (i===0) await d.serial.enterFactory();
                    if (i>0) { this.uiManager.log(`è®¾å¤‡ ${d.id}: è·å–ä¿¡æ¯é‡è¯•...`); }
                    await d.serial.send('<1,DSN>');
                    await sleep(CONFIG.TIMEOUTS.RESPONSE);
                }
                await d.serial.stopReadLoop();
                if (!d.inProgress) return;

                if (!gotInfo) return this.finish(d, {sn:null, serial:false, wifi:false, web:false, status:false}, app);

                const devSn = buf.match(/<1,DSN;([^>]+)>/)?.[1]?.trim();
                if (devSn !== sn) return this.finish(d, {sn:devSn, serial:true, status:false, errorReason:'SNä¸åŒ¹é…', skipReport:true}, app);
                if (!devSn) return this.finish(d, {sn:null, serial:true, status:false, skipReport:true}, app);

                this.uiManager.log(`âœ… è®¾å¤‡ ${d.id}: æ”¶åˆ°SN: ${devSn}`);
                d.record = { deviceId:d.id, timestamp:new Date().toLocaleString(), sn:devSn, wifi:'pending', serial:'pending', web:'pending', status:'pending' };
                this.uiManager.addOrUpdateTestResult(d.record);

                // Step 2: WiFi
                this.uiManager.log(`è®¾å¤‡ ${d.id}: å‘é€é…ç½‘æŒ‡ä»¤...`);
                await d.serial.send(`<1,WFI;${ssid};${UI.wifi.pass.value};${bssid};1>`);
                if (!d.inProgress) return;
                await sleep(CONFIG.TIMEOUTS.WIFI_CONNECT);
                
                let wStat = 0, cBuf = '';
                this.uiManager.log(`è®¾å¤‡ ${d.id}: æ£€æŸ¥WiFiçŠ¶æ€...`);
                await d.serial.stopReadLoop(); // Safety clear
                d.serial.readLoop(t => { cBuf+=t; if (cBuf.match(/<1,EVT5;(\d+);/)) wStat = parseInt(RegExp.$1); });
                await d.serial.send('<1,EVT5>');
                if (!d.inProgress) return;
                await sleep(CONFIG.TIMEOUTS.WIFI_CHECK);
                await d.serial.stopReadLoop();
                
                if (!d.inProgress) return;

                if (wStat === 2) {
                     this.uiManager.log(`âœ… è®¾å¤‡ ${d.id}: WiFiè¿æ¥ç¡®è®¤ (å·²è¿æ¥)`);
                     d.record.wifi = true; d.record.serial = true;
                     this.uiManager.addOrUpdateTestResult(d.record);
                } else {
                    const r = wStat===1?'WiFiæ­£åœ¨è¿æ¥...':'WiFiæœªè¿æ¥';
                    this.uiManager.log(`âŒ è®¾å¤‡ ${d.id}: WiFiçŠ¶æ€æ£€æŸ¥å¤±è´¥ (${r})`);
                    d.record.wifi = false;
                    return this.finish(d, {status:false, errorReason: r, serial:true}, app);
                }

                // Step 3: Web
                this.uiManager.log(`ğŸ”— è®¾å¤‡ ${d.id}: æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...`);
                const url = await this._genUrl(d.record.sn);
                let web = false;
                if (url) {
                    this.uiManager.log(`ğŸŒ è®¾å¤‡ ${d.id}: æµ‹è¯•ç½‘å€: ${url}`);
                    for(let i=0; i<=CONFIG.RETRY_COUNT && !web; i++) {
                        if (!d.inProgress) return;
                        try {
                            const res = await fetch(`https://cors.lorens.qzz.io/?url=${encodeURIComponent(url)}`, {signal:AbortSignal.timeout(CONFIG.TIMEOUTS.FETCH), mode:'cors', cache:'no-cache'});
                            if (res.ok) { this.uiManager.log(`âœ… è®¾å¤‡ ${d.id}: ç½‘ç»œè®¿é—®æˆåŠŸ`); web = true; }
                            else throw 1;
                        } catch {
                             this.uiManager.log(`âŒ è®¾å¤‡ ${d.id}: ç½‘ç»œè®¿é—®å¤±è´¥`);
                             if(i<CONFIG.RETRY_COUNT) await sleep(1000); 
                        }
                    }
                }
                if (!d.inProgress) return;
                this.finish(d, {web, status:web}, app);
            }
            async finish(d, res, app) {
                d.inProgress = false;
                const base = { deviceId: d.id, timestamp: new Date().toLocaleString(), sn:null, wifi:false, serial:false, web:false, status:false };
                d.record = { ...base, ...d.record, ...res };
                this.uiManager.addOrUpdateTestResult(d.record);
                
                const ok = d.record.status === true;
                const noDev = !d.record.sn;
                this.uiManager.showTestResult(d.id, ok ? 'pass' : (noDev ? 'no-device' : 'fail'), res.errorReason);
                this.uiManager.updateButtons(app.devices);
                this.uiManager.log(`ğŸ“Š è®¾å¤‡ ${d.id}: æµ‹è¯•å®Œæˆ - ${ok?'é€šè¿‡':'å¤±è´¥'}`);
                
                if (CONFIG.AUTO_REPORT && !d.record.skipReport) await this.report(d.record);
                try { await d.serial.enterFactory(); } catch {} 
                UI.devicePanels[d.id-1].snInput.value = '';
            }
            async report(r) {
                if (!r.sn) return;
                this.uiManager.log(`ğŸ“® è®¾å¤‡ ${r.sn}: æ­£åœ¨ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...`);
                try {
                    const res = await fetch(CONFIG.URLS.REPORT, {
                        method: 'POST', headers: {'Content-Type':'application/json', 'User-Agent': 'DGS-100-Tester/1.0'},
                        body: JSON.stringify({ deviceId:'DGS-100', results:[{sn:r.sn, wifiTest:r.wifi?'pass':'fail', serialTest:r.serial?'pass':'fail', webTest:r.web?'pass':'fail', overallStatus:r.status?'pass':'fail'}] }),
                        signal: AbortSignal.timeout(CONFIG.TIMEOUTS.REPORT)
                    });
                    if (res.ok) { r.reported = true; this.uiManager.log(`âœ… è®¾å¤‡ ${r.sn}: ä¸ŠæŠ¥æˆåŠŸ`); } else throw 1;
                } catch (e) { r.reportFailed = true; this.uiManager.log(`âŒ è®¾å¤‡ ${r.sn}: ç»“æœä¸ŠæŠ¥å¤±è´¥: ${e.message||''}`); } 
                this.uiManager.addOrUpdateTestResult(r);
            }
            async _genUrl(sn) { const e = await DgwCrypto.encrypt("DAAN"+sn); return e ? `${CONFIG.URLS.TEST}${e}` : null; }
        }

        if ('serial' in navigator) new App(new UIManager()).init();
        else alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚');
    })();
</script>
</body>
</html>