<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 æ•´æœºæµ‹è¯• (WiFiç‰ˆ)</title>
    <style>
        :root {
            --color-primary: #007bff;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-light: #f8f9fa;
            --color-dark: #343a40;
            --border-radius: 8px;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
        }
        body { font-family: system-ui, -apple-system, Roboto, sans-serif; padding: 5px 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: var(--border-radius); padding: 15px; margin: 10px 0; background: #fff; box-shadow: var(--shadow-sm); }
        .panel-blue { border-color: var(--color-primary); background: #f0f8ff; }
        .panel-green { border-color: var(--color-success); background: #f0fff0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background: #fff; border-radius: var(--border-radius); overflow: hidden; box-shadow: var(--shadow-sm); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background: var(--color-light); color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: var(--color-success); }
        .fail { background: #f8d7da; color: var(--color-danger); }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 160px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .table-container { max-height: 520px; overflow-y: auto; }
        .test-result-display {
            margin: 0; padding: 10px; border-radius: var(--border-radius); text-align: center; font-size: 30px; font-weight: bold; box-shadow: 0 3px 6px rgba(0,0,0,0.1); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            transition: background 0.3s ease, color 0.3s ease;
        }
        .test-result-display.pass { background: linear-gradient(135deg, #28a745, #20c997); color: white; border: 2px solid #1e7e34; }
        .test-result-display.fail { background: linear-gradient(135deg, #dc3545, #ff6b6b); color: white; border: 2px solid #bd2130; }
        .test-result-display.waiting { background: linear-gradient(135deg, #007bff, #3da9fc); color: white; border: 2px solid #0056b3; }
        .test-result-display.default { background: #f8f9fa; color: #6c757d; border: 2px solid #dee2e6; }
    </style>
</head>
<body>
<!-- ä¸»æ§ç•Œé¢ -->
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
    <h1 style="margin: 5px 0;">æ•´æœºæµ‹è¯• (WiFiç‰ˆ)</h1>
    <div style="display: flex; align-items: center; gap: 5px;">
        <button class="btn" id="scanWifiBtn">æ‰«æWiFi</button>
        <select id="wifiList" style="padding: 6px; width: 200px; border: 1px solid #ddd; border-radius: 4px; height: 36px;">
            <option value="">è¯·å…ˆæ‰«æ...</option>
        </select>
        <input type="text" id="wifiPass" placeholder="WiFiå¯†ç " style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 120px;">
        <button class="btn" id="connectWifiBtn">è¿æ¥WiFi</button>
        <div style="width: 1px; height: 24px; background: #ccc; margin: 0 10px;"></div>
        <button class="btn" id="switchVerisonBtn" style="background: #007bff; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°4Gç‰ˆ</button>
        <button class="btn" id="switchInterfaceBtn" style="background: #28a745; color: #fff; font-weight: 600; margin-left: 15px;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<!-- è®¾å¤‡è¿æ¥é¢æ¿ -->
<div class="panel">
    <div class="grid">
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Aï¼ˆSERIAL-Aï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput1" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput1" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice1Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice1Btn">è¿æ¥</button>
                <div id="device1Msg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Bï¼ˆSERIAL-Bï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput2" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput2" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice2Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice2Btn">è¿æ¥</button>
                <div id="device2Msg"></div>
            </div>
        </div>
        <div class="panel panel-green">
            <h2 style="margin: 5px 0;">è®¾å¤‡Cï¼ˆSERIAL-Cï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput3" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput3" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice3Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice3Btn">è¿æ¥</button>
                <div id="device3Msg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h2 style="margin: 5px 0;">è®¾å¤‡Dï¼ˆSERIAL-Dï¼‰</h2>
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                <label for="snInput4" style="margin-right: 5px; font-weight: bold; font-size: 30px;">SN:</label>
                <input type="text" id="snInput4" placeholder="è¯·è¿æ¥è®¾å¤‡..." style="flex-grow: 1; padding: 10px; font-size: 24px; min-width: 0; box-sizing: border-box;" disabled>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="btn" id="selectDevice4Btn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="connectDevice4Btn">è¿æ¥</button>
                <div id="device4Msg"></div>
            </div>
        </div>
    </div>
</div>

<!-- çŠ¶æ€æ˜¾ç¤º -->
 <div class="panel">
    <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin: 15px 0;">
        
        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-1" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Aæœªè¿æ¥</div>
            <div id="testResultDisplay-3" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Cæœªè¿æ¥</div>
        </div>

        <img id="deviceImage4" src="image.png" alt="è®¾å¤‡å›¾ç‰‡" style="width: 50%; border-radius: 8px; box-shadow: var(--shadow-sm);"> 

        <div style="display: flex; justify-content: center; width: 100%;">
            <div id="testResultDisplay-2" class="test-result-display default" style="width: 250px; margin-left: 150px;">ç«¯å£Bæœªè¿æ¥</div>
            <div id="testResultDisplay-4" class="test-result-display default" style="width: 250px; margin-left: 160px;">ç«¯å£Dæœªè¿æ¥</div>
        </div>

    </div>
</div>
<!-- æµ‹è¯•ç»“æœè¡¨æ ¼ -->
<div class="panel">
    <div class="table-container">
        <table>
            <thead><tr><th>è®¾å¤‡å·</th><th>æ—¶é—´</th><th>SN</th><th>WIFI</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead>
            <tbody id="wholeMachineResultBody"></tbody>
        </table>
    </div>
</div>

<!-- æ—¥å¿— -->
<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>

    (function() {
        'use strict';
        const CONFIG = {
            AES: { KEY_STRING: "me%ov2Ied|eicegh", IV_STRING: "me%ov2Ied|eicegh" },
            URLS: { TEST: "http://gw.3wlink.cn:22011/?dgwkey=", REPORT: "https://daantest.free.beeceptor.com" },
            BAUD_RATE: 115200,
            TIMEOUTS: { 
                COMMAND: 2000, 
                RESPONSE: 2000, 
                WIFI_CONNECT: 5000,
                WIFI_CHECK: 3000,
                FETCH: 5000, 
                REPORT: 10000 , 
                TEST_URL_WAIT: 5000
            },
            AUTO_REPORT: true,
            DEVICE_COUNT: 4,
            RETRY_COUNT: 2,
            LOG_LIMIT: 100,
        };

        const UI = {
            logBox: document.getElementById('logBox'),
            resultBody: document.getElementById('wholeMachineResultBody'),
            testResultDisplays: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => document.getElementById(`testResultDisplay-${i + 1}`)),
            devicePanels: Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => ({
                selectBtn: document.getElementById(`selectDevice${i + 1}Btn`),
                connectBtn: document.getElementById(`connectDevice${i + 1}Btn`),
                msg: document.getElementById(`device${i + 1}Msg`),
                snInput: document.getElementById(`snInput${i + 1}`)
            })),
            wifi: {
                list: document.getElementById('wifiList'),
                pass: document.getElementById('wifiPass'),
                scanBtn: document.getElementById('scanWifiBtn'),
                connectBtn: document.getElementById('connectWifiBtn'),
                msg: document.getElementById('wifiMsg')
            }
        };

        /**
         * AES åŠ å¯†å·¥å…· 
         */
        const DgwCrypto = {
            _key: null, _iv: null,
            async init() {
                if (this._key) return;
                try {
                    const keyBytes = new TextEncoder().encode(CONFIG.AES.KEY_STRING);
                    this._iv = new TextEncoder().encode(CONFIG.AES.IV_STRING);
                    this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
                } catch (error) {
                    console.error("AES_CBCå¯†é’¥å¯¼å…¥å¤±è´¥:", error);
                    throw error;
                }
            },
            async encrypt(plainText) {
                if (!this._key) await this.init();
                try {
                    const textBytes = new TextEncoder().encode(plainText);
                    const blockSize = 16;
                    const paddingNeeded = blockSize - (textBytes.length % blockSize);
                    const paddedData = new Uint8Array(textBytes.length + (paddingNeeded === blockSize ? 0 : paddingNeeded));
                    paddedData.set(textBytes);
                    const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
                    const truncated = new Uint8Array(encrypted).slice(0, paddedData.length);
                    return btoa(String.fromCharCode(...truncated)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                } catch (error) {
                    console.error('åŠ å¯†å¤±è´¥:', error);
                    return null;
                }
            }
        };

        /**
         * ç®¡ç†ä¸²å£çš„è¿æ¥ã€è¯»å†™å’Œæ–­å¼€ã€‚
         */
        class SerialManager {
            constructor(id) {
                this.id = id;
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.connected = false;
                this.readLoopActive = false;
            }
            async select() {
                try {
                    this.port = await navigator.serial.requestPort();
                    return true;
                } catch {
                    return false;
                }
            }
            async connect(baudRate) {
                if (!this.port) return false;
                try {
                    await this.port.open({ baudRate });
                    this.writer = this.port.writable?.getWriter();
                    this.connected = true;
                    return true;
                } catch (e) {
                    console.error(`è®¾å¤‡ ${String.fromCharCode(64 + this.id)} è¿æ¥å¤±è´¥:`, e);
                    return false;
                }
            }
            async disconnect() {
                await this.stopReadLoop();
                if (this.writer) {
                    try { await this.writer.close(); } catch {}
                    this.writer = null;
                }
                if (this.port?.readable) {
                    try { await this.port.readable.cancel(); } catch {}
                }
                if (this.port) {
                    try { await this.port.close(); } catch {}
                }
                this.connected = false;
            }
            async readLoop(onData, onError) {
                if (!this.port?.readable || !this.connected) return;
                this.readLoopActive = true;
                try {
                    while (this.connected && this.readLoopActive) {
                        this.reader = this.port.readable.getReader();
                        const { value, done } = await this.reader.read();
                        this.reader.releaseLock();
                        this.reader = null;
                        if (done) break;
                        if (onData) onData(new TextDecoder().decode(value));
                    }
                } catch (e) {
                    if (this.readLoopActive && onError) onError(e);
                } finally {
                    this.readLoopActive = false;
                }
            }
            async stopReadLoop() {
                if (this.readLoopActive) {
                    this.readLoopActive = false;
                    if (this.reader) {
                        try { await this.reader.cancel(); } catch {}
                    }
                }
            }
            
            async write(data) {
                 if (!this.writer) return;
                 const enc = typeof data === 'string' ? new TextEncoder().encode(data) : data;
                 await this.writer.write(enc);
            }
        }

        /**
         * WiFi æ§åˆ¶å™¨
         */
        class WifiController {
            constructor(app) {
                this.app = app;
                this.scannedNetworks = [];
                this.isScanning = false;
            }
            
            async scan() {
                const connectedDevices = this.app.devices.filter(d => d.serial.connected);
                if (connectedDevices.length === 0) {
                    alert('è¯·è‡³å°‘è¿æ¥ä¸€ä¸ªè®¾å¤‡è¿›è¡ŒWiFiæ‰«æ');
                    return;
                }
                
                this.app.uiManager.log('å¼€å§‹æ‰«æWiFi (æ‰€æœ‰è®¾å¤‡)...');
                
                // åœ¨å·²è¿æ¥è®¾å¤‡ä¸Šæ˜¾ç¤ºæ‰«æçŠ¶æ€
                connectedDevices.forEach(d => {
                    this.app.uiManager.updateDeviceMessage(d.id, 'æ­£åœ¨æ‰«æ...', 'info');
                });

                UI.wifi.list.innerHTML = '<option value="">æ‰«æä¸­...</option>';
                this.scannedNetworks = [];
                this.isScanning = true;
                this.app.uiManager.updateButtons(this.app.devices, true);
                
                const ssidRx = /ssid\s*=\s*(.*?)\s+rssi/;
                const bssidRx = /bssid\s*=\s*([0-9A-Fa-f]+)/;

                // åœæ­¢æ‰€æœ‰ä¹‹å‰çš„è¯»å–å¹¶å¼€å§‹æ‰«æ
                const scanPromises = connectedDevices.map(async (device) => {
                    await device.serial.stopReadLoop();
                    
                    let buffer = '';
                    const onData = (text) => {
                        if (!this.isScanning) return;
                        buffer += text;
                        const lines = buffer.split(/[\n]+/);
                        if (lines.length > 1) {
                            buffer = lines.pop(); 
                            for (const l of lines.map(x=>x.trim()).filter(x=>x)) {
                                const m = l.match(ssidRx); 
                                const b = l.match(bssidRx); 
                                if (m && b && !this.scannedNetworks.find(n => n.ssid === m[1].trim())) {
                                    this.scannedNetworks.push({ ssid: m[1].trim(), bssid: b[1].trim() });
                                }
                            }
                        }
                        
                        // å¦‚æœæ‰¾åˆ°æ•°æ®åˆ™ç«‹å³å¡«å……
                        //if (this.scannedNetworks.length > 0) {
                             //this.updateSelect();
                        //}
                    };
                    
                    device.serial.readLoop(onData, (e) => console.error(`Device ${device.id} scan error:`, e));
                    
                    // è¿›å…¥å·¥å‚æ¨¡å¼
                    await device.serial.write(new Uint8Array(8).fill(0xf8));
                    await new Promise(resolve => setTimeout(resolve, 50));

                    await device.serial.write('<1,SCN>');
                });
                
                // è®¾ç½®è¶…æ—¶ä»¥åœæ­¢æ‰«æ
                setTimeout(async () => {
                    this.isScanning = false;
                    for (const d of connectedDevices) {
                        await d.serial.stopReadLoop();
                        
                        // é€€å‡ºå·¥å‚æ¨¡å¼
                        await d.serial.write(new Uint8Array(8).fill(0xf8));
                        await new Promise(resolve => setTimeout(resolve, 50));

                        this.app.uiManager.updateDeviceMessage(d.id, 'âœ… å·²è¿æ¥', 'success'); // æ¢å¤çŠ¶æ€
                    }
                    this.updateSelect();
                    this.app.uiManager.updateButtons(this.app.devices, false);
                    this.app.uiManager.log(`æ‰«æç»“æŸï¼Œæ‰¾åˆ° ${this.scannedNetworks.length} ä¸ªç½‘ç»œ`);
                }, 3000); // 3ç§’æ‰«æçª—å£
            }
            
            updateSelect() {
                 const currentVal = UI.wifi.list.value;
                 UI.wifi.list.innerHTML = '';
                 if (this.scannedNetworks.length === 0) {
                     UI.wifi.list.innerHTML = '<option value="">æœªæ‰¾åˆ°WiFi</option>';
                 } else {
                     this.scannedNetworks.forEach(n => {
                         const opt = document.createElement('option');
                         opt.value = n.ssid; 
                         opt.textContent = n.ssid;
                         opt.dataset.bssid = n.bssid;
                         UI.wifi.list.appendChild(opt);
                     });
                     if (currentVal) UI.wifi.list.value = currentVal;
                 }
                 this.app.uiManager.updateButtons(this.app.devices, this.isScanning);
            }
            
            async connectAll() {
                const ssid = UI.wifi.list.value;
                const pass = UI.wifi.pass.value;
                const bssid = UI.wifi.list.options[UI.wifi.list.selectedIndex]?.dataset.bssid;
                
                if (!ssid || !bssid) {
                    alert('è¯·å…ˆæ‰«æå¹¶é€‰æ‹©WiFi');
                    return;
                }
                
                const cmd = `<1,WFI;${ssid};${pass};${bssid};1>`;
                const connectedDevices = this.app.devices.filter(d => d.serial.connected);
                 if (connectedDevices.length === 0) {
                    alert('æ²¡æœ‰å·²è¿æ¥çš„è®¾å¤‡');
                    return;
                }
                
                this.app.uiManager.log('å¼€å§‹è¿æ¥WiFi (æ‰€æœ‰è®¾å¤‡)...');
                
                connectedDevices.forEach(async (device) => {
                    this.app.uiManager.updateDeviceMessage(device.id, 'æ­£åœ¨è¿æ¥...', 'info');
                    await device.serial.stopReadLoop();
                    
                    // è¿›å…¥å·¥å‚æ¨¡å¼
                    await device.serial.write(new Uint8Array(8).fill(0xf8));
                    await new Promise(resolve => setTimeout(resolve, 50));

                    let responseReceived = false;
                    const onData = (text) => {
                        if (text.trim().length > 0) responseReceived = true;
                    };
                    device.serial.readLoop(onData, (e) => {});
                    
                    // å‘é€è¿æ¥
                    await device.serial.write(cmd);
                    
                    // ç­‰å¾…è¿æ¥
                    await new Promise(r => setTimeout(r, CONFIG.TIMEOUTS.WIFI_CONNECT));
                    
                    // å‘é€æŸ¥è¯¢
                    let wifiStatus = 0; // 0:æœªçŸ¥/æ–­å¼€, 1:è¿æ¥ä¸­, 2:å·²è¿æ¥
                    let checkBuffer = '';
                    await device.serial.stopReadLoop();

                    const onCheckData = (text) => {
                        checkBuffer += text;
                        const match = checkBuffer.match(/<1,EVT5;(\d+);/);
                        if (match) {
                             wifiStatus = parseInt(match[1], 10);
                        }
                    };
                    device.serial.readLoop(onCheckData, (e) => {});

                    await device.serial.write('<1,EVT5>');
                    
                    // ç­‰å¾…æŸ¥è¯¢å“åº”
                    await new Promise(r => setTimeout(r, CONFIG.TIMEOUTS.WIFI_CHECK));
                    
                    await device.serial.stopReadLoop();
                    
                    if (wifiStatus === 2) {
                         this.app.uiManager.updateDeviceMessage(device.id, 'WiFiå·²è¿æ¥', 'success');
                         this.app.uiManager.setWifiReady(true);
                         this.app.uiManager.updateButtons(this.app.devices);
                    } else {
                         const msg = wifiStatus === 1 ? 'WiFiæ­£åœ¨è¿æ¥...' : 'WiFiè¿æ¥å¤±è´¥';
                         const type = wifiStatus === 1 ? 'info' : 'error';
                         this.app.uiManager.updateDeviceMessage(device.id, msg, type);
                    }
                    // é€€å‡ºå·¥å‚æ¨¡å¼
                    await device.serial.write(new Uint8Array(8).fill(0xf8));
                    await new Promise(resolve => setTimeout(resolve, 50));
                });
            }
        }

        /**
         * ç®¡ç†æ‰€æœ‰UIæ›´æ–°
         */
        class UIManager {
            constructor() {
                this.logMessages = [];
                this.deviceRows = new Map();
                this.isWifiReady = false;
            }

            setWifiReady(ready) {
                this.isWifiReady = ready;
            }

            initDeviceRows() {
                for (let i = 1; i <= CONFIG.DEVICE_COUNT; i++) {
                    const row = UI.resultBody.insertRow();
                    row.id = `device-row-${i}`;
                    // Cols: Device, Time, SN, WIFI, Serial, Web, Result, Report
                    for (let j = 0; j < 8; j++) row.insertCell();
                    row.cells[0].textContent = `è®¾å¤‡${String.fromCharCode(64 + i)}`;
                    this.deviceRows.set(i, row);
                }
            }

            log(msg) {
                const timestamp = new Date().toLocaleTimeString();
                this.logMessages.push(`[${timestamp}] ${msg}`);
                if (this.logMessages.length > CONFIG.LOG_LIMIT) {
                    this.logMessages.shift();
                }
                UI.logBox.textContent = this.logMessages.join('\n');
                UI.logBox.scrollTop = UI.logBox.scrollHeight;
            }

            updateDeviceMessage(id, text, type = 'info') {
                const el = UI.devicePanels[id - 1].msg;
                if (!el) return;
                el.textContent = text;
                el.style.color = { error: 'red', success: 'green' }[type] || 'black';
            }

            updateButtons(devices, isScanning = false) {
                const anyConnected = devices.some(d => d.serial.connected);
                const ssid = UI.wifi.list.value;
                const pass = UI.wifi.pass.value;

                UI.wifi.scanBtn.disabled = !anyConnected || isScanning;
                UI.wifi.connectBtn.disabled = !anyConnected || !ssid || isScanning; // || pass.length < 8 

                devices.forEach((device, i) => {
                    const panel = UI.devicePanels[i];
                    const isConnected = device.serial.connected;

                    panel.connectBtn.textContent = isConnected ? 'æ–­å¼€' : 'è¿æ¥';
                    panel.connectBtn.disabled = !device.serial.connected && !device.serial.port;
                    panel.selectBtn.disabled = device.inProgress;
                    
                    panel.snInput.disabled = !isConnected || device.inProgress || !this.isWifiReady;
                    if (isConnected) {
                        panel.snInput.placeholder = 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...';
                    } else {
                        panel.snInput.placeholder = 'è¯·è¿æ¥è®¾å¤‡...';
                    }
                });
            }

            addOrUpdateTestResult(record) {
                const row = this.deviceRows.get(record.deviceId);
                if (!row) return;

                if (record.errorReason === 'SNä¸åŒ¹é…') {
                    row.cells[1].textContent = record.timestamp;
                    row.cells[2].textContent = record.sn || 'æœªçŸ¥';
                    row.cells[2].className = 'fail';
                    for(let i=3; i<8; i++) { row.cells[i].textContent = '-'; row.cells[i].className = ''; }
                    row.cells[6].textContent = 'SNä¸åŒ¹é…';
                    row.cells[6].className = 'fail';
                    return;
                }

                const getStatusDisplay = (val) => {
                    if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
                    if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
                    return { text: 'å¾…æµ‹è¯•', className: '' };
                };
                
                const getWifiDisplay = (val) => {
                    if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
                    if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
                    return { text: 'å¾…æµ‹è¯•', className: '' };
                }

                const getInfoCell = (value, failText = 'å¼‚å¸¸') => ({
                    text: value || failText,
                    className: value ? 'pass' : 'fail'
                });

                const getReportStatusCell = (record) => {
                    if (record.skipReport) {
                        return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    }
                    if (record.reported) {
                        return { text: 'å·²ä¸ŠæŠ¥', className: 'pass' };
                    }
                    if (record.reportFailed) {
                        return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    }
                    if (record.status !== 'pending' && !CONFIG.AUTO_REPORT) {
                        return { text: 'æœªä¸ŠæŠ¥', className: record.status === false ? 'fail' : '' };
                    }
                    if (record.status === false && !record.sn) {
                        return { text: 'æœªä¸ŠæŠ¥', className: 'fail' };
                    }
                    return { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' };
                };

                // Cols: Device, Time, SN, WIFI, Serial, Web, Result, Report
                const columns = [
                    { text: `è®¾å¤‡${String.fromCharCode(64 + record.deviceId)}` },
                    { text: record.timestamp },
                    getInfoCell(record.sn),
                    getWifiDisplay(record.wifi),
                    getStatusDisplay(record.serial),
                    getStatusDisplay(record.web),
                    record.status === 'pending' ? { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' } : getStatusDisplay(record.status),
                    getReportStatusCell(record)
                ];

                columns.forEach((col, i) => {
                    row.cells[i].textContent = col.text ?? '';
                    row.cells[i].className = col.className ?? '';
                });
            }

            clearTestResult(deviceId) {
                const row = this.deviceRows.get(deviceId);
                if (row) {
                    for (let i = 1; i < row.cells.length; i++) {
                        row.cells[i].textContent = '';
                        row.cells[i].className = '';
                    }
                }
            }

            showTestResult(deviceId, state, message = null) {
                const display = UI.testResultDisplays[deviceId - 1];
                if (!display) return;

                const states = {
                    waiting: { text: `â³ è®¾å¤‡${String.fromCharCode(64 + deviceId)}æµ‹è¯•ä¸­...`, className: 'waiting' },
                    pass: { text: `âœ… è®¾å¤‡${String.fromCharCode(64 + deviceId)}-é€šè¿‡`, className: 'pass' },
                    fail: { text: `âŒ è®¾å¤‡${String.fromCharCode(64 + deviceId)}-ä¸é€šè¿‡`, className: 'fail' },
                    'no-device': { text: `âŒ è®¾å¤‡${String.fromCharCode(64 + deviceId)}-æœªæ’å…¥`, className: 'fail' },
                    connected: { text: `ç«¯å£${String.fromCharCode(64 + deviceId)}å·²è¿æ¥`, className: 'default' },
                    disconnected: { text: `ç«¯å£${String.fromCharCode(64 + deviceId)}æœªè¿æ¥`, className: 'default' }
                };

                const { text, className } = states[state] || states.disconnected;
                display.textContent = message || text;
                display.className = `test-result-display ${className}`;
            }
        }

        /**
         * æ ¸å¿ƒåº”ç”¨é€»è¾‘
         */
        class App {
            constructor(uiManager) {
                this.uiManager = uiManager;
                this.devices = Array.from({ length: CONFIG.DEVICE_COUNT }, (_, i) => ({
                    id: i + 1,
                    serial: new SerialManager(i + 1),
                    inProgress: false,
                    record: null
                }));
                this.wifiController = new WifiController(this);
                this.testRunner = new TestRunner(this.uiManager);
            }

            async init() {
                try {
                    await DgwCrypto.init();
                } catch (e) {
                    alert('URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚');
                    this.uiManager.log('âŒ URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
                    return;
                }
                this.uiManager.initDeviceRows();
                this.setupEventListeners();
                await this.loadSavedPorts();
                this.uiManager.updateButtons(this.devices);
                this.uiManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
            }

            setupEventListeners() {
                this.devices.forEach((device) => {
                    const panel = UI.devicePanels[device.id - 1];
                    panel.selectBtn.addEventListener('click', () => this.selectPort(device.id));
                    panel.connectBtn.addEventListener('click', () => this.toggleConnection(device.id));
                    panel.snInput.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault(); 
                            this.startTestFromInput(device.id);
                        }
                    });
                });
                
                UI.wifi.scanBtn.addEventListener('click', () => this.wifiController.scan());
                UI.wifi.connectBtn.addEventListener('click', () => this.wifiController.connectAll());
                UI.wifi.list.addEventListener('change', () => this.uiManager.updateButtons(this.devices, this.wifiController.isScanning));
                UI.wifi.pass.addEventListener('input', () => this.uiManager.updateButtons(this.devices, this.wifiController.isScanning));

                document.getElementById('switchInterfaceBtn').addEventListener('click', () => window.location.href = `wifi_tool.html?v=${Date.now()}`);
                document.getElementById('switchVerisonBtn').addEventListener('click', () => window.location.href = `complete_machine.html?v=${Date.now()}`);
            }

            async startTestFromInput(id) {
                const device = this.devices[id - 1];
                
                if (device.inProgress) {
                    this.uiManager.log(`è®¾å¤‡ ${id} æ­£åœ¨æµ‹è¯•ä¸­ï¼Œè¯·å‹¿é‡å¤æ“ä½œã€‚`);
                    return;
                }
                if (!device.serial.connected) {
                    this.uiManager.updateDeviceMessage(id, 'âŒ ä¸²å£æœªè¿æ¥', 'error');
                    return;
                }

                const panel = UI.devicePanels[id - 1];
                const enteredSn = panel.snInput.value.trim();

                if (enteredSn.length !== 20) {
                    this.uiManager.updateDeviceMessage(device.id, 'âŒ SNé”™è¯¯', 'error');
                    return;
                }else{this.uiManager.updateDeviceMessage(device.id, 'âœ… å·²è¿æ¥', 'success');}

                this.testRunner.startTest(device, this, enteredSn);
            }

            async loadSavedPorts() {
                const allPorts = await navigator.serial.getPorts();
                for (const device of this.devices) {
                    try {
                        const savedIndex = localStorage.getItem(`serialPort_device_${device.id}`);
                        if (savedIndex !== null) {
                            const port = allPorts[parseInt(savedIndex, 10)];
                            if (port) {
                                device.serial.port = port;
                                this.uiManager.updateDeviceMessage(device.id, 'âœ… ä¸²å£å·²åŠ è½½');
                            }
                        }
                    } catch (e) {
                        console.error('åŠ è½½å·²ä¿å­˜çš„ç«¯å£å¤±è´¥:', e);
                    }
                }
            }

            async selectPort(id) {
                const device = this.devices[id - 1];
                if (await device.serial.select()) {
                    this.uiManager.updateDeviceMessage(id, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
                    try {
                        const allPorts = await navigator.serial.getPorts();
                        const portIndex = allPorts.indexOf(device.serial.port);
                        if (portIndex > -1) {
                            localStorage.setItem(`serialPort_device_${id}`, portIndex);
                            this.uiManager.log(`ğŸ’¾ å·²ä¸ºè®¾å¤‡ ${id} ä¿å­˜ä¸²å£é€‰æ‹©`);
                        }
                    } catch (e) {
                        console.error('ä¿å­˜ç«¯å£é€‰æ‹©å¤±è´¥:', e);
                    }
                }
                this.uiManager.updateButtons(this.devices);
            }

            async toggleConnection(id) {
                const device = this.devices[id - 1];
                if (device.serial.connected) {
                    const isFinishedFailure = !device.inProgress && device.record?.status === false;
                    await this.disconnectDevice(device, isFinishedFailure);
                } else {
                    await this.connectDevice(device);
                }
                this.uiManager.updateButtons(this.devices);
            }

            async connectDevice(device) {
                this.uiManager.updateDeviceMessage(device.id, 'âŒ› è¿æ¥ä¸­...');
                if (await device.serial.connect(CONFIG.BAUD_RATE)) {
                    this.uiManager.updateDeviceMessage(device.id, 'âœ… å·²è¿æ¥', 'success');
                    this.uiManager.showTestResult(device.id, 'connected');
                } else {
                    this.uiManager.updateDeviceMessage(device.id, 'âŒ è¿æ¥å¤±è´¥', 'error');
                }
            }

            async disconnectDevice(device, keepResultOnDisplay = false) {
                if (device.inProgress) {
                    this.testRunner.cancelTest(device);
                    this.uiManager.log(`ğŸ›‘ è®¾å¤‡ ${device.id}: ç”¨æˆ·æ‰‹åŠ¨æ–­å¼€ï¼Œæµ‹è¯•å·²ä¸­æ–­`);
                }
                await device.serial.disconnect();
                this.uiManager.updateDeviceMessage(device.id, 'â„¹ï¸ å·²æ–­å¼€');
                UI.devicePanels[device.id - 1].snInput.value = '';
                if (!keepResultOnDisplay) { 
                     device.record = null;
                     this.uiManager.showTestResult(device.id, 'disconnected');
                     this.uiManager.clearTestResult(device.id);
                }
            }
        }

        /**
         * æµ‹è¯•æµç¨‹æ§åˆ¶å™¨
         */
        class TestRunner {
            constructor(uiManager) {
                this.uiManager = uiManager;
                this.testTimeouts = new Map();
            }

            cancelTest(device) {
                this.clearTimeouts(device.id);
                device.inProgress = false;
                if (device.record) this.uiManager.clearTestResult(device.id);
                device.record = null;
                this.uiManager.log(`â¹ï¸ è®¾å¤‡ ${device.id}: æµ‹è¯•å·²å–æ¶ˆ`);
            }

            async startTest(device, app, enteredSn) {
                if (device.inProgress) return;

                const ssid = UI.wifi.list.value;
                const bssid = UI.wifi.list.options[UI.wifi.list.selectedIndex]?.dataset.bssid;
                const pass = UI.wifi.pass.value;
                
                if (!ssid || !bssid) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: æ— æ³•å¼€å§‹æµ‹è¯•ï¼Œæœªé…ç½®WiFi (è¯·å…ˆæ‰«æå¹¶é€‰æ‹©)`);
                    this.uiManager.showTestResult(device.id, 'fail', 'WiFiæœªé…ç½®');
                    return;
                }

                this.uiManager.clearTestResult(device.id);
                device.record = null;
                device.inProgress = true;
                device.enteredSn = enteredSn;
                app.uiManager.updateButtons(app.devices);
                
                this.uiManager.showTestResult(device.id, 'waiting');

                // æµç¨‹: SN -> ä¸²å£é€šä¿¡ -> WIFI -> ç½‘é¡µè®¿é—®
                const timeoutId = setTimeout(() => {
                    if (!device.inProgress) return;
                    this.stepSerialInfo(device, app);
                }, CONFIG.TIMEOUTS.COMMAND);
                this.testTimeouts.set(`start_${device.id}`, timeoutId);
            }

            async stepSerialInfo(device, app) {
                this.uiManager.log(`è®¾å¤‡ ${device.id}: è·å–è®¾å¤‡ä¿¡æ¯...`);
                
                let buffer = '';
                let infoReceived = false;
                
                const onData = async (textData) => {
                    if (infoReceived) return;
                    buffer += textData;
                    if (buffer.includes('<1,DSN;')) {
                        infoReceived = true;
                        await device.serial.stopReadLoop();
                        this.handleSerialResponse(device, buffer, app);
                    }
                };
                
                device.serial.readLoop(onData, (e) => {
                     this.uiManager.log(`âŒ è®¾å¤‡ ${device.id} ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                });
                
                // å‘é€ <1,DSN>
                for (let i = 0; i < CONFIG.RETRY_COUNT + 1; i++) {
                    if (infoReceived) break;
                    const isRetry = i > 0;
                    if (isRetry) this.uiManager.log(`è®¾å¤‡ ${device.id}: è·å–ä¿¡æ¯é‡è¯•...`);
                    
                    if (!isRetry) {
                        await device.serial.write(new Uint8Array(8).fill(0xf8));
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    await device.serial.write('<1,DSN>');
                    
                    await new Promise(resolve => {
                         const tid = setTimeout(() => { resolve(); }, CONFIG.TIMEOUTS.RESPONSE);
                         this.testTimeouts.set(`info_${device.id}`, tid);
                    });
                }
                
                if (!infoReceived && device.inProgress) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: è·å–è®¾å¤‡ä¿¡æ¯è¶…æ—¶`);
                    await device.serial.stopReadLoop();
                    this.finishTest(device, { sn: null, serial: false, wifi: false, web: false, status: false }, app);
                }
            }

            async handleSerialResponse(device, buffer, app) {
                const sn = buffer.match(/<1,DSN;([^>]+)>/)?.[1]?.trim() || null;

                if (sn !== device.enteredSn) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: SNä¸åŒ¹é…ã€‚è¾“å…¥: ${device.enteredSn}, è®¾å¤‡è¿”å›: ${sn}`);
                    this.finishTest(device, { sn: sn, serial: true, status: false, errorReason: 'SNä¸åŒ¹é…', skipReport: true }, app);
                    return;
                }

                if (!sn) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: å“åº”æ ¼å¼ä¸æ­£ç¡®æˆ–SNä¸ºç©º`);
                    this.finishTest(device, { sn: null, serial: true, status: false, skipReport: true }, app);
                    return;
                }

                this.uiManager.log(`âœ… è®¾å¤‡ ${device.id}: æ”¶åˆ°SN: ${sn}`);
                
                device.record = { 
                    deviceId: device.id, 
                    timestamp: new Date().toLocaleString(), 
                    sn: sn, 
                    wifi: 'pending',
                    serial: 'pending', 
                    web: 'pending', 
                    status: 'pending' 
                };
                this.uiManager.addOrUpdateTestResult(device.record);
                
                const ssid = UI.wifi.list.value;
                const bssid = UI.wifi.list.options[UI.wifi.list.selectedIndex]?.dataset.bssid;
                const pass = UI.wifi.pass.value;
                await this.stepWifiConnect(device, app, ssid, pass, bssid);
            }

             async stepWifiConnect(device, app, ssid, pass, bssid) {
                this.uiManager.log(`è®¾å¤‡ ${device.id}: å‘é€é…ç½‘æŒ‡ä»¤...`);
                // è¿æ¥æŒ‡ä»¤æ ¼å¼ <1,WFI;ssid;password;bssid;1>
                const wifiCmd = `<1,WFI;${ssid};${pass};${bssid};1>`;
                
                await device.serial.write(wifiCmd);
                
                // ç­‰å¾…WiFiè¿æ¥
                await new Promise(r => setTimeout(r, CONFIG.TIMEOUTS.WIFI_CONNECT));
                
                // å‘é€æŸ¥è¯¢æŒ‡ä»¤ <1,> åˆ¤æ–­è¿æ¥
                await this.stepWifiCheck(device, app);
            }
            
            async stepWifiCheck(device, app) {
                this.uiManager.log(`è®¾å¤‡ ${device.id}: æ£€æŸ¥WiFiçŠ¶æ€...`);
                
                // é¢„ç•™æŸ¥è¯¢æŒ‡ä»¤ <1,>
                let responseReceived = false;
                
                // æ¸…ç†æ—§çš„buffer
                await device.serial.stopReadLoop();
                
                const onData = (text) => {
                    // åªè¦æ”¶åˆ°æ•°æ®ï¼Œä¸”ä¸æ˜¯æ˜ç¡®çš„é”™è¯¯ï¼Œå°±è®¤ä¸ºOK (æ ¹æ®ç”¨æˆ·è¦æ±‚: é»˜è®¤éƒ½å…ˆç”¨<1,>æ¥å‘é€åˆ¤æ–­)
                    // å¯ä»¥æ ¹æ®åç»­å¡«å……çš„å†…å®¹å®Œå–„åˆ¤æ–­
                    if (text.trim().length > 0) {
                        responseReceived = true;
                    }
                };
                
                device.serial.readLoop(onData, (e) => {});
                await device.serial.write('<1,>');
                
                await new Promise(resolve => setTimeout(resolve, CONFIG.TIMEOUTS.WIFI_CHECK));
                await device.serial.stopReadLoop();
                
                if (responseReceived) {
                    this.uiManager.log(`âœ… è®¾å¤‡ ${device.id}: WiFiè¿æ¥ç¡®è®¤ (æŸ¥è¯¢å“åº”OK)`);
                    device.record.wifi = true;
                    device.record.serial = true;
                    this.uiManager.addOrUpdateTestResult(device.record);
                    await this.startWebTest(device, app);
                } else {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: WiFiè¿æ¥æ£€æŸ¥è¶…æ—¶ (æ— å“åº”)`);
                    device.record.wifi = false;
                    this.finishTest(device, { status: false, errorReason: 'WiFiè¿æ¥å¤±è´¥', serial: true }, app);
                }
            }

            async startWebTest(device, app) {
                this.uiManager.log(`ğŸ”— è®¾å¤‡ ${device.id}: æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...`);
                const testUrl = await this._generateTestUrl(device.record.sn);
                let webResult = false;
                
                if (testUrl) {
                    this.uiManager.log(`ğŸŒ è®¾å¤‡ ${device.id}: æµ‹è¯•ç½‘å€: ${testUrl}`);
                    for (let attempt = 0; attempt < CONFIG.RETRY_COUNT + 1; attempt++) {
                        try {
                            const proxiedUrl = `https://cors.lorens.qzz.io/?url=${encodeURIComponent(testUrl)}`;
                            const response = await fetch(proxiedUrl, { signal: AbortSignal.timeout(CONFIG.TIMEOUTS.FETCH), mode: 'cors', cache: 'no-cache' });
                            if (response.ok) {
                                this.uiManager.log(`âœ… è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®æˆåŠŸ`);
                                webResult = true;
                                break;
                            }
                            throw new Error(`HTTPçŠ¶æ€ ${response.status}`);
                        } catch (e) {
                            this.uiManager.log(`âŒ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}`);
                            if (attempt < CONFIG.RETRY_COUNT) await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }
                
                this.finishTest(device, { web: webResult, status: webResult }, app);
            }

            async finishTest(device, result, app) {
                device.inProgress = false;
                
                const baseRecord = {
                    deviceId: device.id,
                    timestamp: new Date().toLocaleString(),
                    sn: null,
                    wifi: false,
                    serial: false,
                    web: false,
                    status: false
                };
                device.record = { ...baseRecord, ...device.record, ...result };

                const isSuccess = device.record.status === true;
                this.uiManager.addOrUpdateTestResult(device.record);

                // åˆ¤æ–­æ˜¯å¦æ²¡è·å–åˆ°å…³é”®å‚æ•° (WiFiç‰ˆåªæœ‰SN)
                const noDeviceDetected = !device.record.sn;
                let displayState;
                if (isSuccess) {
                    displayState = 'pass';
                } else if (noDeviceDetected) {
                    displayState = 'no-device';
                } else {
                    displayState = 'fail';
                }

                this.uiManager.showTestResult(device.id, displayState, result.errorReason);
                this.uiManager.updateButtons(app.devices);
                this.uiManager.log(`ğŸ“Š è®¾å¤‡ ${device.id}: æµ‹è¯•å®Œæˆ - ${isSuccess ? 'é€šè¿‡' : 'å¤±è´¥'}`);

                if (CONFIG.AUTO_REPORT && !device.record.skipReport) {
                    await this.reportResult(device.record);
                }

                // ç»“æŸæ¸…ç†ï¼Œå‘é€ç»“æŸç¬¦
                try {
                    await device.serial.write(new Uint8Array(8).fill(0xf8));
                } catch (e) {}

                UI.devicePanels[device.id - 1].snInput.value = '';
            }

            async reportResult(record) {
                if (!record.sn) return;

                this.uiManager.log(`ğŸ“® è®¾å¤‡ ${record.sn}: æ­£åœ¨ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...`);
                try {
                    const reportData = { 
                        deviceId: 'DGS-100', 
                        results: [{ 
                            sn: record.sn, 
                            wifiTest: record.wifi === true ? 'pass' : 'fail', // æ–°å¢ WiFi çŠ¶æ€ä¸ŠæŠ¥
                            serialTest: record.serial === true ? 'pass' : 'fail', 
                            webTest: record.web === true ? 'pass' : 'fail', 
                            overallStatus: record.status === true ? 'pass' : 'fail' 
                        }] 
                    }; 
                    const response = await fetch(CONFIG.URLS.REPORT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                        body: JSON.stringify(reportData),
                        signal: AbortSignal.timeout(CONFIG.TIMEOUTS.REPORT)
                    });
                    if (response.ok) {
                        this.uiManager.log(`âœ… è®¾å¤‡ ${record.sn}: ä¸ŠæŠ¥æˆåŠŸ`);
                        record.reported = true;
                    } else {
                        throw new Error(`æœåŠ¡å™¨å“åº” ${response.status}`);
                    }
                } catch (error) {
                    this.uiManager.log(`âŒ è®¾å¤‡ ${record.sn}: ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
                    record.reportFailed = true;
                }
                this.uiManager.addOrUpdateTestResult(record);
            }

            async _generateTestUrl(sn) {
                const encrypted = await DgwCrypto.encrypt("DAAN" + sn);
                return encrypted ? `${CONFIG.URLS.TEST}${encrypted}` : null;
            }

            clearTimeouts(deviceId) {
                if (this.testTimeouts.has(`info_${deviceId}`)) {
                    clearTimeout(this.testTimeouts.get(`info_${deviceId}`));
                    this.testTimeouts.delete(`info_${deviceId}`);
                }
            }
        }

        // --- åº”ç”¨å¯åŠ¨ ---
        if ('serial' in navigator) {
            const uiManager = new UIManager();
            const app = new App(uiManager);
            app.init();
        } else {
            alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚');
        }

    })();
</script>
</body>
</html>