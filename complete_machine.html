<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 æ•´æœºæµ‹è¯•</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; background: #fff; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background: #f8f9fa; color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: #28a745; }
        .fail { background: #f8d7da; color: #dc3545; }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 160px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        .table-container { max-height: 520px; overflow-y: auto; }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1>æ•´æœºæµ‹è¯•</h1>
    <div style="display: flex; gap: 10px;">
        <button class="btn" id="saveRecordsBtn">ä¿å­˜è®°å½•</button>
        <button class="btn" id="switchInterfaceBtn" style="background: #28a745; color: white; font-weight: bold;">åˆ‡æ¢åˆ°å•æ¿æµ‹è¯•</button>
    </div>
</div>

<div class="panel">
    <div class="grid">
        <div class="panel panel-green"><h4>è®¾å¤‡1</h4><div style="display: flex; align-items: center; gap: 10px;"><button class="btn" id="selectDevice1Btn">é€‰æ‹©ä¸²å£</button><button class="btn" id="connectDevice1Btn">è¿æ¥</button><div id="device1Msg"></div></div></div>
        <div class="panel panel-blue"><h4>è®¾å¤‡2</h4><div style="display: flex; align-items: center; gap: 10px;"><button class="btn" id="selectDevice2Btn">é€‰æ‹©ä¸²å£</button><button class="btn" id="connectDevice2Btn">è¿æ¥</button><div id="device2Msg"></div></div></div>
        <div class="panel panel-green"><h4>è®¾å¤‡3</h4><div style="display: flex; align-items: center; gap: 10px;"><button class="btn" id="selectDevice3Btn">é€‰æ‹©ä¸²å£</button><button class="btn" id="connectDevice3Btn">è¿æ¥</button><div id="device3Msg"></div></div></div>
        <div class="panel panel-blue"><h4>è®¾å¤‡4</h4><div style="display: flex; align-items: center; gap: 10px;"><button class="btn" id="selectDevice4Btn">é€‰æ‹©ä¸²å£</button><button class="btn" id="connectDevice4Btn">è¿æ¥</button><div id="device4Msg"></div></div></div>
    </div>
</div>

<div class="panel">
    <div class="table-container">
        <table><thead><tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr></thead><tbody id="wholeMachineResultBody"></tbody></table>
    </div>
</div>
<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
const config = { 
    aes: { keyString: "me%ov2Ied|eicegh", ivString: "me%ov2Ied|eicegh" }, 
    urls: { test: "http://gw.3wlink.cn:22011/?dgwkey=", report: "https://daantest.free.beeceptor.com" },
    baudRate: 115200,
    timeouts: { command: 15000, response: 5000, fetch: 5000, report: 10000 },
    autoReport: true
};

const ui = {
    logBox: document.getElementById('logBox'),
    resultBody: document.getElementById('wholeMachineResultBody'),
    saveRecordsBtn: document.getElementById('saveRecordsBtn'),
    devicePanels: Array.from({length: 4}, (_, i) => ({
        selectBtn: document.getElementById(`selectDevice${i+1}Btn`),
        connectBtn: document.getElementById(`connectDevice${i+1}Btn`),
        msg: document.getElementById(`device${i+1}Msg`)
    }))
};

const DgwCrypto = {
    _key: null, _iv: null,
    async init() {
        if (this._key) return;
        try {
            const keyBytes = new TextEncoder().encode(config.aes.keyString);
            this._iv = new TextEncoder().encode(config.aes.ivString);
            this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
        } catch (error) {
            console.error(":", error);
            throw error;
        }
    },
    async encrypt(plainText) {
        if (!this._key) { await this.init(); }
        try {
            const textBytes = new TextEncoder().encode(plainText);
            const blockSize = 16;
            let paddedData;
            if (textBytes.length % blockSize === 0) {
                paddedData = new Uint8Array(textBytes);
            } else {
                const paddingNeeded = blockSize - (textBytes.length % blockSize);
                paddedData = new Uint8Array(textBytes.length + paddingNeeded);
                paddedData.set(textBytes);
            }
            const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
            const encryptedArray = new Uint8Array(encrypted);
            const truncated = encryptedArray.slice(0, paddedData.length);
            const base64 = btoa(String.fromCharCode(...truncated));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        } catch (error) {
            console.error('åŠ å¯†å¤±è´¥:', error);
            return null;
        }
    }
};

class SerialManager {
    constructor(id) {
        this.id = id;
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.connected = false;
        this.buffer = '';
        this.readLoopActive = false;
    }
    async select() {
        try {
            this.port = await navigator.serial.requestPort();
            return true;
        } catch {
            return false;
        }
    }
    async connect(baudRate) {
        if (!this.port) return false;
        try {
            await this.port.open({ baudRate });
            this.writer = this.port.writable?.getWriter();
            this.connected = true;
            return true;
        } catch (e) {
            console.error(`è®¾å¤‡ ${this.id} è¿æ¥å¤±è´¥:`, e);
            return false;
        }
    }
    async disconnect() {
        await this.stopReadLoop();
        if (this.writer) { await this.writer.close().catch(() => {}); this.writer = null; }
        if (this.port) { await this.port.close().catch(() => {}); }
        this.connected = false;
        this.buffer = '';
    }
    async readLoop(onData, onError) {
        if (!this.port?.readable || !this.connected) return;
        this.readLoopActive = true;
        this.reader = this.port.readable.getReader();
        try {
            while (this.connected && this.readLoopActive) {
                const { value, done } = await this.reader.read();
                if (done) break;
                if (onData) onData(new TextDecoder().decode(value));
            }
        } catch (e) {
            if (this.readLoopActive && onError) onError(e);
        } finally {
            if (this.reader) {
                this.reader.releaseLock();
                this.reader = null;
            }
            this.readLoopActive = false;
        }
    }
    async stopReadLoop() {
        if (this.readLoopActive) {
            this.readLoopActive = false;
            if (this.reader) await this.reader.cancel().catch(() => {});
        }
    }
}

const UIManager = {
    logMessages: ['æµ‹è¯•æ—¥å¿—...'], // åˆå§‹åŒ–æ—¥å¿—æ•°ç»„
    logLimit: 100, // æ—¥å¿—ä¸Šé™
    log(msg) {
        const timestamp = new Date().toLocaleTimeString();
        this.logMessages.push(`[${timestamp}] ${msg}`);
        if (this.logMessages.length > this.logLimit) {
            this.logMessages.shift(); // ç§»é™¤æœ€æ—©çš„æ—¥å¿—
        }
        ui.logBox.textContent = this.logMessages.join('\n');
        ui.logBox.scrollTop = ui.logBox.scrollHeight;
    },
    update(id, text, type = 'info') {
        const el = ui.devicePanels[id - 1].msg;
        if (el) el.textContent = text;
        el.style.color = { error: 'red', success: 'green' }[type] || 'black';
    },
    updateButtons(app) {
        app.devices.forEach((device, i) => {
            const panel = ui.devicePanels[i];
            panel.connectBtn.textContent = device.serial.connected ? 'æ–­å¼€' : 'è¿æ¥';
            panel.connectBtn.disabled = !device.serial.connected && !device.serial.port;
            panel.selectBtn.disabled = device.inProgress;
        });
        ui.saveRecordsBtn.disabled = !app.devices.some(d => d.record);
    },
    addOrUpdateTestResult(record) {
        let row = document.getElementById(`row-${record.sn}`);
        if (!row) {
            row = ui.resultBody.insertRow(0);
            row.id = `row-${record.sn}`;
            for (let i = 0; i < 8; i++) row.insertCell();
        }
        const getStatusDisplay = (val) => {
            if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
            if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
            if (val === 'æœªæ’å¡') return { text: 'æœªæ’å¡', className: 'fail' };
            return { text: 'å¾…æµ‹è¯•', className: '' };
        };
        const updateCell = (cell, { text, className = '' }) => {
            cell.textContent = text;
            cell.className = className;
        };
        const columns = [
            { text: record.timestamp, className: '' },
            { text: record.sn, className: record.sn ? 'pass' : 'fail' },
            { text: record.imei, className: record.imei ? 'pass' : 'fail' },
            { text: record.iccid, className: record.iccid && record.iccid !== 'æœªæ’å¡' ? 'pass' : 'fail' },
            getStatusDisplay(record.serial),
            getStatusDisplay(record.web),
            record.status === 'pending' ? { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' } : getStatusDisplay(record.status),
            record.reportFailed ? { text: 'æœªä¸ŠæŠ¥', className: 'fail' } : record.reported ? { text: 'å·²ä¸ŠæŠ¥', className: 'pass' } : { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' }
        ];
        columns.forEach((col, i) => updateCell(row.cells[i], col));
    },
    removeTestResult(sn) {
        const row = document.getElementById(`row-${sn}`);
        if (row) row.remove();
    }
};

const app = {
    devices: Array.from({length: 4}, (_, i) => ({ id: i + 1, serial: new SerialManager(i + 1), inProgress: false, record: null })),
    async init() {
        try {
            await DgwCrypto.init();
        } catch (e) {
            alert('URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚');
            UIManager.log('âŒ URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
            return;
        }
        this.setupEventListeners();
        await this.loadSavedPorts();
        UIManager.updateButtons(this);
        UIManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
    },
    setupEventListeners() {
        this.devices.forEach((device, i) => {
            const panel = ui.devicePanels[i];
            panel.selectBtn.addEventListener('click', () => this.selectPort(device.id));
            panel.connectBtn.addEventListener('click', () => this.toggleConnection(device.id));
        });
        ui.saveRecordsBtn.addEventListener('click', () => this.saveToCSV());
        document.getElementById('switchInterfaceBtn').addEventListener('click', () => window.location.href = 'index.html');
    },
    saveToCSV() {
        const records = this.devices.map(d => d.record).filter(r => r);
        if (!records.length) return alert('æ²¡æœ‰æµ‹è¯•è®°å½•å¯ä¾›ä¿å­˜ã€‚');
        const header = ['æ—¶é—´', 'SN', 'IMEI', 'ICCID', 'ä¸²å£é€šä¿¡', 'ç½‘é¡µè®¿é—®', 'æµ‹è¯•ç»“æœ', 'ä¸ŠæŠ¥çŠ¶æ€'];
        const formatResult = (val) => val === true ? 'æ­£å¸¸' : val === false ? 'å¼‚å¸¸' : val || 'å¾…æµ‹è¯•';
        const rows = records.map(r => [r.timestamp, r.sn, r.imei, r.iccid, formatResult(r.serial), formatResult(r.web), formatResult(r.status),
            r.reported ? 'å·²ä¸ŠæŠ¥' : (r.reportFailed ? 'æœªä¸ŠæŠ¥' : 'å¾…ä¸ŠæŠ¥')]);
        const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
        const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `æ•´æœºæµ‹è¯•è®°å½•_${new Date().toISOString().slice(0, 10)}.csv`;
        link.click();
        link.remove();
    },
    async loadSavedPorts() {
        for (const { id, serial } of this.devices) {
            try {
                const savedIndex = localStorage.getItem(`serialPort_device_${id}`);
                if (savedIndex !== null) {
                    const allPorts = await navigator.serial.getPorts();
                    const port = allPorts[parseInt(savedIndex)] || null;
                    if (port) {
                        serial.port = port;
                        UIManager.update(id, 'âœ… ä¸²å£å·²åŠ è½½');
                    }
                }
            } catch (e) {
                console.error('æœªèƒ½åŠ è½½ç«¯å£é€‰æ‹©:', e);
            }
        }
    },
    async selectPort(id) {
        const device = this.devices[id - 1];
        if (await device.serial.select()) {
            UIManager.update(id, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
            try {
                const allPorts = await navigator.serial.getPorts();
                const portIndex = allPorts.indexOf(device.serial.port);
                if (portIndex > -1) {
                    localStorage.setItem(`serialPort_device_${id}`, portIndex);
                    UIManager.log(`ğŸ’¾ å·²ä¿å­˜è®¾å¤‡ ${id} ä¸²å£é€‰æ‹©`);
                }
            } catch (e) {
                console.error('ä¿æŒé€‰æ‹©ç«¯å£å¤±è´¥:', e);
            }
        }
        UIManager.updateButtons(this);
    },
    async toggleConnection(id, forceDisconnect = false) {
        const device = this.devices[id - 1];
        if (forceDisconnect || device.serial.connected) {
            if (device.inProgress) {
                TestRunner.cancelTest(device, this);
                UIManager.log(`ğŸ›‘ è®¾å¤‡ ${id}: ç”¨æˆ·æ‰‹åŠ¨æ–­å¼€ï¼Œæµ‹è¯•å·²ä¸­æ–­`);
            }
            await device.serial.disconnect();
            device.record = null; // æ¸…é™¤è®°å½•çŠ¶æ€
            UIManager.update(id, 'â„¹ï¸ å·²æ–­å¼€', 'info');
        } else {
            UIManager.update(id, 'âŒ› è¿æ¥ä¸­...');
            if (await device.serial.connect(config.baudRate)) {
                UIManager.update(id, 'âœ… å·²è¿æ¥', 'success');
                TestRunner.startTest(device, this);
            } else {
                UIManager.update(id, 'âŒ è¿æ¥å¤±è´¥', 'error');
            }
        }
        UIManager.updateButtons(this);
    }
};

const TestRunner = {
    testTimeouts: new Map(),
    cancelTest(device, app) {
        for (const key of [`${device.id}`, `response_${device.id}`]) {
            if (this.testTimeouts.has(key)) {
                clearTimeout(this.testTimeouts.get(key));
                this.testTimeouts.delete(key);
            }
        }
        device.inProgress = false;
        if (device.record?.sn) UIManager.removeTestResult(device.record.sn); // ç§»é™¤è¡¨æ ¼ä¸­çš„è®°å½•
        device.record = null; // æ¸…é™¤æµ‹è¯•è®°å½•
        UIManager.update(device.id, 'â„¹ï¸ æµ‹è¯•å·²å–æ¶ˆ', 'info');
        UIManager.updateButtons(app);
        UIManager.log(`â¹ï¸ è®¾å¤‡ ${device.id}: æµ‹è¯•å·²å–æ¶ˆ`);
    },
    async startTest(device, app) {
        if (device.inProgress) return;
        device.inProgress = true;
        UIManager.updateButtons(app);
        UIManager.update(device.id, 'â³ ç­‰å¾…è®¾å¤‡å¯åŠ¨...');
        try {
            const timeoutId = setTimeout(() => {
                if (!device.inProgress) return;
                UIManager.update(device.id, 'âœ… æ­£åœ¨æµ‹è¯•...');
                this.listenAndSendCommand(device, app);
            }, config.timeouts.command);
            this.testTimeouts.set(device.id, timeoutId);
        } catch (e) {
            UIManager.log(`âŒ è®¾å¤‡ ${device.id}: æµ‹è¯•å¯åŠ¨å¤±è´¥: ${e.message}`);
            this.finishTest(device, { serial: false, web: false, status: false }, app);
        }
    },
    async listenAndSendCommand(device, app) {
        this.testTimeouts.delete(device.id);
        let responseReceived = false;
        const sendAndRetry = async (isRetry = false) => {
            if (responseReceived) return;
            const textCommand = '<1,DSN,ICC,IME>';
            const responseTimeoutKey = `response_${device.id}`;
            if (isRetry) {
                UIManager.log(`è®¾å¤‡ ${device.id}: å“åº”è¶…æ—¶ï¼Œé‡è¯•ä¸€æ¬¡...`);
                await device.serial.writer.write(new TextEncoder().encode(textCommand));
                UIManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²é‡å‘æŒ‡ä»¤: ${textCommand.trim()}`);
                this.testTimeouts.set(responseTimeoutKey, setTimeout(() => {
                    if (!responseReceived) {
                        UIManager.log(`âŒ è®¾å¤‡ ${device.id}: ç¬¬äºŒæ¬¡å“åº”è¶…æ—¶`);
                        this.finishTest(device, { serial: false, web: false, status: false }, app);
                    }
                }, config.timeouts.response));
            } else {
                await device.serial.writer.write(new Uint8Array(8).fill(0xf8));
                UIManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²å‘é€HEXæ•°æ®: f8 f8 f8 f8 f8 f8 f8 f8`);
                await new Promise(resolve => setTimeout(resolve, 50));
                await device.serial.writer.write(new TextEncoder().encode(textCommand));
                UIManager.log(`è®¾å¤‡ ${device.id}: ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ${textCommand.trim()}`);
                this.testTimeouts.set(responseTimeoutKey, setTimeout(() => sendAndRetry(true), config.timeouts.response));
            }
        };
        device.serial.buffer = '';
        device.serial.readLoop(async (textData) => {
            if (responseReceived) return;
            device.serial.buffer += textData;
            if (device.serial.buffer.includes('<1,DSN;') && device.serial.buffer.includes('<1,ICC;') && device.serial.buffer.includes('<1,IME;')) {
                responseReceived = true;
                this.testTimeouts.delete(`response_${device.id}`);
                await this.handleResponse(device, device.serial.buffer, app);
                device.serial.buffer = '';
                await device.serial.stopReadLoop();
            }
        }, (e) => {
            if (device.inProgress) {
                UIManager.log(`âŒ è®¾å¤‡ ${device.id} ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                this.finishTest(device, { serial: false, web: false, status: false }, app);
            }
        });
        sendAndRetry();
    },
    async handleResponse(device, buffer, app) {
        const dsnMatch = buffer.match(/<1,DSN;([^>]+)>/);
        const iccMatch = buffer.match(/<1,ICC;([^>]*)>/);
        const imeMatch = buffer.match(/<1,IME;([^>]+)>/);
        const sn = dsnMatch?.[1]?.trim() || null;
        const iccid = iccMatch?.[1]?.trim() || '';
        const imei = imeMatch?.[1]?.trim() || null;
        if (!sn && !imei) {
            UIManager.log(`âŒ è®¾å¤‡ ${device.id}: SN å’Œ IMEI ä¸ºç©ºï¼Œè®°å½•å·²ç§»é™¤`);
            if (device.record?.sn) UIManager.removeTestResult(device.record.sn);
            device.record = null;
            UIManager.update(device.id, 'âŒ è®°å½•å·²ç§»é™¤', 'error');
            this.finishTest(device, { serial: false, web: false, status: false }, app);
            return;
        }
        if (!sn || !imei) {
            UIManager.log(`âŒ è®¾å¤‡ ${device.id}: å“åº”æ ¼å¼ä¸æ­£ç¡®: ${buffer}`);
            if (device.record?.sn) UIManager.removeTestResult(device.record.sn);
            device.record = null;
            UIManager.update(device.id, 'âŒ è®°å½•å·²ç§»é™¤', 'error');
            this.finishTest(device, { sn: sn || 'æœªçŸ¥', serial: false, web: false, status: false }, app);
            return;
        }
        device.record = { timestamp: new Date().toLocaleString(), sn, imei, iccid, serial: true, web: 'pending', status: 'pending' };
        UIManager.addOrUpdateTestResult(device.record);
        UIManager.log(`âœ… è®¾å¤‡ ${device.id}: æ”¶åˆ°SN: ${sn}, IMEI: ${imei}, ICCID: ${iccid || 'æ— '}`);
        if (!iccid) {
            UIManager.log(`âš ï¸ è®¾å¤‡ ${device.id}: æœªæ’å¡`);
            device.record.iccid = 'æœªæ’å¡';
            device.record.web = 'æœªæ’å¡';
            this.finishTest(device, { ...device.record, status: true }, app);
        } else {
            await this.startWebTest(device, app);
        }
    },
    async startWebTest(device, app) {
        if (!device.record?.sn) return; // é˜²æ­¢æ— æ•ˆè®°å½•ç»§ç»­
        UIManager.log(`ğŸ”— è®¾å¤‡ ${device.id}: æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...`);
        const testUrl = await this._generateTestUrl(device.record.sn);
        let webResult = false;
        if (testUrl) {
            UIManager.log(`ğŸŒ è®¾å¤‡ ${device.id}: æµ‹è¯•ç½‘å€: ${testUrl}`);
            for (let attempt = 1; attempt <= 2; attempt++) {
                try {
                    if (attempt === 2) UIManager.log(`ğŸ”„ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥ï¼Œé‡è¯•ç¬¬${attempt}æ¬¡...`);
                    const proxiedUrl = `https://cors.9185918.xyz/?url=${encodeURIComponent(testUrl)}`;
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), config.timeouts.fetch);
                    const response = await fetch(proxiedUrl, { signal: controller.signal, mode: 'cors', cache: 'no-cache' });
                    clearTimeout(timeoutId);
                    if (response.ok) {
                        UIManager.log(`âœ… è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®æˆåŠŸ${attempt === 2 ? ' (é‡è¯•æˆåŠŸ)' : ''}`);
                        webResult = true;
                        break;
                    } else {
                        UIManager.log(`âŒ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥ - ${response.status}${attempt === 1 ? ' (å‡†å¤‡é‡è¯•)' : ''}`);
                    }
                } catch (e) {
                    UIManager.log(`âŒ è®¾å¤‡ ${device.id}: ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}${attempt === 1 ? ' (å‡†å¤‡é‡è¯•)' : ''}`);
                }
                if (attempt === 1 && !webResult) await new Promise(resolve => setTimeout(resolve, 500));
            }
        } else {
            UIManager.log(`âŒ è®¾å¤‡ ${device.id}: URL ç”Ÿæˆå¤±è´¥`);
        }
        this.finishTest(device, { ...device.record, web: webResult, status: webResult }, app);
    },
    async _generateTestUrl(sn) {
        const encrypted = await DgwCrypto.encrypt("DAAN" + sn);
        return encrypted ? `${config.urls.test}${encrypted}` : null;
    },
    async finishTest(device, result, app) {
        device.inProgress = false;
        device.record = result;
        if (result.sn && result.imei && result.status !== false) { // ä»…æœ‰æ•ˆè®°å½•æ›´æ–°è¡¨æ ¼
            UIManager.addOrUpdateTestResult(device.record);
        } else if (result.sn) {
            UIManager.removeTestResult(result.sn); // ç§»é™¤æ— æ•ˆè®°å½•
        }
        UIManager.updateButtons(app);
        UIManager.log(`ğŸ“Š è®¾å¤‡ ${device.id}: æµ‹è¯•å®Œæˆ - ${result.status ? 'é€šè¿‡' : 'å¤±è´¥'}`);
        if (config.autoReport && result.sn && result.imei && result.status !== false) {
            await this.reportResult(device.record, device.id);
        }
        try {
            if (device.serial.writer) {
                UIManager.log(`è®¾å¤‡ ${device.id}: å‘é€æœ€ç»ˆæŒ‡ä»¤å¹¶å‡†å¤‡æ–­å¼€...`);
                await device.serial.writer.write(new Uint8Array(8).fill(0xf8));
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        } catch (e) {
            UIManager.log(`è®¾å¤‡ ${device.id}: å‘é€æœ€ç»ˆæŒ‡ä»¤å¤±è´¥: ${e.message}`);
        } finally {
            await app.toggleConnection(device.id, true);
        }
    },
    async reportResult(record, deviceId) {
        if (!record || !record.sn) {
            UIManager.log(`âŒ è®¾å¤‡ ${deviceId}: æ— æ³•ä¸ŠæŠ¥ï¼Œæ— æ•ˆè®°å½•`);
            return;
        }
        UIManager.log(`ğŸ“® è®¾å¤‡ ${record.sn}: ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...`);
        try {
            const reportData = { deviceId: 'DGS-100', results: [{ sn: record.sn, imei: record.imei, iccid: record.iccid, serialTest: record.serial, webTest: record.web, overallStatus: record.status }] };
            const response = await fetch(config.urls.report, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                body: JSON.stringify(reportData),
                signal: AbortSignal.timeout(config.timeouts.report)
            });
            if (response.ok) {
                UIManager.log(`âœ… è®¾å¤‡ ${record.sn}: ä¸ŠæŠ¥æˆåŠŸ`);
                record.reported = true;
            } else {
                throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status}`);
            }
        } catch (error) {
            UIManager.log(`âŒ è®¾å¤‡ ${record.sn}: ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
            record.reportFailed = true;
        }
        if (record.sn && record.imei) {
            UIManager.addOrUpdateTestResult(record);
        }
    }
};

if ('serial' in navigator) {
    app.init();
} else {
    alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
    document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>';
}
</script>
</body>
</html>
