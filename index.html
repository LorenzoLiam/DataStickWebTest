<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ•°æ®æ£’æµ‹è¯• (ä¼˜åŒ–ç‰ˆ)</title>
    <style>
        /* CSSæ ·å¼ä¿æŒä¸å˜ */
        body { font-family: sans-serif; padding: 20px; background-color: #f4f7f6; color: #333; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background-color: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .flex { display: flex; gap: 20px; flex-wrap: wrap; }
        .flex > div { flex: 1; min-width: 300px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .status-item { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .status-item span:first-child { color: #555; }
        .status-value { font-weight: bold; }
        .status-ready { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-on { color: #28a745; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
        th { background-color: #f8f8f8; }
        .pass { background: #d4edda; color: #155724; }
        .fail { background: #f8d7da; color: #721c24; }
        #logBox {margin: 10px 0;padding: 10px;border: 1px solid #ddd;height: 160px;overflow-y: auto; background: #f9f9f9;color: #333;font-family: monospace;white-space: pre-wrap;word-break: break-all;border-radius: 4px;
}
        .color-preview { width: 100%; height: 30px; border: 1px solid #ddd; margin-top: 10px; border-radius: 4px; }
        .hidden { display: none; }
        input[type="text"] { width: 200px; padding: 8px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px; }
    </style>
</head>
<body>
<h1>æ•°æ®æ£’æµ‹è¯•</h1>

<div class="flex">
    <div class="panel panel-green">
        <h3>è®¾å¤‡çŠ¶æ€ç›‘æ§</h3>
        <button class="btn" id="selectStatusBtn">é€‰æ‹©çŠ¶æ€ä¸²å£</button>
        <button class="btn" id="connectStatusBtn">è¿æ¥</button>
        <button class="btn" id="disconnectStatusBtn">æ–­å¼€</button>
        <div id="statusMsg"></div>
    </div>

    <div class="panel panel-blue">
        <h3>æµ‹è¯•åŠŸèƒ½</h3>
        <div style="margin: 10px 0; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
            <button class="btn" id="selectTestBtn">é€‰æ‹©æµ‹è¯•ä¸²å£</button>
            <div style="display: flex; align-items: center;">
                <label for="scanInput">SN:</label>
                <input type="text" id="scanInput" placeholder="è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ..." />
            </div>
            <button class="btn" id="saveRecordsBtn">ä¿å­˜è®°å½•</button>
        </div>
        <div id="testMsg"></div>
    </div>
</div>

<div id="deviceStatus" class="panel hidden">
    <h3>è®¾å¤‡çŠ¶æ€ä¿¡æ¯</h3>
    <div class="grid" id="statusGrid"></div>
</div>

<div class="panel">
    <table>
        <thead><tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th></tr></thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<script>
// --- Configuration ---
const config = {
    aes: {
        keyString: "me%ov2Ied|eicegh", // 16-byte key
        ivString: "me%ov2Ied|eicegh"  // 16-byte IV
    },
    urls: {
        test: "http://gw.3wlink.cn:22011/?dgwkey=",
        proxies: [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ]
    },
    baudRates: {
        status: 115200,
        test: 10000000
    },
    timeouts: {
        test: 15000, // Overall test timeout
        fetch: 5000, // Network request timeout
        proxyFetch: 3000
    }
};

// --- DOM Element Cache ---
const ui = {
    selectStatusBtn: document.getElementById('selectStatusBtn'),
    connectStatusBtn: document.getElementById('connectStatusBtn'),
    disconnectStatusBtn: document.getElementById('disconnectStatusBtn'),
    statusMsg: document.getElementById('statusMsg'),
    selectTestBtn: document.getElementById('selectTestBtn'),
    scanInput: document.getElementById('scanInput'),
    saveRecordsBtn: document.getElementById('saveRecordsBtn'),
    testMsg: document.getElementById('testMsg'),
    deviceStatus: document.getElementById('deviceStatus'),
    statusGrid: document.getElementById('statusGrid'),
    resultBody: document.getElementById('resultBody'),
    logBox: document.getElementById('logBox'),
};

async function encryptAES(plainText) {
    try {
        const keyBytes = new TextEncoder().encode(config.aes.keyString);
        const ivBytes = new TextEncoder().encode(config.aes.ivString);
        const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
        
        const textBytes = new TextEncoder().encode(plainText);
        const blockSize = 16;
        let paddedData;
        if (textBytes.length % blockSize === 0) {
            paddedData = new Uint8Array(textBytes);
        } else {
            const paddingNeeded = blockSize - (textBytes.length % blockSize);
            paddedData = new Uint8Array(textBytes.length + paddingNeeded);
            paddedData.set(textBytes);
        }
        const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: ivBytes }, key, paddedData);
        const encryptedArray = new Uint8Array(encrypted);
        const truncated = encryptedArray.slice(0, paddedData.length);
        const base64 = btoa(String.fromCharCode(...truncated));
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');

    } catch (error) {
        console.error('åŠ å¯†å¤±è´¥:', error);
        return null;
    }
}

async function generateTestUrl(sn) {
    const plainText = "DAAN" + sn;
    const encrypted = await encryptAES(plainText);
    return encrypted ? `${config.urls.test}${encrypted}` : null;
}

// Helper to create DOM elements safely
function createElement(tag, options = {}) {
    const el = document.createElement(tag);
    if (options.text) el.textContent = options.text;
    if (options.className) el.className = options.className;
    if (options.style) Object.assign(el.style, options.style);
    return el;
}

// --- Serial Management Class (Largely unchanged, it's well-designed) ---
class SerialManager {
    constructor(type) {
        this.type = type;
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.connected = false;
        this.buffer = '';
        this.readLoopActive = false;
    }

    async select() {
        try {
            this.port = await navigator.serial.requestPort();
            return true;
        } catch {
            return false;
        }
    }

    async connect(baudRate) {
        if (!this.port) return false;
        try {
            await this.port.open({ baudRate });
            this.reader = this.port.readable?.getReader();
            this.writer = this.port.writable?.getWriter();
            this.connected = true;
            return true;
        } catch (e) {
            console.error(`${this.type} connection failed:`, e);
            return false;
        }
    }

    async disconnect() {
        this.readLoopActive = false; // Signal loop to stop
        if (!this.connected && !this.port) return;

        // Release reader and writer locks before closing the port
        if (this.reader) {
            try { await this.reader.cancel(); } catch {/* Ignore */ } finally { this.reader = null; }
        }
        if (this.writer) {
            try { await this.writer.close(); } catch {/* Ignore */ } finally { this.writer = null; }
        }
        
        // Now close the port
        if (this.port) {
            try { await this.port.close(); } catch {/* Ignore */ }
        }

        this.connected = false;
        this.buffer = '';
    }

    async readLoop(onData, onError) {
        if (!this.reader || !this.connected) return;
        this.readLoopActive = true;
        while (this.connected && this.readLoopActive) {
            try {
                const { value, done } = await this.reader.read();
                if (done) break;
                if (onData) onData(new TextDecoder().decode(value));
            } catch (e) {
                if (this.connected) { // Only call error if it's an unexpected error
                    if (onError) onError(e);
                }
                break; // Exit loop on error
            }
        }
        this.readLoopActive = false;
    }
}


// --- Main Application Logic ---
const app = {
    status: new SerialManager('status'),
    test: new SerialManager('test'),
    testing: false,
    processingData: false,
    records: [],
    testTimeout: null,

    log(msg) {
        const timestamp = new Date().toLocaleTimeString();
        ui.logBox.textContent += `\n[${timestamp}] ${msg}`;
        ui.logBox.scrollTop = ui.logBox.scrollHeight;
    },

    clearLog() {
        ui.logBox.textContent = 'æµ‹è¯•æ—¥å¿—...';
    },

    updateUI(id, text, type = 'info') {
        const el = ui[id];
        if (!el) return;
        el.textContent = text;
        el.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black';
    },

    async selectPort(type) {
        const manager = this[type];
        const success = await manager.select();
        this.updateUI(`${type}Msg`, success ? 'âœ… ä¸²å£å·²é€‰æ‹©' : 'âŒ é€‰æ‹©å¤±è´¥', success ? 'success' : 'error');
        if (success) {
            await this.savePortSelection(type, manager.port);
        }
        this.updateButtons();
    },

    async savePortSelection(type, selectedPort) {
        try {
            const allPorts = await navigator.serial.getPorts();
            const portIndex = allPorts.indexOf(selectedPort);
            if (portIndex > -1) {
                localStorage.setItem(`serialPort_${type}`, portIndex.toString());
                this.log(`ğŸ’¾ å·²ä¿å­˜ ${type === 'status' ? 'çŠ¶æ€' : 'æµ‹è¯•'} ä¸²å£é€‰æ‹©`);
            }
        } catch (e) { console.error('Failed to save port selection:', e); }
    },



    async loadPortSelection(type) {
        try {
            const savedIndex = localStorage.getItem(`serialPort_${type}`);
            if (savedIndex === null) return null;
            const allPorts = await navigator.serial.getPorts();
            return allPorts[parseInt(savedIndex, 10)] || null;
        } catch (e) {
            console.error('Failed to load port selection:', e);
            return null;
        }
    },

    async connect(type) {
        const manager = this[type];
        if (!manager.port || manager.connected) return;

        this.updateUI(`${type}Msg`, 'âŒ› è¿æ¥ä¸­...');
        const success = await manager.connect(config.baudRates[type]);
        this.updateUI(`${type}Msg`, success ? 'âœ… å·²è¿æ¥' : 'âŒ è¿æ¥å¤±è´¥', success ? 'success' : 'error');
        if (success && type === 'status') {
            this.startStatusReadLoop();
        }
        this.updateButtons();
    },

    async disconnect(type) {
        await this[type].disconnect();
        this.updateUI(`${type}Msg`, 'â„¹ï¸ å·²æ–­å¼€');
        if (type === 'status') {
            ui.deviceStatus.classList.add('hidden');
        }
        this.updateButtons();
    },
    
    updateButtons() {
        ui.connectStatusBtn.disabled = !this.status.port || this.status.connected;
        ui.disconnectStatusBtn.disabled = !this.status.connected;
        
        const testInProgress = this.testing;
        ui.selectTestBtn.disabled = testInProgress;
        ui.scanInput.disabled = testInProgress;
        ui.saveRecordsBtn.disabled = this.records.length === 0 || testInProgress;
    },

    startStatusReadLoop() {
        this.status.readLoop(
            (text) => {
                this.status.buffer += text;
                // Check for a complete message block, ending with Color_C=...
                if (this.status.buffer.includes('Color_C=')) {
                    this.parseStatus(this.status.buffer.trim());
                    this.status.buffer = ''; // Clear buffer for next message
                }
            },
            (err) => {
                this.log(`âŒ çŠ¶æ€ä¸²å£è¯»å–é”™è¯¯: ${err.message}`);
                this.disconnect('status');
            }
        );
    },

    parseStatus(data) {
        const parsed = {};
        data.split(/\r?\n/).forEach(line => {
            const match = line.match(/^(\w+)[=:]\s*(.+)/);
            if (match) {
                parsed[match[1].toLowerCase()] = match[2].trim();
            }
        });
        this.displayStatus(parsed);
    },

    // Refactored to use DOM APIs instead of innerHTML
    displayStatus(data) {
        ui.deviceStatus.classList.remove('hidden');
        ui.statusGrid.innerHTML = ''; // Clear previous content

        const groups = {
            'ç³»ç»ŸçŠ¶æ€': [ { key: 'state', label: 'çŠ¶æ€' }, { key: 'swd', label: 'SWDçƒ§å½•' } ],
            'ç”µæºä¿¡æ¯': [ { key: 'vout', label: 'å·¥ä½œç”µå‹' }, { key: 'iout', label: 'å·¥ä½œç”µæµ' }, { key: 'pout', label: 'å·¥ä½œåŠŸè€—' } ],
            'æ¨¡æ‹Ÿè¾“å…¥': [ { key: 'ai0', label: 'DCDCè¾“å‡º' }, { key: 'ai1', label: 'WIFI/4Gä¾›ç”µ' }, { key: 'ai2', label: 'MCUä¾›ç”µ' } ],
            'é¢œè‰²ä¼ æ„Ÿå™¨': [ { key: 'tcs', label: 'TCSçŠ¶æ€' }, { key: 'color_r', label: 'R' }, { key: 'color_g', label: 'G' }, { key: 'color_b', label: 'B' }, { key: 'color_c', label: 'C' } ]
        };

        Object.entries(groups).forEach(([title, items]) => {
            const panel = createElement('div', { className: 'panel' });
            panel.appendChild(createElement('h4', { text: title }));

            items.forEach(item => {
                const value = data[item.key] || '-';
                const itemDiv = createElement('div', { className: 'status-item' });
                itemDiv.appendChild(createElement('span', { text: `${item.label}:` }));

                let cls = '';
                if (item.key === 'state') cls = data.state === 'Ready' ? 'status-ready' : 'status-wait';
                else if (item.key === 'swd' || item.key === 'tcs') cls = data[item.key] === 'ON' ? 'status-on' : 'status-off';
                
                const valueSpan = createElement('span', { text: value, className: `status-value ${cls}` });
                itemDiv.appendChild(valueSpan);
                panel.appendChild(itemDiv);
            });
            
            if (title === 'é¢œè‰²ä¼ æ„Ÿå™¨' && data.color_r && data.color_g && data.color_b) {
                const colorPreview = createElement('div', { className: 'color-preview' });
                colorPreview.style.backgroundColor = `rgb(${data.color_r},${data.color_g},${data.color_b})`;
                panel.appendChild(colorPreview);
            }
            ui.statusGrid.appendChild(panel);
        });
    },

    async startTest(sn) {
        if (!this.test.port || this.testing || !sn) return;
        
        this.testing = true;
        this.updateButtons();
        this.updateUI('testMsg', 'â³ æ­£åœ¨æµ‹è¯•...');
        this.clearLog();
        this.log(`ğŸš€ å¼€å§‹æµ‹è¯• SN: ${sn}`);

        this.testTimeout = setTimeout(() => {
            this.log('â° æµ‹è¯•è¶…æ—¶');
            this.finishTest({ sn, serial: false, web: false });
        }, config.timeouts.test);

        try {
            await this.test.disconnect(); // Ensure clean state
            if (!await this.test.connect(config.baudRates.test)) {
                throw new Error('æµ‹è¯•ä¸²å£è¿æ¥å¤±è´¥');
            }

            const command = `ccmd DSN;${sn}\n`;
            await this.test.writer.write(new TextEncoder().encode(command));
            this.log(`ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ${command.trim()}`);
            
            this.startTestReadLoop(sn);

        } catch (e) {
            this.log(`âŒ æµ‹è¯•å¯åŠ¨å¤±è´¥: ${e.message}`);
            this.finishTest({ sn, serial: false, web: false });
        }
    },
    
    startTestReadLoop(sn) {
        this.processingData = false;
        this.test.buffer = '';
        this.test.readLoop(
            (textData) => {
                if (this.processingData) return;
                this.test.buffer += textData;
                const match = this.test.buffer.match(/DSN;(\S+)/);
                if (match) {
                    this.processingData = true; // Prevent multiple triggers
                    this.handleDSNResponse({ sn: match[1].trim(), imei: null, iccid: null, serial: true });
                }
            },
            (e) => {
                if(this.testing) {
                    this.log(`âŒ æµ‹è¯•ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                    this.finishTest({ sn, serial: false, web: false });
                }
            }
        );
    },

    async handleDSNResponse(result) {
        this.log(`âœ… ä¸²å£é€šä¿¡æˆåŠŸ, æ”¶åˆ° SN: ${result.sn}`);
        this.updateUI('testMsg', 'ğŸ”— æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...');
        const webResult = await this.testWebConnection(result.sn);
        result.web = webResult;
        this.finishTest(result);
    },

    async testWebConnection(sn) {
        const testUrl = await generateTestUrl(sn);
        if (!testUrl) {
            this.log('âŒ URL ç”Ÿæˆå¤±è´¥');
            return false;
        }
        this.log(`ğŸŒ æµ‹è¯•ç½‘å€: ${testUrl}`);

        const fetchData = async (url, timeout) => {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(url, { signal: controller.signal, mode: 'cors', cache: 'no-cache' });
                return response.ok;
            } finally {
                clearTimeout(timeoutId);
            }
        };

        try {
            if (await fetchData(testUrl, config.timeouts.fetch)) {
                this.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ (ç›´è¿)');
                return true;
            }
        } catch (e) {
            this.log(`ğŸŸ¡ ç›´è¿å¤±è´¥: ${e.message}. å°è¯•ä½¿ç”¨ä»£ç†...`);
        }

        for (const proxy of config.urls.proxies) {
            try {
                const proxyUrl = proxy + encodeURIComponent(testUrl);
                this.log(`ğŸ”„ å°è¯•ä»£ç†: ${new URL(proxy).hostname}`);
                if (await fetchData(proxyUrl, config.timeouts.proxyFetch)) {
                    this.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ (é€šè¿‡ä»£ç†)');
                    return true;
                }
            } catch (e) {
                this.log(`âŒ ä»£ç†å¤±è´¥: ${e.message}`);
            }
        }

        this.log('âŒ æ‰€æœ‰ç½‘ç»œæµ‹è¯•å‡å¤±è´¥');
        return false;
    },

    async finishTest(result) {
        if (!this.testing) return;
        
        clearTimeout(this.testTimeout);
        this.testTimeout = null;

        const finalResult = {
            timestamp: Date.now(),
            sn: result.sn || ui.scanInput.value,
            imei: result.imei || '-',
            iccid: result.iccid || '-',
            serial: result.serial,
            web: result.web,
            status: result.serial && result.web ? 'é€šè¿‡' : 'ä¸é€šè¿‡'
        };

        this.addTestResult(finalResult);
        this.log(`ğŸ“Š æµ‹è¯•å®Œæˆ: ${finalResult.status}`);
        this.updateUI('testMsg', `âœ… æµ‹è¯•å®Œæˆ: ${finalResult.status}`, finalResult.status === 'é€šè¿‡' ? 'success' : 'error');
        
        await this.test.disconnect();
        this.testing = false;
        this.processingData = false;
        this.updateButtons();
        ui.scanInput.value = '';
        ui.scanInput.focus();
    },

    // Refactored to use DOM APIs and fix the bug
    addTestResult(result) {
        // BUG FIX: Add record to the array for saving
        this.records.unshift(result);

        const row = ui.resultBody.insertRow(0); // Insert at the top
        const passFail = (val) => val ? 'pass' : 'fail';
        const normalAbnormal = (val) => val ? 'æ­£å¸¸' : 'å¼‚å¸¸';

        row.insertCell().textContent = new Date(result.timestamp).toLocaleString();
        row.insertCell().textContent = result.sn;
        row.insertCell().textContent = result.imei;
        row.insertCell().textContent = result.iccid;
        const serialCell = row.insertCell();
        serialCell.textContent = normalAbnormal(result.serial);
        serialCell.className = passFail(result.serial);
        const webCell = row.insertCell();
        webCell.textContent = normalAbnormal(result.web);
        webCell.className = passFail(result.web);
        const statusCell = row.insertCell();
        statusCell.textContent = result.status;
        statusCell.className = passFail(result.status === 'é€šè¿‡');
    },

    saveRecords() {
        if (this.records.length === 0) {
            alert('æ²¡æœ‰æµ‹è¯•è®°å½•å¯ä¾›ä¿å­˜ã€‚');
            return;
        }

        const header = ['æ—¶é—´', 'SN', 'IMEI', 'ICCID', 'ä¸²å£é€šä¿¡', 'ç½‘é¡µè®¿é—®', 'æµ‹è¯•ç»“æœ'];
        const rows = this.records.map(r => [
            new Date(r.timestamp).toLocaleString('zh-CN'),
            r.sn, r.imei, r.iccid,
            r.serial ? 'æ­£å¸¸' : 'å¼‚å¸¸',
            r.web ? 'æ­£å¸¸' : 'å¼‚å¸¸',
            r.status
        ]);
        
        const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
        const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' }); // Add BOM for Excel
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `æ•°æ®æ£’æµ‹è¯•è®°å½•_${new Date().toISOString().slice(0,10)}.csv`;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        this.log('ğŸ’¾ æµ‹è¯•è®°å½•å·²ä¿å­˜');
    },

    setupEventListeners() {
        ui.selectStatusBtn.addEventListener('click', () => this.selectPort('status'));
        ui.connectStatusBtn.addEventListener('click', () => this.connect('status'));
        ui.disconnectStatusBtn.addEventListener('click', () => this.disconnect('status'));

        ui.selectTestBtn.addEventListener('click', () => this.selectPort('test'));
        ui.saveRecordsBtn.addEventListener('click', () => this.saveRecords());
        
        ui.scanInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const value = ui.scanInput.value.trim();
                if (value && !this.testing) {
                    this.startTest(value);
                } else if(this.testing) {
                    this.log('âš ï¸ æµ‹è¯•è¿›è¡Œä¸­ï¼Œè¯·å‹¿é‡å¤æ‰«ç ');
                }
            }
        });
        
        // Keep focus on the scan input for scanner usage
        ui.scanInput.addEventListener('blur', () => {
             if (!this.testing) setTimeout(() => ui.scanInput.focus(), 100);
        });
    },

    async init() {
        this.setupEventListeners();
        
        const savedStatusPort = await this.loadPortSelection('status');
        if (savedStatusPort) {
            this.status.port = savedStatusPort;
            this.updateUI('statusMsg', 'âœ… çŠ¶æ€ä¸²å£å·²åŠ è½½');
        }
        
        const savedTestPort = await this.loadPortSelection('test');
        if (savedTestPort) {
            this.test.port = savedTestPort;
            this.updateUI('testMsg', 'âœ… æµ‹è¯•ä¸²å£å·²åŠ è½½');
        }

        this.updateButtons();
        ui.scanInput.focus();
        this.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
    }
};

// --- Entry Point ---
if ('serial' in navigator) {
    app.init();
} else {
    alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
    document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>';
}

</script>
</body>
</html>
