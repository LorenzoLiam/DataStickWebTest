<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>DGS-100 å•æ¿æµ‹è¯•</title>
    <style>
        body { font-family: system-ui, -apple-system, Roboto, sans-serif; padding: 20px; background: #f4f7f6; color: #333; line-height: 1.6; }
        .btn { margin: 5px; padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background: #fff; transition: background-color 0.2s, box-shadow 0.2s; }
        .btn:hover:not(:disabled) { background: #e9e9e9; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #f0f0f0; }
        .panel { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .panel-green { border-color: #28a745; background: #f0fff0; }
        .panel-blue { border-color: #007bff; background: #f0f8ff; }
        .status-reporting { color: #ffc107; }
        .status-report-success { color: #28a745; }
        .status-report-failed { color: #dc3545; }
        .flex { display: flex; gap: 15px; flex-wrap: wrap; }
        .flex > div { flex: 1; min-width: 280px; }
        .status-item { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .status-item span:first-child { color: #555; }
        .status-value { font-weight: 600; }
        .status-ready, .status-on { color: #28a745; }
        .status-wait { color: #ffc107; }
        .status-off { color: #6c757d; }
        table { border-collapse: collapse; width: 100%; margin: 15px 0; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background: #f8f9fa; color: #495057; font-weight: 600; }
        .pass { background: #d1f2d1; color: #28a745; }
        .fail { background: #f8d7da; color: #dc3545; }
        .testing { background: #fff3cd; color: #856404; }
        #logBox { margin: 10px 0; padding: 10px; border: 1px solid #ddd; height: 150px; overflow-y: auto; background: #f9f9f9; color: #333; font-family: monospace; white-space: pre-wrap; word-break: break-all; border-radius: 4px; }
        #testResultDisplay {
            margin: 15px 0; padding: 20px; border-radius: 8px; text-align: center; font-size: 30px; font-weight: bold; box-shadow: 0 3px 6px rgba(0,0,0,0.1); display: none;
        }
        #testResultDisplay.pass { background: linear-gradient(135deg, #28a745, #20c997); color: white; border: 2px solid #1e7e34; } /* #212529 */
        #testResultDisplay.fail { background: linear-gradient(135deg, #dc3545, #ff6b6b); color: white; border: 2px solid #bd2130; }
        #testResultDisplay.waiting { background: linear-gradient(135deg, #ffc107, #ffb347); color: white; border: 2px solid #e0a800; display: block; }
        input[type="text"] { width: 180px; padding: 6px; margin-left: 8px; border: 1px solid #ddd; border-radius: 3px; }
    </style>
</head>
<body>
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
    <h1>å•æ¿æµ‹è¯•</h1>
    <div style="display: flex; gap: 10px;">
        <button class="btn" id="switchInterfaceBtn" style="background: #28a745; color: #fff; font-weight: 600;">åˆ‡æ¢åˆ°æ•´æœºæµ‹è¯•</button>
    </div>
</div>

<div class="panel">
    <div class="flex">
        <div class="panel panel-green">
            <h4>æµ‹è¯•æ¶ä¸²å£-D</h4>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="selectStatusBtn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="toggleStatusBtn">è¿æ¥</button>
                <div id="statusMsg"></div>
            </div>
        </div>
        <div class="panel panel-blue">
            <h4>æ•°æ®æ£’ä¸²å£-A</h4>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="selectTestBtn">é€‰æ‹©ä¸²å£</button>
                <button class="btn" id="toggleTestBtn">è¿æ¥</button>
                <label for="scanInput">SN:</label>
                <input type="text" id="scanInput" placeholder="è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...">
                <div id="testMsg"></div>
            </div>
        </div>
    </div>
</div>

<div class="panel">
    <table>
        <thead>
            <tr><th>æ—¶é—´</th><th>SN</th><th>IMEI</th><th>ICCID</th><th>ä¸²å£é€šä¿¡</th><th>å·¥ä½œç”µå‹</th><th>å·¥ä½œç”µæµ</th><th>DCDC</th><th>ç½‘ç»œä¾›ç”µ</th><th>MCUä¾›ç”µ</th><th>ç”µæºç¯</th><th>ä¸²å£ç¯</th><th>ç½‘ç»œç¯</th><th>ç½‘é¡µè®¿é—®</th><th>æµ‹è¯•ç»“æœ</th><th>ä¸ŠæŠ¥çŠ¶æ€</th></tr>
        </thead>
        <tbody id="resultBody"></tbody>
    </table>
</div>

<div id="logBox">æµ‹è¯•æ—¥å¿—...</div>

<div id="testResultDisplay">ç­‰å¾…æµ‹è¯•...</div>

<script>
const config = {
    aes: { keyString: "me%ov2Ied|eicegh", ivString: "me%ov2Ied|eicegh" },
    urls: { test: "http://gw.3wlink.cn:22011/?dgwkey=", report: "https://eoy7ueylk4yybg6.m.pipedream.net" },
    baudRates: { status: 115200, test: 10000000 },
    timeouts: { dsn: 3000, imei: 3000, iccid: 3000, rst: 15000, led: 2000, fetch: 5000, report: 10000 },
    sampling: { count: 4, interval: 500 },
    autoReport: true,
    maxRetries: 3
};

const ui = {
    selectStatusBtn: document.getElementById('selectStatusBtn'),
    toggleStatusBtn: document.getElementById('toggleStatusBtn'),
    statusMsg: document.getElementById('statusMsg'),
    selectTestBtn: document.getElementById('selectTestBtn'),
    toggleTestBtn: document.getElementById('toggleTestBtn'),
    scanInput: document.getElementById('scanInput'),
    testMsg: document.getElementById('testMsg'),
    resultBody: document.getElementById('resultBody'),
    logBox: document.getElementById('logBox'),
    testResultDisplay: document.getElementById('testResultDisplay')
};

const DgwCrypto = {
    _key: null, _iv: null,
    async init() {
        if (this._key) return;
        try {
            const keyBytes = new TextEncoder().encode(config.aes.keyString);
            this._iv = new TextEncoder().encode(config.aes.ivString);
            this._key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CBC' }, false, ['encrypt']);
        } catch (error) {
            console.error(":", error);
            throw error;
        }
    },
    async encrypt(plainText) {
        if (!this._key) { await this.init(); }
        try {
            const textBytes = new TextEncoder().encode(plainText);
            const blockSize = 16;
            let paddedData;
            if (textBytes.length % blockSize === 0) {
                paddedData = new Uint8Array(textBytes);
            } else {
                const paddingNeeded = blockSize - (textBytes.length % blockSize);
                paddedData = new Uint8Array(textBytes.length + paddingNeeded);
                paddedData.set(textBytes);
            }
            const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this._iv }, this._key, paddedData);
            const encryptedArray = new Uint8Array(encrypted);
            const truncated = encryptedArray.slice(0, paddedData.length);
            const base64 = btoa(String.fromCharCode(...truncated));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        } catch (error) {
            console.error('åŠ å¯†å¤±è´¥:', error);
            return null;
        }
    }
};

class SerialManager {
    constructor(type) {
        this.type = type;
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.connected = false;
        this.buffer = '';
        this.readLoopActive = false;
    }
    async select() {
        try {
            this.port = await navigator.serial.requestPort();
            return true;
        } catch {
            return false;
        }
    }
    async connect(baudRate) {
        if (!this.port) return false;
        try {
            await this.port.open({ baudRate });
            this.writer = this.port.writable?.getWriter();
            this.connected = true;
            return true;
        } catch (e) {
            console.error(`${this.type} connection failed:`, e);
            return false;
        }
    }
    async disconnect() {
        await this.stopReadLoop();
        if (this.writer) { try { await this.writer.close(); } catch {} finally { this.writer = null; } }
        if (this.port) { try { await this.port.close(); } catch {} }
        this.connected = false;
        this.buffer = '';
    }
    async readLoop(onData, onError) {
        if (!this.port?.readable || !this.connected) return;
        this.readLoopActive = true;
        this.reader = this.port.readable.getReader();
        try {
            while (this.readLoopActive) {
                const { value, done } = await this.reader.read();
                if (done) break;
                if (onData) onData(new TextDecoder().decode(value));
            }
        } catch (e) {
            if (this.readLoopActive && onError) onError(e);
        } finally {
            if (this.reader) {
                this.reader.releaseLock();
                this.reader = null;
            }
            this.readLoopActive = false;
        }
    }
    async stopReadLoop() {
        if (this.readLoopActive) {
            this.readLoopActive = false;
            if (this.reader) {
                try { await this.reader.cancel(); } catch {}
            }
        }
    }
}

const UIManager = {
    init(appState) {
        this.state = appState;
    },
    log(msg) {
        ui.logBox.textContent += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
        ui.logBox.scrollTop = ui.logBox.scrollHeight;
    },
    clearLog() {
        ui.logBox.textContent = 'æµ‹è¯•æ—¥å¿—...';
    },
    update(id, text, type = 'info') {
        const el = ui[id];
        if (el) {
            el.textContent = text;
            el.style.color = { error: 'red', success: 'green', info: 'black' }[type] || 'black';
        }
    },
    updateButtons(app) {
        ui.toggleStatusBtn.textContent = app.serial.status.connected ? 'æ–­å¼€' : 'è¿æ¥';
        ui.toggleStatusBtn.disabled = !app.serial.status.port && !app.serial.status.connected;
        ui.toggleTestBtn.textContent = app.serial.test.connected ? 'æ–­å¼€' : 'è¿æ¥';
        ui.toggleTestBtn.disabled = !app.serial.test.port && !app.serial.test.connected;
        ui.selectTestBtn.disabled = this.state.test.inProgress;
        ui.scanInput.disabled = this.state.test.inProgress || !this.state.device.ready || !app.serial.test.connected;
        ui.scanInput.placeholder = !this.state.device.ready ? 'è®¾å¤‡æœªå°±ç»ªï¼Œè¯·è¿æ¥çŠ¶æ€ä¸²å£...' : !app.serial.test.connected ? 'è¯·è¿æ¥æµ‹è¯•ä¸²å£...' : 'è¯·ä½¿ç”¨æ‰«ç æªæ‰«æ...';
    },
    addOrUpdateTestResult(record) {
        if (!record.row) return;
        const getStatus = (val) => {
            if (val === true) return { text: 'æ­£å¸¸', className: 'pass' };
            if (val === false) return { text: 'å¼‚å¸¸', className: 'fail' };
            if (val === 'æœªæ’å¡') return { text: 'æœªæ’å¡', className: 'fail' };
            if (val === '-') return { text: '-', className: '' };
            return { text: 'å¾…æµ‹è¯•', className: '' };
        };
        const updateCell = (cell, { text, className = '' }) => {
            cell.textContent = text;
            cell.className = className;
        };
        const columns = [
            { text: new Date(record.timestamp).toLocaleString() },
            { text: record.sn, className: record.snMismatch ? 'fail' : record.snMatch ? 'pass' : '' },
            { text: record.imei, className: record.imei !== 'å¾…æµ‹è¯•' && record.imei !== '-' ? 'pass' : record.imeiFailed ? 'fail' : '' },
            { text: record.iccid, className: record.iccid === 'æœªæ’å¡' || record.iccidFailed ? 'fail' : record.iccid !== 'å¾…æµ‹è¯•' && record.iccid !== '-' ? 'pass' : '' },
            getStatus(record.serial),
            getStatus(record.vout),
            getStatus(record.iout),
            getStatus(record.ai0),
            getStatus(record.ai1),
            getStatus(record.ai2),
            getStatus(record.powerLight),
            getStatus(record.rs485Light),
            getStatus(record.networkLight),
            getStatus(record.web),
            record.status === 'pending' ? { text: 'æ­£åœ¨æµ‹è¯•...', className: 'testing' } : getStatus(record.status),
            record.reportFailed ? { text: 'æœªä¸ŠæŠ¥', className: 'fail' } : record.reported ? { text: 'å·²ä¸ŠæŠ¥', className: 'pass' } : { text: 'å¾…ä¸ŠæŠ¥', className: 'testing' }
        ];
        columns.forEach((col, i) => updateCell(record.row.cells[i], col));
    },
    showTestResult(passed) {
        const display = ui.testResultDisplay;
        display.style.display = 'block';
        if (passed === 'waiting') {
            display.textContent = 'â³ æ­£åœ¨æµ‹è¯•...';
            display.className = 'waiting';
        } else if (passed) {
            display.textContent = 'âœ… é€šè¿‡';
            display.className = 'pass';
        } else {
            display.textContent = 'âŒ ä¸é€šè¿‡';
            display.className = 'fail';
        }
    }
};

const RecordManager = {
    init(records, uiManager) {
        this.records = records;
        this.uiManager = uiManager;
    },
    createOrUpdate(partialResult) {
        let record;
        if (partialResult.isNewTest) {
            ui.resultBody.innerHTML = '';
            this.records.length = 0;
            record = { sn: partialResult.sn, row: ui.resultBody.insertRow(0) };
            this.records.push(record);
            for (let i = 0; i < 16; i++) record.row.insertCell();
            Object.assign(record, {
                timestamp: Date.now(), imei: 'å¾…æµ‹è¯•', iccid: 'å¾…æµ‹è¯•', vout: 'pending', iout: 'pending',
                ai0: 'pending', ai1: 'pending', ai2: 'pending', powerLight: 'pending', rs485Light: 'pending',
                networkLight: 'pending', serial: 'pending', web: 'pending', status: 'pending',
                snMismatch: false, snMatch: false, reported: false, reportFailed: false, imeiFailed: false, iccidFailed: false
            });
        } else {
            record = this.records.find(r => r.sn === partialResult.sn);
            if (!record) return null;
        }
        Object.assign(record, partialResult);
        this.uiManager.addOrUpdateTestResult(record);
        return record;
    },
    async report(failureItems = []) {
        if (!this.records.length) {
            this.uiManager.log('âš ï¸ æ²¡æœ‰æµ‹è¯•ç»“æœå¯ä¸ŠæŠ¥');
            return;
        }
        this.uiManager.log('ğŸ“® ä¸ŠæŠ¥æµ‹è¯•ç»“æœ...');
        try {
            const recordsToReport = this.records.filter(r => r.status !== 'pending' && !r.reported);
            const reportData = {
                deviceId: 'DGS-100',
                results: recordsToReport.map(r => {
                    const payload = {
                        sn: r.sn,
                        imei: (r.imei && r.imei !== 'å¾…æµ‹è¯•') ? r.imei : undefined,
                    };

                    if (r.iccid && r.iccid !== 'æœªæ’å¡' && r.iccid !== 'å¾…æµ‹è¯•') {
                        payload.iccid = r.iccid;
                    }

                    if (failureItems.length > 0) {
                        payload.failureItems = failureItems[0];
                    } else {
                        payload.serialTest = r.serial === true ? 'pass' : 'fail';
                        payload.webTest = r.web === true ? 'pass' : 'fail';
                        payload.overallStatus = r.status === true ? 'pass' : 'fail';
                    }
                    return payload;
                })
            };
            const response = await fetch(config.urls.report, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'User-Agent': 'DGS-100-Tester/1.0' },
                body: JSON.stringify(reportData),
                signal: AbortSignal.timeout(config.timeouts.report)
            });
            if (response.ok) {
                this.uiManager.log(`âœ… ä¸ŠæŠ¥æˆåŠŸï¼Œå“åº”: ${response.status}`);
                recordsToReport.forEach(record => this.createOrUpdate({ sn: record.sn, reported: true, reportFailed: false }));
            } else {
                throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status} - ${response.statusText}`);
            }
        } catch (error) {
            this.uiManager.log(`âŒ ç»“æœä¸ŠæŠ¥å¤±è´¥: ${error.message}`);
            this.records.filter(r => r.status !== 'pending' && !r.reported).forEach(record => this.createOrUpdate({ sn: record.sn, reportFailed: true }));
        }
    }
};

const app = {
    state: { 
        reporting: false, 
        test: { 
            inProgress: false, 
            currentSN: '', 
            currentStep: '', 
            stepTimeouts: {}, 
            stepRetryCount: {}, 
            skipWebTest: false,
            hasFailure: false,
            failureItems: []
        }, 
        device: { ready: false, status: null, colorR: 0 } 
    },
    serial: { status: new SerialManager('status'), test: new SerialManager('test') },
    records: [],
    async init() {
        UIManager.init(this.state);
        RecordManager.init(this.records, UIManager);
        try {
            await DgwCrypto.init();
        } catch (e) {
            alert('URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼Œæµ‹è¯•åŠŸèƒ½å·²ç¦ç”¨ã€‚');
            UIManager.log('âŒ URLåŠ å¯†æ¨¡å—åˆå§‹åŒ–å¤±è´¥!');
            return;
        }
        this.setupEventListeners();
        await this.loadSavedPorts();
        UIManager.updateButtons(this);
        ui.scanInput.focus();
        UIManager.log('åº”ç”¨ç¨‹åºå·²åˆå§‹åŒ–ï¼Œè¯·è¿æ¥ä¸²å£å¹¶å¼€å§‹æµ‹è¯•ã€‚');
    },
    setupEventListeners() {
        ui.selectStatusBtn.addEventListener('click', () => this.selectPort('status'));
        ui.toggleStatusBtn.addEventListener('click', () => this.toggleConnection('status'));
        ui.selectTestBtn.addEventListener('click', () => this.selectPort('test'));
        ui.toggleTestBtn.addEventListener('click', () => this.toggleConnection('test'));
        ui.scanInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const value = ui.scanInput.value.trim();
                if (value && !this.state.test.inProgress) {
                    TestRunner.startTest(value, this);
                } else if (this.state.test.inProgress) {
                    UIManager.log('âš ï¸ æµ‹è¯•è¿›è¡Œä¸­ï¼Œè¯·å‹¿é‡å¤æ‰«ç ');
                }
            }
        });
        ui.scanInput.addEventListener('blur', () => {
            if (!this.state.test.inProgress) setTimeout(() => ui.scanInput.focus(), 100);
        });
        //document.getElementById('switchInterfaceBtn').addEventListener('click', () => window.location.href = 'complete_machine.html');
        document.getElementById('switchInterfaceBtn').addEventListener('click', () => { const targetPage = 'complete_machine.html'; window.location.href = `${targetPage}?v=${Date.now()}`;});
    },
    async loadSavedPorts() {
        const load = async type => {
            try {
                const savedIndex = localStorage.getItem(`serialPort_${type}`);
                if (savedIndex !== null) {
                    const allPorts = await navigator.serial.getPorts();
                    const port = allPorts[parseInt(savedIndex, 10)];
                    if (port) {
                        this.serial[type].port = port;
                        UIManager.update(`${type}Msg`, 'âœ… ä¸²å£å·²åŠ è½½');
                    }
                }
            } catch (e) {
                console.error('æœªèƒ½åŠ è½½ç«¯å£é€‰æ‹©:', e);
            }
        };
        await Promise.all([load('status'), load('test')]);
    },
    async selectPort(type) {
        const manager = this.serial[type];
        if (await manager.select()) {
            UIManager.update(`${type}Msg`, 'âœ… ä¸²å£å·²é€‰æ‹©', 'success');
            try {
                const allPorts = await navigator.serial.getPorts();
                const portIndex = allPorts.indexOf(manager.port);
                if (portIndex > -1) {
                    localStorage.setItem(`serialPort_${type}`, portIndex);
                    UIManager.log(`ğŸ’¾ å·²ä¿å­˜ ${type === 'status' ? 'çŠ¶æ€' : 'æµ‹è¯•'} ä¸²å£é€‰æ‹©`);
                }
            } catch (e) {
                console.error('ä¿æŒé€‰æ‹©ç«¯å£å¤±è´¥:', e);
            }
        }
        UIManager.updateButtons(this);
    },
    async toggleConnection(type) {
        const manager = this.serial[type];
        if (manager.connected) {
            await manager.disconnect();
            UIManager.update(`${type}Msg`, 'â„¹ï¸ å·²æ–­å¼€');
            if (type === 'status') this.state.device.ready = false;
        } else {
            UIManager.update(`${type}Msg`, 'âŒ› è¿æ¥ä¸­...');
            if (await manager.connect(config.baudRates[type])) {
                UIManager.update(`${type}Msg`, 'âœ… å·²è¿æ¥', 'success');
                if (type === 'status') TestRunner.startStatusReadLoop(this);
            } else {
                UIManager.update(`${type}Msg`, 'âŒ è¿æ¥å¤±è´¥', 'error');
            }
        }
        UIManager.updateButtons(this);
    }
};

const TestRunner = {
    async startTest(sn, app) {
        if (!app.serial.test.port || app.state.test.inProgress || !sn || !app.state.device.ready) {
            if (!app.state.device.ready) UIManager.log('âš ï¸ è®¾å¤‡æœªå°±ç»ªï¼Œæ— æ³•å¼€å§‹æµ‹è¯•');
            return;
        }
        app.state.test.inProgress = true;
        app.state.test.stepRetryCount = {};
        app.state.test.skipWebTest = false;
        app.state.test.hasFailure = false;
        app.state.test.failureItems = [];
        UIManager.updateButtons(app);
        UIManager.update('testMsg', 'â³ æ­£åœ¨æµ‹è¯•...');
        UIManager.clearLog();
        UIManager.log(`ğŸš€ å¼€å§‹æµ‹è¯• SN: ${sn}`);
        UIManager.showTestResult('waiting');
        RecordManager.createOrUpdate({ sn, isNewTest: true });
        try {
            if (!app.serial.test.connected) throw new Error('æµ‹è¯•ä¸²å£æœªè¿æ¥');
            app.state.test.currentStep = 'WAITING_FOR_DSN';
            await this.startTestReadLoop(sn, app);
            app.serial.test.buffer = '';
            const command = `ccmd DSN;${sn}\r\n`;
            await app.serial.test.writer.write(new TextEncoder().encode(command));
            UIManager.log(`ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ${command.trim()}`);
        } catch (e) {
            UIManager.log(`âŒ æµ‹è¯•å¯åŠ¨å¤±è´¥: ${e.message}`);
            await this.finishTest({ sn, serial: false, web: false }, app);
        }
    },
    async startTestReadLoop(sn, app) {
        await app.serial.test.stopReadLoop();
        app.state.test.currentSN = sn;
        const stepHandlers = {
            'WAITING_FOR_DSN': buffer => this.handleDsnResponse(buffer, sn, app),
            'WAITING_FOR_IMEI': buffer => this.handleImeiResponse(buffer, sn, app),
            'WAITING_FOR_ICCID': buffer => this.handleIccidResponse(buffer, sn, app)
        };
        app.serial.test.readLoop(async text => {
            app.serial.test.buffer += text;
            const handler = stepHandlers[app.state.test.currentStep];
            if (handler && (app.serial.test.buffer.includes('\n') || app.serial.test.buffer.includes('\r'))) {
                await handler(app.serial.test.buffer);
            }
        }, e => {
            if (app.state.test.inProgress) {
                UIManager.log(`âŒ æµ‹è¯•ä¸²å£è¯»å–å¼‚å¸¸: ${e.message}`);
                this.finishTest({ sn, serial: false, web: false }, app);
            }
        });
        this.setStepTimeout('WAITING_FOR_DSN', () => this.retryOrFail('WAITING_FOR_DSN', sn, app, () => {
            app.serial.test.writer.write(new TextEncoder().encode(`ccmd DSN;${sn}\r\n`));
        }, 'ä¸²å£é€šä¿¡'), config.timeouts.dsn, app);
    },
    async retryOrFail(step, sn, app, retryFn, failItemOrCallback) {
        const count = app.state.test.stepRetryCount[step] = (app.state.test.stepRetryCount[step] || 0) + 1;
        if (count <= config.maxRetries) {
            UIManager.log(`ğŸ”„ ${step}å“åº”è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯• (${count}/${config.maxRetries})...`);
            retryFn();
            this.setStepTimeout(step, () => this.retryOrFail(step, sn, app, retryFn, failItemOrCallback), config.timeouts[step.replace('WAITING_FOR_', '').toLowerCase()], app);
        } else {
            if (typeof failItemOrCallback === 'function') {
                await failItemOrCallback();
            } else {
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push(failItemOrCallback || `${step}è¶…æ—¶`);
                this.skipRemainingTests(sn, app);
            }
        }
    },
    async handleDsnResponse(buffer, sn, app) {
        const match = buffer.match(/DSN;(\S+?)[\r\n]/);
        if (!match) return;
        this.clearStepTimeout('WAITING_FOR_DSN', app);
        const receivedValue = match[1].trim();
        if (receivedValue === sn) {
            UIManager.log(`âœ… æ”¶åˆ° DSN: ${receivedValue}ï¼ŒSN åŒ¹é…æˆåŠŸ`);
            RecordManager.createOrUpdate({ sn, snMatch: true });
            await this.startImeiTest(sn, app);
        } else {
            UIManager.log(`âŒ SNä¸åŒ¹é…! å‘é€: ${sn}, æ”¶åˆ°: ${receivedValue}`);
            const count = app.state.test.stepRetryCount['WAITING_FOR_DSN'] = (app.state.test.stepRetryCount['WAITING_FOR_DSN'] || 0) + 1;
            if (count <= config.maxRetries) {
                UIManager.log(`ğŸ”„ SNä¸åŒ¹é…ï¼Œæ­£åœ¨é‡è¯• (${count}/${config.maxRetries})...`);
                app.serial.test.buffer = '';
                await app.serial.test.writer.write(new TextEncoder().encode(`ccmd DSN;${sn}\r\n`));
                this.setStepTimeout('WAITING_FOR_DSN', () => this.retryOrFail('WAITING_FOR_DSN', sn, app, () => {
                    app.serial.test.buffer = '';
                    app.serial.test.writer.write(new TextEncoder().encode(`ccmd DSN;${sn}\r\n`));
                }, 'SNä¸åŒ¹é…'), config.timeouts.dsn, app);
                return;
            }
            RecordManager.createOrUpdate({ sn, snMismatch: true });
            app.state.test.hasFailure = true;
            app.state.test.failureItems.push('SNä¸åŒ¹é…');
            await this.skipRemainingTests(sn, app);
        }
        app.serial.test.buffer = '';
    },
    async handleImeiResponse(buffer, sn, app) {
        const match = buffer.match(/IME;(\S+?)[\r\n]/);
        if (!match) return;
        this.clearStepTimeout('WAITING_FOR_IMEI', app);
        const receivedValue = match[1].trim();
        if (receivedValue.toLowerCase() === 'error') {
            UIManager.log(`âŒ æ”¶åˆ° IME ERROR`);
            this.retryOrFail('WAITING_FOR_IMEI', sn, app, () => {
                app.serial.test.buffer = '';
                app.serial.test.writer.write(new TextEncoder().encode('ccmd IME\r\n'));
            }, () => {
                RecordManager.createOrUpdate({ sn, imei: 'å¾…æµ‹è¯•', imeiFailed: true });
                this.startIccidTest(sn, app);
            });
            return;
        } else {
            UIManager.log(`âœ… æ”¶åˆ° IME: ${receivedValue}`);
            RecordManager.createOrUpdate({ sn, imei: receivedValue });
        }
        await this.startIccidTest(sn, app);
        app.serial.test.buffer = '';
    },
    async handleIccidResponse(buffer, sn, app) {
        const match = buffer.match(/ICC;([^\r\n]*)[\r\n]/);
        if (!match) return;
        this.clearStepTimeout('WAITING_FOR_ICCID', app);
        const receivedValue = match[1].trim();
        if (receivedValue.toLowerCase() === 'error' || receivedValue === '' || receivedValue === ';') {
            UIManager.log(`âŒ æ”¶åˆ° ICC ${receivedValue === '' || receivedValue === ';' ? 'æ— å€¼ï¼Œæœªæ’å¡' : 'ERROR'}`);
            this.retryOrFail('WAITING_FOR_ICCID', sn, app, () => {
                app.serial.test.buffer = '';
                app.serial.test.writer.write(new TextEncoder().encode('ccmd ICC\r\n'));
            }, () => {
                RecordManager.createOrUpdate({ sn, iccid: 'æœªæ’å¡', iccidFailed: true });
                this.completeSerialTest(sn, app);
            });
            return;
        } else {
            UIManager.log(`âœ… æ”¶åˆ° ICC: ${receivedValue}`);
            RecordManager.createOrUpdate({ sn, iccid: receivedValue });
        }
        this.completeSerialTest(sn, app);
        app.serial.test.buffer = '';
    },
    async completeSerialTest(sn, app) {
        UIManager.log(`âœ… ä¸²å£é€šä¿¡æµ‹è¯•: æ­£å¸¸`);
        RecordManager.createOrUpdate({ sn, serial: true });
        const currentRecord = app.records.find(r => r.sn === sn);
        const skipWebTest = currentRecord?.iccid === 'æœªæ’å¡' || currentRecord?.iccidFailed;
        app.state.test.skipWebTest = skipWebTest;
        await this.startComponentAndLedTests(sn, app);
    },
    async startImeiTest(sn, app) {
        app.state.test.currentStep = 'WAITING_FOR_IMEI';
        try {
            await app.serial.test.writer.write(new TextEncoder().encode('ccmd IME\r\n'));
            UIManager.log('ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ccmd IME');
            this.setStepTimeout('WAITING_FOR_IMEI', () => this.retryOrFail('WAITING_FOR_IMEI', sn, app, () => {
                app.serial.test.writer.write(new TextEncoder().encode('ccmd IME\r\n'));
            }, () => {
                RecordManager.createOrUpdate({ sn, imei: 'å¾…æµ‹è¯•', imeiFailed: true });
                this.startIccidTest(sn, app);
            }), config.timeouts.imei, app);
        } catch (error) {
            UIManager.log(`âŒ å‘é€ IMEI æŸ¥è¯¢å‘½ä»¤å¤±è´¥: ${error.message}`);
            RecordManager.createOrUpdate({ sn, imei: 'å¾…æµ‹è¯•', imeiFailed: true });
            await this.startIccidTest(sn, app);
        }
    },
    async startIccidTest(sn, app) {
        app.state.test.currentStep = 'WAITING_FOR_ICCID';
        try {
            await app.serial.test.writer.write(new TextEncoder().encode('ccmd ICC\r\n'));
            UIManager.log('ğŸ“¤ å·²å‘é€æŒ‡ä»¤: ccmd ICC');
            this.setStepTimeout('WAITING_FOR_ICCID', () => this.retryOrFail('WAITING_FOR_ICCID', sn, app, () => {
                app.serial.test.writer.write(new TextEncoder().encode('ccmd ICC\r\n'));
            }, () => {
                RecordManager.createOrUpdate({ sn, iccid: 'æœªæ’å¡', iccidFailed: true });
                this.completeSerialTest(sn, app);
            }), config.timeouts.iccid, app);
        } catch (error) {
            UIManager.log(`âŒ å‘é€ ICCID æŸ¥è¯¢å‘½ä»¤å¤±è´¥: ${error.message}`);
            RecordManager.createOrUpdate({ sn, iccid: 'æœªæ’å¡', iccidFailed: true });
            await this.completeSerialTest(sn, app);
        }
    },
    async startComponentAndLedTests(sn, app) {
        if (app.state.test.hasFailure) {
            await this.skipRemainingTests(sn, app);
            return;
        }
        app.state.test.currentStep = 'COMPONENT_TESTS';
        const tests = [
            { key: 'vout', name: 'å·¥ä½œç”µå‹', low: 4.8, high: 5.1, unit: 'V' },
            { key: 'iout', name: 'å·¥ä½œç”µæµ', low: 50, high: 200, unit: 'mA' },
            { key: 'ai0', name: 'DCDCä¾›ç”µ', low: 3600, high: 4100, unit: 'mV' },
            { key: 'ai1', name: 'ç½‘ç»œä¾›ç”µ', low: 3600, high: 4100, unit: 'mV' },
            { key: 'ai2', name: 'MCUä¾›ç”µ', low: 3100, high: 3400, unit: 'mV' }
        ];
        for (const t of tests) {
            UIManager.log(`âš¡ æµ‹è¯•${t.name}...`);
            const val = await this.getAverageValue(() => parseFloat(app.state.device.status?.[t.key]) || 0);
            const pass = val >= t.low && val < t.high;
            UIManager.log(`ğŸ“Š ${t.name}: ${val.toFixed(3)}${t.unit}, ç»“æœ: ${pass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            RecordManager.createOrUpdate({ sn, [t.key]: pass });
            if (!pass) {
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push(t.name);
                await this.skipRemainingTests(sn, app);
                return;
            }
        }
        await this.startLedTests(sn, app);
    },
    async startLedTests(sn, app) {
        if (app.state.test.hasFailure) {
            await this.skipRemainingTests(sn, app);
            return;
        }
        await app.serial.status.writer.write(new TextEncoder().encode('AT+TCS=ON\r\n'));
        app.state.test.currentStep = 'LED_TESTS';
        UIManager.log('ğŸ” å¼€å§‹ LED æŒ‡ç¤ºç¯æµ‹è¯•...');
        const send = cmd => app.serial.test.writer.write(new TextEncoder().encode(cmd));
        const delay = ms => new Promise(res => setTimeout(res, ms));
        const getAvgColorR = () => this.getAverageValue(() => parseFloat(app.state.device.status?.color_r) || app.state.device.colorR || 0);

        const ledTests = [
            { cmd: 'ccmd LED;6;0\r\n', key: 'powerLight', name: 'ç”µæºæŒ‡ç¤ºç¯', threshold: 26, divisor: 1 },
            { cmd: 'ccmd LED;3;1\r\n', key: 'rs485Light', name: '485æŒ‡ç¤ºç¯', threshold: 26, divisor: 2 },
            { cmd: 'ccmd LED;4;1\r\n', key: 'networkLight', name: 'ç½‘ç»œæŒ‡ç¤ºç¯', threshold: 26, divisor: 3 }
        ];

        for (const test of ledTests) {
            let retryCount = 0;
            const runLedTest = async () => {
                await send(test.cmd);
                await delay(500);
                const colorR = await getAvgColorR();
                const pass = (colorR / test.divisor) > test.threshold;
                UIManager.log(`ğŸ“Š ${test.name} Color_R å¹³å‡å€¼: ${colorR.toFixed(3)}, ç»“æœ: ${pass ? 'æ­£å¸¸' : 'å¼‚å¸¸'}${retryCount > 0 ? ` (é‡è¯• ${retryCount}/${config.maxRetries})` : ''}`);
                return { pass, colorR };
            };

            let result = await runLedTest();
            while (!result.pass && retryCount < config.maxRetries) {
                retryCount++;
                UIManager.log(`ğŸ”„ ${test.name} æµ‹è¯•å¤±è´¥ï¼Œæ­£åœ¨é‡è¯• (${retryCount}/${config.maxRetries})...`);
                result = await runLedTest();
            }

            RecordManager.createOrUpdate({ sn, [test.key]: result.pass });
            if (!result.pass) {
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push(test.name);
                await this.skipRemainingTests(sn, app);
                return;
            }
        }

        if (app.state.test.skipWebTest) {
            const currentRecord = app.records.find(r => r.sn === sn);
            await this.finishTest({ ...currentRecord, sn, web: 'æœªæ’å¡', webFailed: true }, app);
        } else {
            await this.sendRstAndWait(sn, app);
        }
    },
    async sendRstAndWait(sn, app) {
        try {
            UIManager.log('ğŸ“¤ å‘é€ AT+RST å‘½ä»¤è¿›è¡Œè®¾å¤‡é‡ç½®...');
            app.serial.status.buffer = '';
            await app.serial.status.writer.write(new TextEncoder().encode('AT+RST\r\n'));
            app.state.test.currentStep = 'WAITING_FOR_RST';
            UIManager.log(`â³ ç­‰å¾… ${config.timeouts.rst / 1000} ç§’è®¾å¤‡é‡ç½®å®Œæˆ...`);
            await new Promise(resolve => setTimeout(resolve, config.timeouts.rst));
            UIManager.log('âœ… è®¾å¤‡é‡ç½®å®Œæˆï¼Œå¼€å§‹ç½‘ç»œè¿æ¥æµ‹è¯•');
            await this.startWebTest(sn, app);
        } catch (error) {
            UIManager.log(`âŒ å‘é€ AT+RST å‘½ä»¤å¤±è´¥: ${error.message}`);
            app.state.test.hasFailure = true;
            app.state.test.failureItems.push('è®¾å¤‡é‡ç½®');
            await this.skipRemainingTests(sn, app);
        }
    },
    async _generateTestUrl(sn) {
        const encrypted = await DgwCrypto.encrypt("DAAN" + sn);
        return encrypted ? `${config.urls.test}${encrypted}` : null;
    },
    async startWebTest(sn, app) {
        UIManager.update('testMsg', 'ğŸ”— æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...');
        const testUrl = await this._generateTestUrl(sn);
        let webResult = false;
        if (testUrl) {
            UIManager.log(`ğŸŒ æµ‹è¯•ç½‘å€: ${testUrl}`);
            try {
                const proxiedUrl = `https://cors.9185918.xyz/?url=${encodeURIComponent(testUrl)}`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), config.timeouts.fetch);
                const response = await fetch(proxiedUrl, { signal: controller.signal, mode: 'cors', cache: 'no-cache' });
                clearTimeout(timeoutId);
                if (response.ok) {
                    UIManager.log('âœ… ç½‘ç»œè®¿é—®æˆåŠŸ');
                    webResult = true;
                } else {
                    app.state.test.hasFailure = true;
                    app.state.test.failureItems.push('ç½‘é¡µè®¿é—®');
                }
            } catch (e) {
                UIManager.log(`âŒ ç½‘ç»œè®¿é—®å¤±è´¥: ${e.message}`);
                app.state.test.hasFailure = true;
                app.state.test.failureItems.push('ç½‘é¡µè®¿é—®');
            }
        } else {
            UIManager.log('âŒ URL ç”Ÿæˆå¤±è´¥');
            app.state.test.hasFailure = true;
            app.state.test.failureItems.push('ç½‘é¡µè®¿é—®');
        }
        const currentRecord = app.records.find(r => r.sn === sn);
        await this.finishTest({ ...currentRecord, sn, web: webResult }, app);
    },
    async skipRemainingTests(sn, app) {
        UIManager.log('âš ï¸ æ£€æµ‹åˆ°å¼‚å¸¸ï¼Œè·³è¿‡åç»­æµ‹è¯•æ­¥éª¤');
        const currentRecord = app.records.find(r => r.sn === sn);
        const skippedItems = {
            vout: currentRecord?.vout === 'pending' ? '-' : currentRecord?.vout,
            iout: currentRecord?.iout === 'pending' ? '-' : currentRecord?.iout,
            ai0: currentRecord?.ai0 === 'pending' ? '-' : currentRecord?.ai0,
            ai1: currentRecord?.ai1 === 'pending' ? '-' : currentRecord?.ai1,
            ai2: currentRecord?.ai2 === 'pending' ? '-' : currentRecord?.ai2,
            powerLight: currentRecord?.powerLight === 'pending' ? '-' : currentRecord?.powerLight,
            rs485Light: currentRecord?.rs485Light === 'pending' ? '-' : currentRecord?.rs485Light,
            networkLight: currentRecord?.networkLight === 'pending' ? '-' : currentRecord?.networkLight,
            web: currentRecord?.web === 'pending' ? '-' : currentRecord?.web
        };
        await this.finishTest({ ...currentRecord, sn, ...skippedItems }, app);
    },
    async finishTest(result, app) {
        if (!app.state.test.inProgress) return;
        await app.serial.test.stopReadLoop();
        app.state.test.inProgress = false;
        Object.values(app.state.test.stepTimeouts).forEach(clearTimeout);
        app.state.test.stepTimeouts = {};
        app.state.test.stepRetryCount = {};
        app.state.test.skipWebTest = false;
        app.state.test.currentStep = 'DONE';
        
        const hardwareTests = [result.serial, result.vout, result.iout, result.ai0, result.ai1, result.ai2, result.powerLight, result.rs485Light, result.networkLight];
        const allHardwarePass = hardwareTests.every(test => test === true || test === '-');
        const finalStatus = result.web === 'æœªæ’å¡' ? allHardwarePass : (result.web === '-' ? false : allHardwarePass && result.web);
        
        RecordManager.createOrUpdate({ ...result, status: finalStatus, isNewTest: false });
        UIManager.log(`ğŸ“Š æµ‹è¯•å®Œæˆ: ${finalStatus ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
        UIManager.update('testMsg', `âœ… æµ‹è¯•å®Œæˆ: ${finalStatus ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`, finalStatus ? 'success' : 'error');
        UIManager.showTestResult(finalStatus);
        
        if (config.autoReport) {
            app.state.reporting = true;
            UIManager.updateButtons(app);
            await RecordManager.report(app.state.test.failureItems);
            app.state.reporting = false;
        }
        
        app.state.test.hasFailure = false;
        app.state.test.failureItems = [];
        
        UIManager.updateButtons(app);
        ui.scanInput.value = '';
        ui.scanInput.focus();
    },
    startStatusReadLoop(app) {
        app.serial.status.readLoop(text => {
            app.serial.status.buffer += text;
            if (app.serial.status.buffer.includes('Color_C=')) {
                this.parseStatus(app.serial.status.buffer.trim(), app);
                app.serial.status.buffer = '';
            }
        }, err => {
            UIManager.log(`âŒ çŠ¶æ€ä¸²å£è¯»å–é”™è¯¯: ${err.message}`);
            app.toggleConnection('status');
        });
    },
    async parseStatus(data, app) {
        const parsed = {};
        data.split(/\r?\n/).forEach(line => {
            const match = line.match(/^(\w+)[=:]\s*(.+)/);
            if (match) parsed[match[1].toLowerCase()] = match[2].trim();
        });
        if (parsed.color_r) app.state.device.colorR = parseFloat(parsed.color_r) || 0;
        const previousState = app.state.device.status?.state;
        app.state.device.status = parsed;
        if (previousState !== parsed.state) {
            app.state.device.ready = parsed.state === 'Ready';
            UIManager.update('statusMsg', app.state.device.ready ? 'âœ… è®¾å¤‡å·²å°±ç»ª' : 'â„¹ï¸ è®¾å¤‡æœªå°±ç»ª', app.state.device.ready ? 'success' : 'info');
            if (app.state.device.ready) {setTimeout(() => {ui.scanInput.focus(); UIManager.log('âœ… è®¾å¤‡å·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•');}, 100);}
            else { 
                //await new Promise(resolve => setTimeout(resolve, 2000)); 
                //await app.serial.status.writer.write(new TextEncoder().encode('AT+CAL\r\n')); 
                //UIManager.log('ğŸ”§ å·²æ ¡å‡†ç”µå‹é‡‡é›†')
            }
        }
        UIManager.updateButtons(app);
    },
    async getAverageValue(sampleFunction) {
        const samples = [];
        for (let i = 0; i < config.sampling.count; i++) {
            samples.push(await sampleFunction());
            if (i < config.sampling.count - 1) await new Promise(resolve => setTimeout(resolve, config.sampling.interval));
        }
        samples.sort((a, b) => a - b);
        if (samples.length <= 2) return samples[0] || 0;
        const validSamples = samples.slice(1, -1);
        const average = validSamples.reduce((sum, val) => sum + val, 0) / validSamples.length;
        UIManager.log(`ğŸ“Š é‡‡æ ·æ•°æ®: [${samples.join(', ')}] -> å¹³å‡å€¼: ${average.toFixed(3)}`);
        return average;
    },
    setStepTimeout(step, callback, timeout, app) {
        this.clearStepTimeout(step, app);
        app.state.test.stepTimeouts[step] = setTimeout(callback, timeout);
    },
    clearStepTimeout(step, app) {
        if (app.state.test.stepTimeouts[step]) clearTimeout(app.state.test.stepTimeouts[step]);
    }
};

if ('serial' in navigator) {
    app.init();
} else {
    alert('é”™è¯¯ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆçš„ Chrome æˆ– Edge æµè§ˆå™¨ã€‚');
    document.body.innerHTML = '<h1>æµè§ˆå™¨ä¸å…¼å®¹</h1>';
}
</script>
</body>
</html>
